
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model AcademicSemester
 * 
 */
export type AcademicSemester = $Result.DefaultSelection<Prisma.$AcademicSemesterPayload>
/**
 * Model AcademicFaculty
 * 
 */
export type AcademicFaculty = $Result.DefaultSelection<Prisma.$AcademicFacultyPayload>
/**
 * Model AcademicDepartment
 * 
 */
export type AcademicDepartment = $Result.DefaultSelection<Prisma.$AcademicDepartmentPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Faculty
 * 
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>
/**
 * Model Building
 * 
 */
export type Building = $Result.DefaultSelection<Prisma.$BuildingPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseToPrerequisite
 * 
 */
export type CourseToPrerequisite = $Result.DefaultSelection<Prisma.$CourseToPrerequisitePayload>
/**
 * Model CourseFaculty
 * 
 */
export type CourseFaculty = $Result.DefaultSelection<Prisma.$CourseFacultyPayload>
/**
 * Model SemesterRegistration
 * 
 */
export type SemesterRegistration = $Result.DefaultSelection<Prisma.$SemesterRegistrationPayload>
/**
 * Model OfferedCourse
 * 
 */
export type OfferedCourse = $Result.DefaultSelection<Prisma.$OfferedCoursePayload>
/**
 * Model OfferedCourseSection
 * 
 */
export type OfferedCourseSection = $Result.DefaultSelection<Prisma.$OfferedCourseSectionPayload>
/**
 * Model OfferedCourseClassSchedule
 * 
 */
export type OfferedCourseClassSchedule = $Result.DefaultSelection<Prisma.$OfferedCourseClassSchedulePayload>
/**
 * Model StudentSemesterRegistration
 * 
 */
export type StudentSemesterRegistration = $Result.DefaultSelection<Prisma.$StudentSemesterRegistrationPayload>
/**
 * Model StudentSemesterRegistrationCourse
 * 
 */
export type StudentSemesterRegistrationCourse = $Result.DefaultSelection<Prisma.$StudentSemesterRegistrationCoursePayload>
/**
 * Model StudentEnrolledCourse
 * 
 */
export type StudentEnrolledCourse = $Result.DefaultSelection<Prisma.$StudentEnrolledCoursePayload>
/**
 * Model StudentEnrolledCourseMark
 * 
 */
export type StudentEnrolledCourseMark = $Result.DefaultSelection<Prisma.$StudentEnrolledCourseMarkPayload>
/**
 * Model StudentSemesterPayment
 * 
 */
export type StudentSemesterPayment = $Result.DefaultSelection<Prisma.$StudentSemesterPaymentPayload>
/**
 * Model StudentSemesterPaymentHistory
 * 
 */
export type StudentSemesterPaymentHistory = $Result.DefaultSelection<Prisma.$StudentSemesterPaymentHistoryPayload>
/**
 * Model StudentAcademicInfo
 * 
 */
export type StudentAcademicInfo = $Result.DefaultSelection<Prisma.$StudentAcademicInfoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SemesterRegistrationStatus: {
  UPCOMING: 'UPCOMING',
  ONGOING: 'ONGOING',
  ENDED: 'ENDED'
};

export type SemesterRegistrationStatus = (typeof SemesterRegistrationStatus)[keyof typeof SemesterRegistrationStatus]


export const WeekDays: {
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY',
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY'
};

export type WeekDays = (typeof WeekDays)[keyof typeof WeekDays]


export const StudentEnrolledCourseStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  WITHDRAWN: 'WITHDRAWN'
};

export type StudentEnrolledCourseStatus = (typeof StudentEnrolledCourseStatus)[keyof typeof StudentEnrolledCourseStatus]


export const ExamType: {
  MIDTERM: 'MIDTERM',
  FINAL: 'FINAL'
};

export type ExamType = (typeof ExamType)[keyof typeof ExamType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PARTIAL_PAID: 'PARTIAL_PAID',
  FULL_PAID: 'FULL_PAID'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  ONLINE: 'ONLINE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]

}

export type SemesterRegistrationStatus = $Enums.SemesterRegistrationStatus

export const SemesterRegistrationStatus: typeof $Enums.SemesterRegistrationStatus

export type WeekDays = $Enums.WeekDays

export const WeekDays: typeof $Enums.WeekDays

export type StudentEnrolledCourseStatus = $Enums.StudentEnrolledCourseStatus

export const StudentEnrolledCourseStatus: typeof $Enums.StudentEnrolledCourseStatus

export type ExamType = $Enums.ExamType

export const ExamType: typeof $Enums.ExamType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more AcademicSemesters
 * const academicSemesters = await prisma.academicSemester.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more AcademicSemesters
   * const academicSemesters = await prisma.academicSemester.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.academicSemester`: Exposes CRUD operations for the **AcademicSemester** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicSemesters
    * const academicSemesters = await prisma.academicSemester.findMany()
    * ```
    */
  get academicSemester(): Prisma.AcademicSemesterDelegate<ExtArgs>;

  /**
   * `prisma.academicFaculty`: Exposes CRUD operations for the **AcademicFaculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicFaculties
    * const academicFaculties = await prisma.academicFaculty.findMany()
    * ```
    */
  get academicFaculty(): Prisma.AcademicFacultyDelegate<ExtArgs>;

  /**
   * `prisma.academicDepartment`: Exposes CRUD operations for the **AcademicDepartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicDepartments
    * const academicDepartments = await prisma.academicDepartment.findMany()
    * ```
    */
  get academicDepartment(): Prisma.AcademicDepartmentDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<ExtArgs>;

  /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.BuildingDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.courseToPrerequisite`: Exposes CRUD operations for the **CourseToPrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseToPrerequisites
    * const courseToPrerequisites = await prisma.courseToPrerequisite.findMany()
    * ```
    */
  get courseToPrerequisite(): Prisma.CourseToPrerequisiteDelegate<ExtArgs>;

  /**
   * `prisma.courseFaculty`: Exposes CRUD operations for the **CourseFaculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseFaculties
    * const courseFaculties = await prisma.courseFaculty.findMany()
    * ```
    */
  get courseFaculty(): Prisma.CourseFacultyDelegate<ExtArgs>;

  /**
   * `prisma.semesterRegistration`: Exposes CRUD operations for the **SemesterRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SemesterRegistrations
    * const semesterRegistrations = await prisma.semesterRegistration.findMany()
    * ```
    */
  get semesterRegistration(): Prisma.SemesterRegistrationDelegate<ExtArgs>;

  /**
   * `prisma.offeredCourse`: Exposes CRUD operations for the **OfferedCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourses
    * const offeredCourses = await prisma.offeredCourse.findMany()
    * ```
    */
  get offeredCourse(): Prisma.OfferedCourseDelegate<ExtArgs>;

  /**
   * `prisma.offeredCourseSection`: Exposes CRUD operations for the **OfferedCourseSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourseSections
    * const offeredCourseSections = await prisma.offeredCourseSection.findMany()
    * ```
    */
  get offeredCourseSection(): Prisma.OfferedCourseSectionDelegate<ExtArgs>;

  /**
   * `prisma.offeredCourseClassSchedule`: Exposes CRUD operations for the **OfferedCourseClassSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferedCourseClassSchedules
    * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany()
    * ```
    */
  get offeredCourseClassSchedule(): Prisma.OfferedCourseClassScheduleDelegate<ExtArgs>;

  /**
   * `prisma.studentSemesterRegistration`: Exposes CRUD operations for the **StudentSemesterRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterRegistrations
    * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany()
    * ```
    */
  get studentSemesterRegistration(): Prisma.StudentSemesterRegistrationDelegate<ExtArgs>;

  /**
   * `prisma.studentSemesterRegistrationCourse`: Exposes CRUD operations for the **StudentSemesterRegistrationCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterRegistrationCourses
    * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany()
    * ```
    */
  get studentSemesterRegistrationCourse(): Prisma.StudentSemesterRegistrationCourseDelegate<ExtArgs>;

  /**
   * `prisma.studentEnrolledCourse`: Exposes CRUD operations for the **StudentEnrolledCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrolledCourses
    * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany()
    * ```
    */
  get studentEnrolledCourse(): Prisma.StudentEnrolledCourseDelegate<ExtArgs>;

  /**
   * `prisma.studentEnrolledCourseMark`: Exposes CRUD operations for the **StudentEnrolledCourseMark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentEnrolledCourseMarks
    * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany()
    * ```
    */
  get studentEnrolledCourseMark(): Prisma.StudentEnrolledCourseMarkDelegate<ExtArgs>;

  /**
   * `prisma.studentSemesterPayment`: Exposes CRUD operations for the **StudentSemesterPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterPayments
    * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany()
    * ```
    */
  get studentSemesterPayment(): Prisma.StudentSemesterPaymentDelegate<ExtArgs>;

  /**
   * `prisma.studentSemesterPaymentHistory`: Exposes CRUD operations for the **StudentSemesterPaymentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSemesterPaymentHistories
    * const studentSemesterPaymentHistories = await prisma.studentSemesterPaymentHistory.findMany()
    * ```
    */
  get studentSemesterPaymentHistory(): Prisma.StudentSemesterPaymentHistoryDelegate<ExtArgs>;

  /**
   * `prisma.studentAcademicInfo`: Exposes CRUD operations for the **StudentAcademicInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAcademicInfos
    * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany()
    * ```
    */
  get studentAcademicInfo(): Prisma.StudentAcademicInfoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.1.1
   * Query Engine version: e95e739751f42d8ca026f6b910f5a2dc5adeaeee
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    AcademicSemester: 'AcademicSemester',
    AcademicFaculty: 'AcademicFaculty',
    AcademicDepartment: 'AcademicDepartment',
    Student: 'Student',
    Faculty: 'Faculty',
    Building: 'Building',
    Room: 'Room',
    Course: 'Course',
    CourseToPrerequisite: 'CourseToPrerequisite',
    CourseFaculty: 'CourseFaculty',
    SemesterRegistration: 'SemesterRegistration',
    OfferedCourse: 'OfferedCourse',
    OfferedCourseSection: 'OfferedCourseSection',
    OfferedCourseClassSchedule: 'OfferedCourseClassSchedule',
    StudentSemesterRegistration: 'StudentSemesterRegistration',
    StudentSemesterRegistrationCourse: 'StudentSemesterRegistrationCourse',
    StudentEnrolledCourse: 'StudentEnrolledCourse',
    StudentEnrolledCourseMark: 'StudentEnrolledCourseMark',
    StudentSemesterPayment: 'StudentSemesterPayment',
    StudentSemesterPaymentHistory: 'StudentSemesterPaymentHistory',
    StudentAcademicInfo: 'StudentAcademicInfo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'academicSemester' | 'academicFaculty' | 'academicDepartment' | 'student' | 'faculty' | 'building' | 'room' | 'course' | 'courseToPrerequisite' | 'courseFaculty' | 'semesterRegistration' | 'offeredCourse' | 'offeredCourseSection' | 'offeredCourseClassSchedule' | 'studentSemesterRegistration' | 'studentSemesterRegistrationCourse' | 'studentEnrolledCourse' | 'studentEnrolledCourseMark' | 'studentSemesterPayment' | 'studentSemesterPaymentHistory' | 'studentAcademicInfo'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      AcademicSemester: {
        payload: Prisma.$AcademicSemesterPayload<ExtArgs>
        fields: Prisma.AcademicSemesterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicSemesterFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicSemesterFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          findFirst: {
            args: Prisma.AcademicSemesterFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicSemesterFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          findMany: {
            args: Prisma.AcademicSemesterFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>[]
          }
          create: {
            args: Prisma.AcademicSemesterCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          createMany: {
            args: Prisma.AcademicSemesterCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AcademicSemesterDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          update: {
            args: Prisma.AcademicSemesterUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          deleteMany: {
            args: Prisma.AcademicSemesterDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicSemesterUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AcademicSemesterUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicSemesterPayload>
          }
          aggregate: {
            args: Prisma.AcademicSemesterAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAcademicSemester>
          }
          groupBy: {
            args: Prisma.AcademicSemesterGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AcademicSemesterGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicSemesterCountArgs<ExtArgs>,
            result: $Utils.Optional<AcademicSemesterCountAggregateOutputType> | number
          }
        }
      }
      AcademicFaculty: {
        payload: Prisma.$AcademicFacultyPayload<ExtArgs>
        fields: Prisma.AcademicFacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicFacultyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicFacultyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          findFirst: {
            args: Prisma.AcademicFacultyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicFacultyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          findMany: {
            args: Prisma.AcademicFacultyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>[]
          }
          create: {
            args: Prisma.AcademicFacultyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          createMany: {
            args: Prisma.AcademicFacultyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AcademicFacultyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          update: {
            args: Prisma.AcademicFacultyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          deleteMany: {
            args: Prisma.AcademicFacultyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicFacultyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AcademicFacultyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicFacultyPayload>
          }
          aggregate: {
            args: Prisma.AcademicFacultyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAcademicFaculty>
          }
          groupBy: {
            args: Prisma.AcademicFacultyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AcademicFacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicFacultyCountArgs<ExtArgs>,
            result: $Utils.Optional<AcademicFacultyCountAggregateOutputType> | number
          }
        }
      }
      AcademicDepartment: {
        payload: Prisma.$AcademicDepartmentPayload<ExtArgs>
        fields: Prisma.AcademicDepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicDepartmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          findFirst: {
            args: Prisma.AcademicDepartmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicDepartmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          findMany: {
            args: Prisma.AcademicDepartmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>[]
          }
          create: {
            args: Prisma.AcademicDepartmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          createMany: {
            args: Prisma.AcademicDepartmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AcademicDepartmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          update: {
            args: Prisma.AcademicDepartmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          deleteMany: {
            args: Prisma.AcademicDepartmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicDepartmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AcademicDepartmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcademicDepartmentPayload>
          }
          aggregate: {
            args: Prisma.AcademicDepartmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAcademicDepartment>
          }
          groupBy: {
            args: Prisma.AcademicDepartmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AcademicDepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicDepartmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AcademicDepartmentCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>
        fields: Prisma.FacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>,
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      Building: {
        payload: Prisma.$BuildingPayload<ExtArgs>
        fields: Prisma.BuildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findFirst: {
            args: Prisma.BuildingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findMany: {
            args: Prisma.BuildingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          create: {
            args: Prisma.BuildingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          createMany: {
            args: Prisma.BuildingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BuildingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          update: {
            args: Prisma.BuildingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          deleteMany: {
            args: Prisma.BuildingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BuildingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.BuildingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingCountArgs<ExtArgs>,
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>,
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>,
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseToPrerequisite: {
        payload: Prisma.$CourseToPrerequisitePayload<ExtArgs>
        fields: Prisma.CourseToPrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseToPrerequisiteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseToPrerequisiteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload>
          }
          findFirst: {
            args: Prisma.CourseToPrerequisiteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseToPrerequisiteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload>
          }
          findMany: {
            args: Prisma.CourseToPrerequisiteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload>[]
          }
          create: {
            args: Prisma.CourseToPrerequisiteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload>
          }
          createMany: {
            args: Prisma.CourseToPrerequisiteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourseToPrerequisiteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload>
          }
          update: {
            args: Prisma.CourseToPrerequisiteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.CourseToPrerequisiteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourseToPrerequisiteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourseToPrerequisiteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseToPrerequisitePayload>
          }
          aggregate: {
            args: Prisma.CourseToPrerequisiteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourseToPrerequisite>
          }
          groupBy: {
            args: Prisma.CourseToPrerequisiteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourseToPrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseToPrerequisiteCountArgs<ExtArgs>,
            result: $Utils.Optional<CourseToPrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      CourseFaculty: {
        payload: Prisma.$CourseFacultyPayload<ExtArgs>
        fields: Prisma.CourseFacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFacultyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFacultyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          findFirst: {
            args: Prisma.CourseFacultyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFacultyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          findMany: {
            args: Prisma.CourseFacultyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>[]
          }
          create: {
            args: Prisma.CourseFacultyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          createMany: {
            args: Prisma.CourseFacultyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourseFacultyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          update: {
            args: Prisma.CourseFacultyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          deleteMany: {
            args: Prisma.CourseFacultyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourseFacultyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourseFacultyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CourseFacultyPayload>
          }
          aggregate: {
            args: Prisma.CourseFacultyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourseFaculty>
          }
          groupBy: {
            args: Prisma.CourseFacultyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourseFacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseFacultyCountArgs<ExtArgs>,
            result: $Utils.Optional<CourseFacultyCountAggregateOutputType> | number
          }
        }
      }
      SemesterRegistration: {
        payload: Prisma.$SemesterRegistrationPayload<ExtArgs>
        fields: Prisma.SemesterRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SemesterRegistrationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          findFirst: {
            args: Prisma.SemesterRegistrationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SemesterRegistrationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          findMany: {
            args: Prisma.SemesterRegistrationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>[]
          }
          create: {
            args: Prisma.SemesterRegistrationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          createMany: {
            args: Prisma.SemesterRegistrationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SemesterRegistrationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          update: {
            args: Prisma.SemesterRegistrationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.SemesterRegistrationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SemesterRegistrationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SemesterRegistrationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SemesterRegistrationPayload>
          }
          aggregate: {
            args: Prisma.SemesterRegistrationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSemesterRegistration>
          }
          groupBy: {
            args: Prisma.SemesterRegistrationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SemesterRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SemesterRegistrationCountArgs<ExtArgs>,
            result: $Utils.Optional<SemesterRegistrationCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourse: {
        payload: Prisma.$OfferedCoursePayload<ExtArgs>
        fields: Prisma.OfferedCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          findMany: {
            args: Prisma.OfferedCourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>[]
          }
          create: {
            args: Prisma.OfferedCourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          createMany: {
            args: Prisma.OfferedCourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          update: {
            args: Prisma.OfferedCourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCoursePayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOfferedCourse>
          }
          groupBy: {
            args: Prisma.OfferedCourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfferedCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseCountArgs<ExtArgs>,
            result: $Utils.Optional<OfferedCourseCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourseSection: {
        payload: Prisma.$OfferedCourseSectionPayload<ExtArgs>
        fields: Prisma.OfferedCourseSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseSectionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseSectionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          findMany: {
            args: Prisma.OfferedCourseSectionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>[]
          }
          create: {
            args: Prisma.OfferedCourseSectionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          createMany: {
            args: Prisma.OfferedCourseSectionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseSectionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          update: {
            args: Prisma.OfferedCourseSectionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseSectionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseSectionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseSectionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseSectionPayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseSectionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOfferedCourseSection>
          }
          groupBy: {
            args: Prisma.OfferedCourseSectionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfferedCourseSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseSectionCountArgs<ExtArgs>,
            result: $Utils.Optional<OfferedCourseSectionCountAggregateOutputType> | number
          }
        }
      }
      OfferedCourseClassSchedule: {
        payload: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>
        fields: Prisma.OfferedCourseClassScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferedCourseClassScheduleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          findFirst: {
            args: Prisma.OfferedCourseClassScheduleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          findMany: {
            args: Prisma.OfferedCourseClassScheduleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>[]
          }
          create: {
            args: Prisma.OfferedCourseClassScheduleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          createMany: {
            args: Prisma.OfferedCourseClassScheduleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OfferedCourseClassScheduleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          update: {
            args: Prisma.OfferedCourseClassScheduleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          deleteMany: {
            args: Prisma.OfferedCourseClassScheduleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OfferedCourseClassScheduleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OfferedCourseClassScheduleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OfferedCourseClassSchedulePayload>
          }
          aggregate: {
            args: Prisma.OfferedCourseClassScheduleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOfferedCourseClassSchedule>
          }
          groupBy: {
            args: Prisma.OfferedCourseClassScheduleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OfferedCourseClassScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferedCourseClassScheduleCountArgs<ExtArgs>,
            result: $Utils.Optional<OfferedCourseClassScheduleCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterRegistration: {
        payload: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>
        fields: Prisma.StudentSemesterRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterRegistrationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterRegistrationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          findMany: {
            args: Prisma.StudentSemesterRegistrationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>[]
          }
          create: {
            args: Prisma.StudentSemesterRegistrationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          createMany: {
            args: Prisma.StudentSemesterRegistrationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterRegistrationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          update: {
            args: Prisma.StudentSemesterRegistrationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterRegistrationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterRegistrationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterRegistrationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationPayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterRegistrationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentSemesterRegistration>
          }
          groupBy: {
            args: Prisma.StudentSemesterRegistrationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterRegistrationCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterRegistrationCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterRegistrationCourse: {
        payload: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>
        fields: Prisma.StudentSemesterRegistrationCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          findMany: {
            args: Prisma.StudentSemesterRegistrationCourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>[]
          }
          create: {
            args: Prisma.StudentSemesterRegistrationCourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          createMany: {
            args: Prisma.StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterRegistrationCourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          update: {
            args: Prisma.StudentSemesterRegistrationCourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterRegistrationCourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterRegistrationCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterRegistrationCourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentSemesterRegistrationCourse>
          }
          groupBy: {
            args: Prisma.StudentSemesterRegistrationCourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterRegistrationCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterRegistrationCourseCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterRegistrationCourseCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrolledCourse: {
        payload: Prisma.$StudentEnrolledCoursePayload<ExtArgs>
        fields: Prisma.StudentEnrolledCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrolledCourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentEnrolledCourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          findMany: {
            args: Prisma.StudentEnrolledCourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>[]
          }
          create: {
            args: Prisma.StudentEnrolledCourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          createMany: {
            args: Prisma.StudentEnrolledCourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentEnrolledCourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          update: {
            args: Prisma.StudentEnrolledCourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrolledCourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrolledCourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentEnrolledCourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentEnrolledCourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentEnrolledCourse>
          }
          groupBy: {
            args: Prisma.StudentEnrolledCourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentEnrolledCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrolledCourseCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentEnrolledCourseCountAggregateOutputType> | number
          }
        }
      }
      StudentEnrolledCourseMark: {
        payload: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>
        fields: Prisma.StudentEnrolledCourseMarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          findFirst: {
            args: Prisma.StudentEnrolledCourseMarkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          findMany: {
            args: Prisma.StudentEnrolledCourseMarkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>[]
          }
          create: {
            args: Prisma.StudentEnrolledCourseMarkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          createMany: {
            args: Prisma.StudentEnrolledCourseMarkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentEnrolledCourseMarkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          update: {
            args: Prisma.StudentEnrolledCourseMarkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          deleteMany: {
            args: Prisma.StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentEnrolledCourseMarkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentEnrolledCourseMarkPayload>
          }
          aggregate: {
            args: Prisma.StudentEnrolledCourseMarkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentEnrolledCourseMark>
          }
          groupBy: {
            args: Prisma.StudentEnrolledCourseMarkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentEnrolledCourseMarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentEnrolledCourseMarkCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentEnrolledCourseMarkCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterPayment: {
        payload: Prisma.$StudentSemesterPaymentPayload<ExtArgs>
        fields: Prisma.StudentSemesterPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterPaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterPaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          findMany: {
            args: Prisma.StudentSemesterPaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>[]
          }
          create: {
            args: Prisma.StudentSemesterPaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          createMany: {
            args: Prisma.StudentSemesterPaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterPaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          update: {
            args: Prisma.StudentSemesterPaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterPaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterPaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterPaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentPayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterPaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentSemesterPayment>
          }
          groupBy: {
            args: Prisma.StudentSemesterPaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterPaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterPaymentCountAggregateOutputType> | number
          }
        }
      }
      StudentSemesterPaymentHistory: {
        payload: Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>
        fields: Prisma.StudentSemesterPaymentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSemesterPaymentHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSemesterPaymentHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload>
          }
          findFirst: {
            args: Prisma.StudentSemesterPaymentHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSemesterPaymentHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload>
          }
          findMany: {
            args: Prisma.StudentSemesterPaymentHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload>[]
          }
          create: {
            args: Prisma.StudentSemesterPaymentHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload>
          }
          createMany: {
            args: Prisma.StudentSemesterPaymentHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentSemesterPaymentHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload>
          }
          update: {
            args: Prisma.StudentSemesterPaymentHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.StudentSemesterPaymentHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSemesterPaymentHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentSemesterPaymentHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentSemesterPaymentHistoryPayload>
          }
          aggregate: {
            args: Prisma.StudentSemesterPaymentHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentSemesterPaymentHistory>
          }
          groupBy: {
            args: Prisma.StudentSemesterPaymentHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterPaymentHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSemesterPaymentHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentSemesterPaymentHistoryCountAggregateOutputType> | number
          }
        }
      }
      StudentAcademicInfo: {
        payload: Prisma.$StudentAcademicInfoPayload<ExtArgs>
        fields: Prisma.StudentAcademicInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAcademicInfoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          findFirst: {
            args: Prisma.StudentAcademicInfoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          findMany: {
            args: Prisma.StudentAcademicInfoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>[]
          }
          create: {
            args: Prisma.StudentAcademicInfoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          createMany: {
            args: Prisma.StudentAcademicInfoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentAcademicInfoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          update: {
            args: Prisma.StudentAcademicInfoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          deleteMany: {
            args: Prisma.StudentAcademicInfoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAcademicInfoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentAcademicInfoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentAcademicInfoPayload>
          }
          aggregate: {
            args: Prisma.StudentAcademicInfoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentAcademicInfo>
          }
          groupBy: {
            args: Prisma.StudentAcademicInfoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentAcademicInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAcademicInfoCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentAcademicInfoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AcademicSemesterCountOutputType
   */

  export type AcademicSemesterCountOutputType = {
    students: number
    semesterRegistrations: number
    studentEnrolledCourses: number
    studentEnrolledCourseMarks: number
    studentSemesterPayments: number
  }

  export type AcademicSemesterCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    students?: boolean | AcademicSemesterCountOutputTypeCountStudentsArgs
    semesterRegistrations?: boolean | AcademicSemesterCountOutputTypeCountSemesterRegistrationsArgs
    studentEnrolledCourses?: boolean | AcademicSemesterCountOutputTypeCountStudentEnrolledCoursesArgs
    studentEnrolledCourseMarks?: boolean | AcademicSemesterCountOutputTypeCountStudentEnrolledCourseMarksArgs
    studentSemesterPayments?: boolean | AcademicSemesterCountOutputTypeCountStudentSemesterPaymentsArgs
  }

  // Custom InputTypes

  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemesterCountOutputType
     */
    select?: AcademicSemesterCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountSemesterRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SemesterRegistrationWhereInput
  }


  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }


  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }


  /**
   * AcademicSemesterCountOutputType without action
   */
  export type AcademicSemesterCountOutputTypeCountStudentSemesterPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
  }



  /**
   * Count Type AcademicFacultyCountOutputType
   */

  export type AcademicFacultyCountOutputType = {
    academicDepartments: number
    students: number
    faculties: number
  }

  export type AcademicFacultyCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    academicDepartments?: boolean | AcademicFacultyCountOutputTypeCountAcademicDepartmentsArgs
    students?: boolean | AcademicFacultyCountOutputTypeCountStudentsArgs
    faculties?: boolean | AcademicFacultyCountOutputTypeCountFacultiesArgs
  }

  // Custom InputTypes

  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFacultyCountOutputType
     */
    select?: AcademicFacultyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountAcademicDepartmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AcademicDepartmentWhereInput
  }


  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * AcademicFacultyCountOutputType without action
   */
  export type AcademicFacultyCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
  }



  /**
   * Count Type AcademicDepartmentCountOutputType
   */

  export type AcademicDepartmentCountOutputType = {
    students: number
    faculties: number
    offeredCourses: number
  }

  export type AcademicDepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    students?: boolean | AcademicDepartmentCountOutputTypeCountStudentsArgs
    faculties?: boolean | AcademicDepartmentCountOutputTypeCountFacultiesArgs
    offeredCourses?: boolean | AcademicDepartmentCountOutputTypeCountOfferedCoursesArgs
  }

  // Custom InputTypes

  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartmentCountOutputType
     */
    select?: AcademicDepartmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
  }


  /**
   * AcademicDepartmentCountOutputType without action
   */
  export type AcademicDepartmentCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }



  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    studentSemesterRegistrations: number
    studentSemesterRegistrationCourses: number
    studentEnrolledCourses: number
    studentEnrolledCourseMarks: number
    studentSemesterPayments: number
    studentAcademicInfos: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    studentSemesterRegistrations?: boolean | StudentCountOutputTypeCountStudentSemesterRegistrationsArgs
    studentSemesterRegistrationCourses?: boolean | StudentCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
    studentEnrolledCourses?: boolean | StudentCountOutputTypeCountStudentEnrolledCoursesArgs
    studentEnrolledCourseMarks?: boolean | StudentCountOutputTypeCountStudentEnrolledCourseMarksArgs
    studentSemesterPayments?: boolean | StudentCountOutputTypeCountStudentSemesterPaymentsArgs
    studentAcademicInfos?: boolean | StudentCountOutputTypeCountStudentAcademicInfosArgs
  }

  // Custom InputTypes

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSemesterPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
  }


  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentAcademicInfosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentAcademicInfoWhereInput
  }



  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    courses: number
    offeredCourseClassSchedules: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    courses?: boolean | FacultyCountOutputTypeCountCoursesArgs
    offeredCourseClassSchedules?: boolean | FacultyCountOutputTypeCountOfferedCourseClassSchedulesArgs
  }

  // Custom InputTypes

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
  }


  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }



  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    rooms: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    rooms?: boolean | BuildingCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }



  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    offeredCourseClassSchedules: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offeredCourseClassSchedules?: boolean | RoomCountOutputTypeCountOfferedCourseClassSchedulesArgs
  }

  // Custom InputTypes

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }



  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    preRequisite: number
    preRequisiteFor: number
    faculties: number
    offeredCourses: number
    studentEnrolledCourses: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    preRequisite?: boolean | CourseCountOutputTypeCountPreRequisiteArgs
    preRequisiteFor?: boolean | CourseCountOutputTypeCountPreRequisiteForArgs
    faculties?: boolean | CourseCountOutputTypeCountFacultiesArgs
    offeredCourses?: boolean | CourseCountOutputTypeCountOfferedCoursesArgs
    studentEnrolledCourses?: boolean | CourseCountOutputTypeCountStudentEnrolledCoursesArgs
  }

  // Custom InputTypes

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPreRequisiteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseToPrerequisiteWhereInput
  }


  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPreRequisiteForArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseToPrerequisiteWhereInput
  }


  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
  }


  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }


  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudentEnrolledCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
  }



  /**
   * Count Type SemesterRegistrationCountOutputType
   */

  export type SemesterRegistrationCountOutputType = {
    offeredCourses: number
    offeredCourseSections: number
    offeredCourseClassSchedules: number
    studentSemesterRegistrations: number
    studentSemesterRegistrationCourses: number
  }

  export type SemesterRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offeredCourses?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCoursesArgs
    offeredCourseSections?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCourseSectionsArgs
    offeredCourseClassSchedules?: boolean | SemesterRegistrationCountOutputTypeCountOfferedCourseClassSchedulesArgs
    studentSemesterRegistrations?: boolean | SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationsArgs
    studentSemesterRegistrationCourses?: boolean | SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes

  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistrationCountOutputType
     */
    select?: SemesterRegistrationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
  }


  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCourseSectionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
  }


  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
  }


  /**
   * SemesterRegistrationCountOutputType without action
   */
  export type SemesterRegistrationCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }



  /**
   * Count Type OfferedCourseCountOutputType
   */

  export type OfferedCourseCountOutputType = {
    offeredCourseSections: number
    studentSemesterRegistrationCourses: number
  }

  export type OfferedCourseCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offeredCourseSections?: boolean | OfferedCourseCountOutputTypeCountOfferedCourseSectionsArgs
    studentSemesterRegistrationCourses?: boolean | OfferedCourseCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes

  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseCountOutputType
     */
    select?: OfferedCourseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeCountOfferedCourseSectionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
  }


  /**
   * OfferedCourseCountOutputType without action
   */
  export type OfferedCourseCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }



  /**
   * Count Type OfferedCourseSectionCountOutputType
   */

  export type OfferedCourseSectionCountOutputType = {
    offeredCourseClassSchedules: number
    studentSemesterRegistrationCourses: number
  }

  export type OfferedCourseSectionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offeredCourseClassSchedules?: boolean | OfferedCourseSectionCountOutputTypeCountOfferedCourseClassSchedulesArgs
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSectionCountOutputTypeCountStudentSemesterRegistrationCoursesArgs
  }

  // Custom InputTypes

  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSectionCountOutputType
     */
    select?: OfferedCourseSectionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeCountOfferedCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * OfferedCourseSectionCountOutputType without action
   */
  export type OfferedCourseSectionCountOutputTypeCountStudentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
  }



  /**
   * Count Type StudentEnrolledCourseCountOutputType
   */

  export type StudentEnrolledCourseCountOutputType = {
    studentEnrolledCourseMarks: number
  }

  export type StudentEnrolledCourseCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourseCountOutputTypeCountStudentEnrolledCourseMarksArgs
  }

  // Custom InputTypes

  /**
   * StudentEnrolledCourseCountOutputType without action
   */
  export type StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseCountOutputType
     */
    select?: StudentEnrolledCourseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentEnrolledCourseCountOutputType without action
   */
  export type StudentEnrolledCourseCountOutputTypeCountStudentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
  }



  /**
   * Count Type StudentSemesterPaymentCountOutputType
   */

  export type StudentSemesterPaymentCountOutputType = {
    StudentSemesterPaymentHistory: number
  }

  export type StudentSemesterPaymentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    StudentSemesterPaymentHistory?: boolean | StudentSemesterPaymentCountOutputTypeCountStudentSemesterPaymentHistoryArgs
  }

  // Custom InputTypes

  /**
   * StudentSemesterPaymentCountOutputType without action
   */
  export type StudentSemesterPaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentCountOutputType
     */
    select?: StudentSemesterPaymentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentSemesterPaymentCountOutputType without action
   */
  export type StudentSemesterPaymentCountOutputTypeCountStudentSemesterPaymentHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentHistoryWhereInput
  }



  /**
   * Models
   */

  /**
   * Model AcademicSemester
   */

  export type AggregateAcademicSemester = {
    _count: AcademicSemesterCountAggregateOutputType | null
    _avg: AcademicSemesterAvgAggregateOutputType | null
    _sum: AcademicSemesterSumAggregateOutputType | null
    _min: AcademicSemesterMinAggregateOutputType | null
    _max: AcademicSemesterMaxAggregateOutputType | null
  }

  export type AcademicSemesterAvgAggregateOutputType = {
    year: number | null
  }

  export type AcademicSemesterSumAggregateOutputType = {
    year: number | null
  }

  export type AcademicSemesterMinAggregateOutputType = {
    id: string | null
    year: number | null
    title: string | null
    code: string | null
    startMonth: string | null
    endMonth: string | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSemesterMaxAggregateOutputType = {
    id: string | null
    year: number | null
    title: string | null
    code: string | null
    startMonth: string | null
    endMonth: string | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSemesterCountAggregateOutputType = {
    id: number
    year: number
    title: number
    code: number
    startMonth: number
    endMonth: number
    isCurrent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicSemesterAvgAggregateInputType = {
    year?: true
  }

  export type AcademicSemesterSumAggregateInputType = {
    year?: true
  }

  export type AcademicSemesterMinAggregateInputType = {
    id?: true
    year?: true
    title?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSemesterMaxAggregateInputType = {
    id?: true
    year?: true
    title?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSemesterCountAggregateInputType = {
    id?: true
    year?: true
    title?: true
    code?: true
    startMonth?: true
    endMonth?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicSemesterAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSemester to aggregate.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicSemesters
    **/
    _count?: true | AcademicSemesterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicSemesterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicSemesterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicSemesterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicSemesterMaxAggregateInputType
  }

  export type GetAcademicSemesterAggregateType<T extends AcademicSemesterAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicSemester]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicSemester[P]>
      : GetScalarType<T[P], AggregateAcademicSemester[P]>
  }




  export type AcademicSemesterGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AcademicSemesterWhereInput
    orderBy?: AcademicSemesterOrderByWithAggregationInput | AcademicSemesterOrderByWithAggregationInput[]
    by: AcademicSemesterScalarFieldEnum[] | AcademicSemesterScalarFieldEnum
    having?: AcademicSemesterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicSemesterCountAggregateInputType | true
    _avg?: AcademicSemesterAvgAggregateInputType
    _sum?: AcademicSemesterSumAggregateInputType
    _min?: AcademicSemesterMinAggregateInputType
    _max?: AcademicSemesterMaxAggregateInputType
  }

  export type AcademicSemesterGroupByOutputType = {
    id: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: AcademicSemesterCountAggregateOutputType | null
    _avg: AcademicSemesterAvgAggregateOutputType | null
    _sum: AcademicSemesterSumAggregateOutputType | null
    _min: AcademicSemesterMinAggregateOutputType | null
    _max: AcademicSemesterMaxAggregateOutputType | null
  }

  type GetAcademicSemesterGroupByPayload<T extends AcademicSemesterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicSemesterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicSemesterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicSemesterGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicSemesterGroupByOutputType[P]>
        }
      >
    >


  export type AcademicSemesterSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    title?: boolean
    code?: boolean
    startMonth?: boolean
    endMonth?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    students?: boolean | AcademicSemester$studentsArgs<ExtArgs>
    semesterRegistrations?: boolean | AcademicSemester$semesterRegistrationsArgs<ExtArgs>
    studentEnrolledCourses?: boolean | AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>
    _count?: boolean | AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSemester"]>

  export type AcademicSemesterSelectScalar = {
    id?: boolean
    year?: boolean
    title?: boolean
    code?: boolean
    startMonth?: boolean
    endMonth?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicSemesterInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    students?: boolean | AcademicSemester$studentsArgs<ExtArgs>
    semesterRegistrations?: boolean | AcademicSemester$semesterRegistrationsArgs<ExtArgs>
    studentEnrolledCourses?: boolean | AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>
    _count?: boolean | AcademicSemesterCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AcademicSemesterPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "AcademicSemester"
    objects: {
      students: Prisma.$StudentPayload<ExtArgs>[]
      semesterRegistrations: Prisma.$SemesterRegistrationPayload<ExtArgs>[]
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
      studentSemesterPayments: Prisma.$StudentSemesterPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      year: number
      title: string
      code: string
      startMonth: string
      endMonth: string
      isCurrent: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicSemester"]>
    composites: {}
  }


  type AcademicSemesterGetPayload<S extends boolean | null | undefined | AcademicSemesterDefaultArgs> = $Result.GetResult<Prisma.$AcademicSemesterPayload, S>

  type AcademicSemesterCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AcademicSemesterFindManyArgs, 'select' | 'include'> & {
      select?: AcademicSemesterCountAggregateInputType | true
    }

  export interface AcademicSemesterDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicSemester'], meta: { name: 'AcademicSemester' } }
    /**
     * Find zero or one AcademicSemester that matches the filter.
     * @param {AcademicSemesterFindUniqueArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AcademicSemesterFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicSemesterFindUniqueArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AcademicSemester that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AcademicSemesterFindUniqueOrThrowArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AcademicSemesterFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicSemesterFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AcademicSemester that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindFirstArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AcademicSemesterFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicSemesterFindFirstArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AcademicSemester that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindFirstOrThrowArgs} args - Arguments to find a AcademicSemester
     * @example
     * // Get one AcademicSemester
     * const academicSemester = await prisma.academicSemester.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AcademicSemesterFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicSemesterFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AcademicSemesters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicSemesters
     * const academicSemesters = await prisma.academicSemester.findMany()
     * 
     * // Get first 10 AcademicSemesters
     * const academicSemesters = await prisma.academicSemester.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicSemesterWithIdOnly = await prisma.academicSemester.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AcademicSemesterFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicSemesterFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AcademicSemester.
     * @param {AcademicSemesterCreateArgs} args - Arguments to create a AcademicSemester.
     * @example
     * // Create one AcademicSemester
     * const AcademicSemester = await prisma.academicSemester.create({
     *   data: {
     *     // ... data to create a AcademicSemester
     *   }
     * })
     * 
    **/
    create<T extends AcademicSemesterCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicSemesterCreateArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AcademicSemesters.
     *     @param {AcademicSemesterCreateManyArgs} args - Arguments to create many AcademicSemesters.
     *     @example
     *     // Create many AcademicSemesters
     *     const academicSemester = await prisma.academicSemester.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AcademicSemesterCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicSemesterCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicSemester.
     * @param {AcademicSemesterDeleteArgs} args - Arguments to delete one AcademicSemester.
     * @example
     * // Delete one AcademicSemester
     * const AcademicSemester = await prisma.academicSemester.delete({
     *   where: {
     *     // ... filter to delete one AcademicSemester
     *   }
     * })
     * 
    **/
    delete<T extends AcademicSemesterDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicSemesterDeleteArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AcademicSemester.
     * @param {AcademicSemesterUpdateArgs} args - Arguments to update one AcademicSemester.
     * @example
     * // Update one AcademicSemester
     * const academicSemester = await prisma.academicSemester.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AcademicSemesterUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicSemesterUpdateArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AcademicSemesters.
     * @param {AcademicSemesterDeleteManyArgs} args - Arguments to filter AcademicSemesters to delete.
     * @example
     * // Delete a few AcademicSemesters
     * const { count } = await prisma.academicSemester.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AcademicSemesterDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicSemesterDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSemesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicSemesters
     * const academicSemester = await prisma.academicSemester.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AcademicSemesterUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicSemesterUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicSemester.
     * @param {AcademicSemesterUpsertArgs} args - Arguments to update or create a AcademicSemester.
     * @example
     * // Update or create a AcademicSemester
     * const academicSemester = await prisma.academicSemester.upsert({
     *   create: {
     *     // ... data to create a AcademicSemester
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicSemester we want to update
     *   }
     * })
    **/
    upsert<T extends AcademicSemesterUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicSemesterUpsertArgs<ExtArgs>>
    ): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AcademicSemesters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterCountArgs} args - Arguments to filter AcademicSemesters to count.
     * @example
     * // Count the number of AcademicSemesters
     * const count = await prisma.academicSemester.count({
     *   where: {
     *     // ... the filter for the AcademicSemesters we want to count
     *   }
     * })
    **/
    count<T extends AcademicSemesterCountArgs>(
      args?: Subset<T, AcademicSemesterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicSemesterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicSemester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicSemesterAggregateArgs>(args: Subset<T, AcademicSemesterAggregateArgs>): Prisma.PrismaPromise<GetAcademicSemesterAggregateType<T>>

    /**
     * Group by AcademicSemester.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSemesterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicSemesterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicSemesterGroupByArgs['orderBy'] }
        : { orderBy?: AcademicSemesterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicSemesterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicSemesterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicSemester model
   */
  readonly fields: AcademicSemesterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicSemester.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicSemesterClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    students<T extends AcademicSemester$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'> | Null>;

    semesterRegistrations<T extends AcademicSemester$semesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$semesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentEnrolledCourses<T extends AcademicSemester$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    studentEnrolledCourseMarks<T extends AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentSemesterPayments<T extends AcademicSemester$studentSemesterPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemester$studentSemesterPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AcademicSemester model
   */ 
  interface AcademicSemesterFieldRefs {
    readonly id: FieldRef<"AcademicSemester", 'String'>
    readonly year: FieldRef<"AcademicSemester", 'Int'>
    readonly title: FieldRef<"AcademicSemester", 'String'>
    readonly code: FieldRef<"AcademicSemester", 'String'>
    readonly startMonth: FieldRef<"AcademicSemester", 'String'>
    readonly endMonth: FieldRef<"AcademicSemester", 'String'>
    readonly isCurrent: FieldRef<"AcademicSemester", 'Boolean'>
    readonly createdAt: FieldRef<"AcademicSemester", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicSemester", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AcademicSemester findUnique
   */
  export type AcademicSemesterFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where: AcademicSemesterWhereUniqueInput
  }


  /**
   * AcademicSemester findUniqueOrThrow
   */
  export type AcademicSemesterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where: AcademicSemesterWhereUniqueInput
  }


  /**
   * AcademicSemester findFirst
   */
  export type AcademicSemesterFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSemesters.
     */
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }


  /**
   * AcademicSemester findFirstOrThrow
   */
  export type AcademicSemesterFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemester to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSemesters.
     */
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }


  /**
   * AcademicSemester findMany
   */
  export type AcademicSemesterFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSemesters to fetch.
     */
    where?: AcademicSemesterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSemesters to fetch.
     */
    orderBy?: AcademicSemesterOrderByWithRelationInput | AcademicSemesterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicSemesters.
     */
    cursor?: AcademicSemesterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSemesters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSemesters.
     */
    skip?: number
    distinct?: AcademicSemesterScalarFieldEnum | AcademicSemesterScalarFieldEnum[]
  }


  /**
   * AcademicSemester create
   */
  export type AcademicSemesterCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicSemester.
     */
    data: XOR<AcademicSemesterCreateInput, AcademicSemesterUncheckedCreateInput>
  }


  /**
   * AcademicSemester createMany
   */
  export type AcademicSemesterCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicSemesters.
     */
    data: AcademicSemesterCreateManyInput | AcademicSemesterCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AcademicSemester update
   */
  export type AcademicSemesterUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicSemester.
     */
    data: XOR<AcademicSemesterUpdateInput, AcademicSemesterUncheckedUpdateInput>
    /**
     * Choose, which AcademicSemester to update.
     */
    where: AcademicSemesterWhereUniqueInput
  }


  /**
   * AcademicSemester updateMany
   */
  export type AcademicSemesterUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicSemesters.
     */
    data: XOR<AcademicSemesterUpdateManyMutationInput, AcademicSemesterUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSemesters to update
     */
    where?: AcademicSemesterWhereInput
  }


  /**
   * AcademicSemester upsert
   */
  export type AcademicSemesterUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicSemester to update in case it exists.
     */
    where: AcademicSemesterWhereUniqueInput
    /**
     * In case the AcademicSemester found by the `where` argument doesn't exist, create a new AcademicSemester with this data.
     */
    create: XOR<AcademicSemesterCreateInput, AcademicSemesterUncheckedCreateInput>
    /**
     * In case the AcademicSemester was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicSemesterUpdateInput, AcademicSemesterUncheckedUpdateInput>
  }


  /**
   * AcademicSemester delete
   */
  export type AcademicSemesterDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
    /**
     * Filter which AcademicSemester to delete.
     */
    where: AcademicSemesterWhereUniqueInput
  }


  /**
   * AcademicSemester deleteMany
   */
  export type AcademicSemesterDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSemesters to delete
     */
    where?: AcademicSemesterWhereInput
  }


  /**
   * AcademicSemester.students
   */
  export type AcademicSemester$studentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * AcademicSemester.semesterRegistrations
   */
  export type AcademicSemester$semesterRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    where?: SemesterRegistrationWhereInput
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    cursor?: SemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }


  /**
   * AcademicSemester.studentEnrolledCourses
   */
  export type AcademicSemester$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }


  /**
   * AcademicSemester.studentEnrolledCourseMarks
   */
  export type AcademicSemester$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }


  /**
   * AcademicSemester.studentSemesterPayments
   */
  export type AcademicSemester$studentSemesterPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }


  /**
   * AcademicSemester without action
   */
  export type AcademicSemesterDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSemester
     */
    select?: AcademicSemesterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicSemesterInclude<ExtArgs> | null
  }



  /**
   * Model AcademicFaculty
   */

  export type AggregateAcademicFaculty = {
    _count: AcademicFacultyCountAggregateOutputType | null
    _min: AcademicFacultyMinAggregateOutputType | null
    _max: AcademicFacultyMaxAggregateOutputType | null
  }

  export type AcademicFacultyMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicFacultyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicFacultyCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicFacultyMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicFacultyMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicFacultyCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicFacultyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicFaculty to aggregate.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicFaculties
    **/
    _count?: true | AcademicFacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicFacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicFacultyMaxAggregateInputType
  }

  export type GetAcademicFacultyAggregateType<T extends AcademicFacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicFaculty[P]>
      : GetScalarType<T[P], AggregateAcademicFaculty[P]>
  }




  export type AcademicFacultyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AcademicFacultyWhereInput
    orderBy?: AcademicFacultyOrderByWithAggregationInput | AcademicFacultyOrderByWithAggregationInput[]
    by: AcademicFacultyScalarFieldEnum[] | AcademicFacultyScalarFieldEnum
    having?: AcademicFacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicFacultyCountAggregateInputType | true
    _min?: AcademicFacultyMinAggregateInputType
    _max?: AcademicFacultyMaxAggregateInputType
  }

  export type AcademicFacultyGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: AcademicFacultyCountAggregateOutputType | null
    _min: AcademicFacultyMinAggregateOutputType | null
    _max: AcademicFacultyMaxAggregateOutputType | null
  }

  type GetAcademicFacultyGroupByPayload<T extends AcademicFacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicFacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicFacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicFacultyGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicFacultyGroupByOutputType[P]>
        }
      >
    >


  export type AcademicFacultySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicDepartments?: boolean | AcademicFaculty$academicDepartmentsArgs<ExtArgs>
    students?: boolean | AcademicFaculty$studentsArgs<ExtArgs>
    faculties?: boolean | AcademicFaculty$facultiesArgs<ExtArgs>
    _count?: boolean | AcademicFacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicFaculty"]>

  export type AcademicFacultySelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicFacultyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    academicDepartments?: boolean | AcademicFaculty$academicDepartmentsArgs<ExtArgs>
    students?: boolean | AcademicFaculty$studentsArgs<ExtArgs>
    faculties?: boolean | AcademicFaculty$facultiesArgs<ExtArgs>
    _count?: boolean | AcademicFacultyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AcademicFacultyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "AcademicFaculty"
    objects: {
      academicDepartments: Prisma.$AcademicDepartmentPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      faculties: Prisma.$FacultyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicFaculty"]>
    composites: {}
  }


  type AcademicFacultyGetPayload<S extends boolean | null | undefined | AcademicFacultyDefaultArgs> = $Result.GetResult<Prisma.$AcademicFacultyPayload, S>

  type AcademicFacultyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AcademicFacultyFindManyArgs, 'select' | 'include'> & {
      select?: AcademicFacultyCountAggregateInputType | true
    }

  export interface AcademicFacultyDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicFaculty'], meta: { name: 'AcademicFaculty' } }
    /**
     * Find zero or one AcademicFaculty that matches the filter.
     * @param {AcademicFacultyFindUniqueArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AcademicFacultyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicFacultyFindUniqueArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AcademicFaculty that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AcademicFacultyFindUniqueOrThrowArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AcademicFacultyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicFacultyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AcademicFaculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindFirstArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AcademicFacultyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicFacultyFindFirstArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AcademicFaculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindFirstOrThrowArgs} args - Arguments to find a AcademicFaculty
     * @example
     * // Get one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AcademicFacultyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicFacultyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AcademicFaculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicFaculties
     * const academicFaculties = await prisma.academicFaculty.findMany()
     * 
     * // Get first 10 AcademicFaculties
     * const academicFaculties = await prisma.academicFaculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicFacultyWithIdOnly = await prisma.academicFaculty.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AcademicFacultyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicFacultyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AcademicFaculty.
     * @param {AcademicFacultyCreateArgs} args - Arguments to create a AcademicFaculty.
     * @example
     * // Create one AcademicFaculty
     * const AcademicFaculty = await prisma.academicFaculty.create({
     *   data: {
     *     // ... data to create a AcademicFaculty
     *   }
     * })
     * 
    **/
    create<T extends AcademicFacultyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicFacultyCreateArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AcademicFaculties.
     *     @param {AcademicFacultyCreateManyArgs} args - Arguments to create many AcademicFaculties.
     *     @example
     *     // Create many AcademicFaculties
     *     const academicFaculty = await prisma.academicFaculty.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AcademicFacultyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicFacultyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicFaculty.
     * @param {AcademicFacultyDeleteArgs} args - Arguments to delete one AcademicFaculty.
     * @example
     * // Delete one AcademicFaculty
     * const AcademicFaculty = await prisma.academicFaculty.delete({
     *   where: {
     *     // ... filter to delete one AcademicFaculty
     *   }
     * })
     * 
    **/
    delete<T extends AcademicFacultyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicFacultyDeleteArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AcademicFaculty.
     * @param {AcademicFacultyUpdateArgs} args - Arguments to update one AcademicFaculty.
     * @example
     * // Update one AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AcademicFacultyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicFacultyUpdateArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AcademicFaculties.
     * @param {AcademicFacultyDeleteManyArgs} args - Arguments to filter AcademicFaculties to delete.
     * @example
     * // Delete a few AcademicFaculties
     * const { count } = await prisma.academicFaculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AcademicFacultyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicFacultyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicFaculties
     * const academicFaculty = await prisma.academicFaculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AcademicFacultyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicFacultyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicFaculty.
     * @param {AcademicFacultyUpsertArgs} args - Arguments to update or create a AcademicFaculty.
     * @example
     * // Update or create a AcademicFaculty
     * const academicFaculty = await prisma.academicFaculty.upsert({
     *   create: {
     *     // ... data to create a AcademicFaculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicFaculty we want to update
     *   }
     * })
    **/
    upsert<T extends AcademicFacultyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicFacultyUpsertArgs<ExtArgs>>
    ): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AcademicFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyCountArgs} args - Arguments to filter AcademicFaculties to count.
     * @example
     * // Count the number of AcademicFaculties
     * const count = await prisma.academicFaculty.count({
     *   where: {
     *     // ... the filter for the AcademicFaculties we want to count
     *   }
     * })
    **/
    count<T extends AcademicFacultyCountArgs>(
      args?: Subset<T, AcademicFacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicFacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicFacultyAggregateArgs>(args: Subset<T, AcademicFacultyAggregateArgs>): Prisma.PrismaPromise<GetAcademicFacultyAggregateType<T>>

    /**
     * Group by AcademicFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicFacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicFacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicFacultyGroupByArgs['orderBy'] }
        : { orderBy?: AcademicFacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicFacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicFaculty model
   */
  readonly fields: AcademicFacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicFaculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicFacultyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    academicDepartments<T extends AcademicFaculty$academicDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$academicDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findMany'> | Null>;

    students<T extends AcademicFaculty$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'> | Null>;

    faculties<T extends AcademicFaculty$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFaculty$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AcademicFaculty model
   */ 
  interface AcademicFacultyFieldRefs {
    readonly id: FieldRef<"AcademicFaculty", 'String'>
    readonly title: FieldRef<"AcademicFaculty", 'String'>
    readonly createdAt: FieldRef<"AcademicFaculty", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicFaculty", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AcademicFaculty findUnique
   */
  export type AcademicFacultyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where: AcademicFacultyWhereUniqueInput
  }


  /**
   * AcademicFaculty findUniqueOrThrow
   */
  export type AcademicFacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where: AcademicFacultyWhereUniqueInput
  }


  /**
   * AcademicFaculty findFirst
   */
  export type AcademicFacultyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicFaculties.
     */
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }


  /**
   * AcademicFaculty findFirstOrThrow
   */
  export type AcademicFacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculty to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicFaculties.
     */
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }


  /**
   * AcademicFaculty findMany
   */
  export type AcademicFacultyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter, which AcademicFaculties to fetch.
     */
    where?: AcademicFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicFaculties to fetch.
     */
    orderBy?: AcademicFacultyOrderByWithRelationInput | AcademicFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicFaculties.
     */
    cursor?: AcademicFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicFaculties.
     */
    skip?: number
    distinct?: AcademicFacultyScalarFieldEnum | AcademicFacultyScalarFieldEnum[]
  }


  /**
   * AcademicFaculty create
   */
  export type AcademicFacultyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicFaculty.
     */
    data: XOR<AcademicFacultyCreateInput, AcademicFacultyUncheckedCreateInput>
  }


  /**
   * AcademicFaculty createMany
   */
  export type AcademicFacultyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicFaculties.
     */
    data: AcademicFacultyCreateManyInput | AcademicFacultyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AcademicFaculty update
   */
  export type AcademicFacultyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicFaculty.
     */
    data: XOR<AcademicFacultyUpdateInput, AcademicFacultyUncheckedUpdateInput>
    /**
     * Choose, which AcademicFaculty to update.
     */
    where: AcademicFacultyWhereUniqueInput
  }


  /**
   * AcademicFaculty updateMany
   */
  export type AcademicFacultyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicFaculties.
     */
    data: XOR<AcademicFacultyUpdateManyMutationInput, AcademicFacultyUncheckedUpdateManyInput>
    /**
     * Filter which AcademicFaculties to update
     */
    where?: AcademicFacultyWhereInput
  }


  /**
   * AcademicFaculty upsert
   */
  export type AcademicFacultyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicFaculty to update in case it exists.
     */
    where: AcademicFacultyWhereUniqueInput
    /**
     * In case the AcademicFaculty found by the `where` argument doesn't exist, create a new AcademicFaculty with this data.
     */
    create: XOR<AcademicFacultyCreateInput, AcademicFacultyUncheckedCreateInput>
    /**
     * In case the AcademicFaculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicFacultyUpdateInput, AcademicFacultyUncheckedUpdateInput>
  }


  /**
   * AcademicFaculty delete
   */
  export type AcademicFacultyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
    /**
     * Filter which AcademicFaculty to delete.
     */
    where: AcademicFacultyWhereUniqueInput
  }


  /**
   * AcademicFaculty deleteMany
   */
  export type AcademicFacultyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicFaculties to delete
     */
    where?: AcademicFacultyWhereInput
  }


  /**
   * AcademicFaculty.academicDepartments
   */
  export type AcademicFaculty$academicDepartmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    where?: AcademicDepartmentWhereInput
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    cursor?: AcademicDepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }


  /**
   * AcademicFaculty.students
   */
  export type AcademicFaculty$studentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * AcademicFaculty.faculties
   */
  export type AcademicFaculty$facultiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    cursor?: FacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }


  /**
   * AcademicFaculty without action
   */
  export type AcademicFacultyDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicFaculty
     */
    select?: AcademicFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicFacultyInclude<ExtArgs> | null
  }



  /**
   * Model AcademicDepartment
   */

  export type AggregateAcademicDepartment = {
    _count: AcademicDepartmentCountAggregateOutputType | null
    _min: AcademicDepartmentMinAggregateOutputType | null
    _max: AcademicDepartmentMaxAggregateOutputType | null
  }

  export type AcademicDepartmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicFacultyId: string | null
  }

  export type AcademicDepartmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicFacultyId: string | null
  }

  export type AcademicDepartmentCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    academicFacultyId: number
    _all: number
  }


  export type AcademicDepartmentMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    academicFacultyId?: true
  }

  export type AcademicDepartmentMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    academicFacultyId?: true
  }

  export type AcademicDepartmentCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    academicFacultyId?: true
    _all?: true
  }

  export type AcademicDepartmentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDepartment to aggregate.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicDepartments
    **/
    _count?: true | AcademicDepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicDepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicDepartmentMaxAggregateInputType
  }

  export type GetAcademicDepartmentAggregateType<T extends AcademicDepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicDepartment[P]>
      : GetScalarType<T[P], AggregateAcademicDepartment[P]>
  }




  export type AcademicDepartmentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AcademicDepartmentWhereInput
    orderBy?: AcademicDepartmentOrderByWithAggregationInput | AcademicDepartmentOrderByWithAggregationInput[]
    by: AcademicDepartmentScalarFieldEnum[] | AcademicDepartmentScalarFieldEnum
    having?: AcademicDepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicDepartmentCountAggregateInputType | true
    _min?: AcademicDepartmentMinAggregateInputType
    _max?: AcademicDepartmentMaxAggregateInputType
  }

  export type AcademicDepartmentGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    academicFacultyId: string
    _count: AcademicDepartmentCountAggregateOutputType | null
    _min: AcademicDepartmentMinAggregateOutputType | null
    _max: AcademicDepartmentMaxAggregateOutputType | null
  }

  type GetAcademicDepartmentGroupByPayload<T extends AcademicDepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicDepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicDepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicDepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicDepartmentGroupByOutputType[P]>
        }
      >
    >


  export type AcademicDepartmentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicFacultyId?: boolean
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    students?: boolean | AcademicDepartment$studentsArgs<ExtArgs>
    faculties?: boolean | AcademicDepartment$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | AcademicDepartment$offeredCoursesArgs<ExtArgs>
    _count?: boolean | AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicDepartment"]>

  export type AcademicDepartmentSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicFacultyId?: boolean
  }

  export type AcademicDepartmentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    students?: boolean | AcademicDepartment$studentsArgs<ExtArgs>
    faculties?: boolean | AcademicDepartment$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | AcademicDepartment$offeredCoursesArgs<ExtArgs>
    _count?: boolean | AcademicDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AcademicDepartmentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "AcademicDepartment"
    objects: {
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
      faculties: Prisma.$FacultyPayload<ExtArgs>[]
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
      academicFacultyId: string
    }, ExtArgs["result"]["academicDepartment"]>
    composites: {}
  }


  type AcademicDepartmentGetPayload<S extends boolean | null | undefined | AcademicDepartmentDefaultArgs> = $Result.GetResult<Prisma.$AcademicDepartmentPayload, S>

  type AcademicDepartmentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AcademicDepartmentFindManyArgs, 'select' | 'include'> & {
      select?: AcademicDepartmentCountAggregateInputType | true
    }

  export interface AcademicDepartmentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicDepartment'], meta: { name: 'AcademicDepartment' } }
    /**
     * Find zero or one AcademicDepartment that matches the filter.
     * @param {AcademicDepartmentFindUniqueArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AcademicDepartmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicDepartmentFindUniqueArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AcademicDepartment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AcademicDepartmentFindUniqueOrThrowArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AcademicDepartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindFirstArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AcademicDepartmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicDepartmentFindFirstArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AcademicDepartment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindFirstOrThrowArgs} args - Arguments to find a AcademicDepartment
     * @example
     * // Get one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AcademicDepartmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicDepartmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AcademicDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicDepartments
     * const academicDepartments = await prisma.academicDepartment.findMany()
     * 
     * // Get first 10 AcademicDepartments
     * const academicDepartments = await prisma.academicDepartment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicDepartmentWithIdOnly = await prisma.academicDepartment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AcademicDepartmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicDepartmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AcademicDepartment.
     * @param {AcademicDepartmentCreateArgs} args - Arguments to create a AcademicDepartment.
     * @example
     * // Create one AcademicDepartment
     * const AcademicDepartment = await prisma.academicDepartment.create({
     *   data: {
     *     // ... data to create a AcademicDepartment
     *   }
     * })
     * 
    **/
    create<T extends AcademicDepartmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicDepartmentCreateArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AcademicDepartments.
     *     @param {AcademicDepartmentCreateManyArgs} args - Arguments to create many AcademicDepartments.
     *     @example
     *     // Create many AcademicDepartments
     *     const academicDepartment = await prisma.academicDepartment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AcademicDepartmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicDepartmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AcademicDepartment.
     * @param {AcademicDepartmentDeleteArgs} args - Arguments to delete one AcademicDepartment.
     * @example
     * // Delete one AcademicDepartment
     * const AcademicDepartment = await prisma.academicDepartment.delete({
     *   where: {
     *     // ... filter to delete one AcademicDepartment
     *   }
     * })
     * 
    **/
    delete<T extends AcademicDepartmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicDepartmentDeleteArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AcademicDepartment.
     * @param {AcademicDepartmentUpdateArgs} args - Arguments to update one AcademicDepartment.
     * @example
     * // Update one AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AcademicDepartmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicDepartmentUpdateArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AcademicDepartments.
     * @param {AcademicDepartmentDeleteManyArgs} args - Arguments to filter AcademicDepartments to delete.
     * @example
     * // Delete a few AcademicDepartments
     * const { count } = await prisma.academicDepartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AcademicDepartmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcademicDepartmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicDepartments
     * const academicDepartment = await prisma.academicDepartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AcademicDepartmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicDepartmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicDepartment.
     * @param {AcademicDepartmentUpsertArgs} args - Arguments to update or create a AcademicDepartment.
     * @example
     * // Update or create a AcademicDepartment
     * const academicDepartment = await prisma.academicDepartment.upsert({
     *   create: {
     *     // ... data to create a AcademicDepartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicDepartment we want to update
     *   }
     * })
    **/
    upsert<T extends AcademicDepartmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AcademicDepartmentUpsertArgs<ExtArgs>>
    ): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AcademicDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentCountArgs} args - Arguments to filter AcademicDepartments to count.
     * @example
     * // Count the number of AcademicDepartments
     * const count = await prisma.academicDepartment.count({
     *   where: {
     *     // ... the filter for the AcademicDepartments we want to count
     *   }
     * })
    **/
    count<T extends AcademicDepartmentCountArgs>(
      args?: Subset<T, AcademicDepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicDepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicDepartmentAggregateArgs>(args: Subset<T, AcademicDepartmentAggregateArgs>): Prisma.PrismaPromise<GetAcademicDepartmentAggregateType<T>>

    /**
     * Group by AcademicDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicDepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicDepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicDepartmentGroupByArgs['orderBy'] }
        : { orderBy?: AcademicDepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicDepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicDepartment model
   */
  readonly fields: AcademicDepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicDepartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicDepartmentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    students<T extends AcademicDepartment$studentsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'> | Null>;

    faculties<T extends AcademicDepartment$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findMany'> | Null>;

    offeredCourses<T extends AcademicDepartment$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartment$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AcademicDepartment model
   */ 
  interface AcademicDepartmentFieldRefs {
    readonly id: FieldRef<"AcademicDepartment", 'String'>
    readonly title: FieldRef<"AcademicDepartment", 'String'>
    readonly createdAt: FieldRef<"AcademicDepartment", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicDepartment", 'DateTime'>
    readonly academicFacultyId: FieldRef<"AcademicDepartment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AcademicDepartment findUnique
   */
  export type AcademicDepartmentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where: AcademicDepartmentWhereUniqueInput
  }


  /**
   * AcademicDepartment findUniqueOrThrow
   */
  export type AcademicDepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where: AcademicDepartmentWhereUniqueInput
  }


  /**
   * AcademicDepartment findFirst
   */
  export type AcademicDepartmentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDepartments.
     */
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }


  /**
   * AcademicDepartment findFirstOrThrow
   */
  export type AcademicDepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartment to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicDepartments.
     */
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }


  /**
   * AcademicDepartment findMany
   */
  export type AcademicDepartmentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which AcademicDepartments to fetch.
     */
    where?: AcademicDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicDepartments to fetch.
     */
    orderBy?: AcademicDepartmentOrderByWithRelationInput | AcademicDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicDepartments.
     */
    cursor?: AcademicDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicDepartments.
     */
    skip?: number
    distinct?: AcademicDepartmentScalarFieldEnum | AcademicDepartmentScalarFieldEnum[]
  }


  /**
   * AcademicDepartment create
   */
  export type AcademicDepartmentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicDepartment.
     */
    data: XOR<AcademicDepartmentCreateInput, AcademicDepartmentUncheckedCreateInput>
  }


  /**
   * AcademicDepartment createMany
   */
  export type AcademicDepartmentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicDepartments.
     */
    data: AcademicDepartmentCreateManyInput | AcademicDepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AcademicDepartment update
   */
  export type AcademicDepartmentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicDepartment.
     */
    data: XOR<AcademicDepartmentUpdateInput, AcademicDepartmentUncheckedUpdateInput>
    /**
     * Choose, which AcademicDepartment to update.
     */
    where: AcademicDepartmentWhereUniqueInput
  }


  /**
   * AcademicDepartment updateMany
   */
  export type AcademicDepartmentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicDepartments.
     */
    data: XOR<AcademicDepartmentUpdateManyMutationInput, AcademicDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which AcademicDepartments to update
     */
    where?: AcademicDepartmentWhereInput
  }


  /**
   * AcademicDepartment upsert
   */
  export type AcademicDepartmentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicDepartment to update in case it exists.
     */
    where: AcademicDepartmentWhereUniqueInput
    /**
     * In case the AcademicDepartment found by the `where` argument doesn't exist, create a new AcademicDepartment with this data.
     */
    create: XOR<AcademicDepartmentCreateInput, AcademicDepartmentUncheckedCreateInput>
    /**
     * In case the AcademicDepartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicDepartmentUpdateInput, AcademicDepartmentUncheckedUpdateInput>
  }


  /**
   * AcademicDepartment delete
   */
  export type AcademicDepartmentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
    /**
     * Filter which AcademicDepartment to delete.
     */
    where: AcademicDepartmentWhereUniqueInput
  }


  /**
   * AcademicDepartment deleteMany
   */
  export type AcademicDepartmentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicDepartments to delete
     */
    where?: AcademicDepartmentWhereInput
  }


  /**
   * AcademicDepartment.students
   */
  export type AcademicDepartment$studentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * AcademicDepartment.faculties
   */
  export type AcademicDepartment$facultiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    cursor?: FacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }


  /**
   * AcademicDepartment.offeredCourses
   */
  export type AcademicDepartment$offeredCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }


  /**
   * AcademicDepartment without action
   */
  export type AcademicDepartmentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicDepartment
     */
    select?: AcademicDepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcademicDepartmentInclude<ExtArgs> | null
  }



  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    bloodGroup: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicSemesterId: string | null
    academicDepartmentId: string | null
    academicFacultyId: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    bloodGroup: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicSemesterId: string | null
    academicDepartmentId: string | null
    academicFacultyId: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    studentId: number
    firstName: number
    lastName: number
    middleName: number
    profileImage: number
    email: number
    contactNo: number
    gender: number
    bloodGroup: number
    createdAt: number
    updatedAt: number
    academicSemesterId: number
    academicDepartmentId: number
    academicFacultyId: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    studentId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    bloodGroup?: true
    createdAt?: true
    updatedAt?: true
    academicSemesterId?: true
    academicDepartmentId?: true
    academicFacultyId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    studentId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    bloodGroup?: true
    createdAt?: true
    updatedAt?: true
    academicSemesterId?: true
    academicDepartmentId?: true
    academicFacultyId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    studentId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    bloodGroup?: true
    createdAt?: true
    updatedAt?: true
    academicSemesterId?: true
    academicDepartmentId?: true
    academicFacultyId?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt: Date
    updatedAt: Date
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    bloodGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicSemesterId?: boolean
    academicDepartmentId?: boolean
    academicFacultyId?: boolean
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | Student$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | Student$studentSemesterRegistrationCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Student$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | Student$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | Student$studentSemesterPaymentsArgs<ExtArgs>
    studentAcademicInfos?: boolean | Student$studentAcademicInfosArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    studentId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    bloodGroup?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicSemesterId?: boolean
    academicDepartmentId?: boolean
    academicFacultyId?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | Student$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | Student$studentSemesterRegistrationCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Student$studentEnrolledCoursesArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | Student$studentEnrolledCourseMarksArgs<ExtArgs>
    studentSemesterPayments?: boolean | Student$studentSemesterPaymentsArgs<ExtArgs>
    studentAcademicInfos?: boolean | Student$studentAcademicInfosArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      studentSemesterRegistrations: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
      studentSemesterPayments: Prisma.$StudentSemesterPaymentPayload<ExtArgs>[]
      studentAcademicInfos: Prisma.$StudentAcademicInfoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      studentId: string
      firstName: string
      lastName: string
      middleName: string
      profileImage: string | null
      email: string
      contactNo: string
      gender: string
      bloodGroup: string
      createdAt: Date
      updatedAt: Date
      academicSemesterId: string
      academicDepartmentId: string
      academicFacultyId: string
    }, ExtArgs["result"]["student"]>
    composites: {}
  }


  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
    **/
    create<T extends StudentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentCreateArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Students.
     *     @param {StudentCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const student = await prisma.student.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
    **/
    delete<T extends StudentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
    **/
    upsert<T extends StudentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>
    ): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    studentSemesterRegistrations<T extends Student$studentSemesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentSemesterRegistrationCourses<T extends Student$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    studentEnrolledCourses<T extends Student$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    studentEnrolledCourseMarks<T extends Student$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentSemesterPayments<T extends Student$studentSemesterPaymentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSemesterPaymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentAcademicInfos<T extends Student$studentAcademicInfosArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentAcademicInfosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly studentId: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly middleName: FieldRef<"Student", 'String'>
    readonly profileImage: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly contactNo: FieldRef<"Student", 'String'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly bloodGroup: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
    readonly academicSemesterId: FieldRef<"Student", 'String'>
    readonly academicDepartmentId: FieldRef<"Student", 'String'>
    readonly academicFacultyId: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }


  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }


  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }


  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }


  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }


  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }


  /**
   * Student.studentSemesterRegistrations
   */
  export type Student$studentSemesterRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }


  /**
   * Student.studentSemesterRegistrationCourses
   */
  export type Student$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }


  /**
   * Student.studentEnrolledCourses
   */
  export type Student$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }


  /**
   * Student.studentEnrolledCourseMarks
   */
  export type Student$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }


  /**
   * Student.studentSemesterPayments
   */
  export type Student$studentSemesterPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }


  /**
   * Student.studentAcademicInfos
   */
  export type Student$studentAcademicInfosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    where?: StudentAcademicInfoWhereInput
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    cursor?: StudentAcademicInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }


  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentInclude<ExtArgs> | null
  }



  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyMinAggregateOutputType = {
    id: string | null
    facultyId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    bloodGroup: string | null
    designation: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicDepartmentId: string | null
    academicFacultyId: string | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: string | null
    facultyId: string | null
    firstName: string | null
    lastName: string | null
    middleName: string | null
    profileImage: string | null
    email: string | null
    contactNo: string | null
    gender: string | null
    bloodGroup: string | null
    designation: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academicDepartmentId: string | null
    academicFacultyId: string | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    facultyId: number
    firstName: number
    lastName: number
    middleName: number
    profileImage: number
    email: number
    contactNo: number
    gender: number
    bloodGroup: number
    designation: number
    createdAt: number
    updatedAt: number
    academicDepartmentId: number
    academicFacultyId: number
    _all: number
  }


  export type FacultyMinAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    bloodGroup?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
    academicDepartmentId?: true
    academicFacultyId?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    bloodGroup?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
    academicDepartmentId?: true
    academicFacultyId?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    facultyId?: true
    firstName?: true
    lastName?: true
    middleName?: true
    profileImage?: true
    email?: true
    contactNo?: true
    gender?: true
    bloodGroup?: true
    designation?: true
    createdAt?: true
    updatedAt?: true
    academicDepartmentId?: true
    academicFacultyId?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    id: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt: Date
    updatedAt: Date
    academicDepartmentId: string
    academicFacultyId: string
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facultyId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    bloodGroup?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicDepartmentId?: boolean
    academicFacultyId?: boolean
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    courses?: boolean | Faculty$coursesArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Faculty$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectScalar = {
    id?: boolean
    facultyId?: boolean
    firstName?: boolean
    lastName?: boolean
    middleName?: boolean
    profileImage?: boolean
    email?: boolean
    contactNo?: boolean
    gender?: boolean
    bloodGroup?: boolean
    designation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicDepartmentId?: boolean
    academicFacultyId?: boolean
  }

  export type FacultyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    academicFaculty?: boolean | AcademicFacultyDefaultArgs<ExtArgs>
    courses?: boolean | Faculty$coursesArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Faculty$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $FacultyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Faculty"
    objects: {
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      academicFaculty: Prisma.$AcademicFacultyPayload<ExtArgs>
      courses: Prisma.$CourseFacultyPayload<ExtArgs>[]
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      facultyId: string
      firstName: string
      lastName: string
      middleName: string
      profileImage: string
      email: string
      contactNo: string
      gender: string
      bloodGroup: string
      designation: string
      createdAt: Date
      updatedAt: Date
      academicDepartmentId: string
      academicFacultyId: string
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }


  type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<Prisma.$FacultyPayload, S>

  type FacultyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FacultyFindManyArgs, 'select' | 'include'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface FacultyDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty'], meta: { name: 'Faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FacultyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Faculty that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FacultyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FacultyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
    **/
    create<T extends FacultyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Faculties.
     *     @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     *     @example
     *     // Create many Faculties
     *     const faculty = await prisma.faculty.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FacultyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
    **/
    delete<T extends FacultyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FacultyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FacultyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FacultyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
    **/
    upsert<T extends FacultyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>
    ): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faculty model
   */
  readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicFaculty<T extends AcademicFacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicFacultyDefaultArgs<ExtArgs>>): Prisma__AcademicFacultyClient<$Result.GetResult<Prisma.$AcademicFacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    courses<T extends Faculty$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'findMany'> | Null>;

    offeredCourseClassSchedules<T extends Faculty$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Faculty model
   */ 
  interface FacultyFieldRefs {
    readonly id: FieldRef<"Faculty", 'String'>
    readonly facultyId: FieldRef<"Faculty", 'String'>
    readonly firstName: FieldRef<"Faculty", 'String'>
    readonly lastName: FieldRef<"Faculty", 'String'>
    readonly middleName: FieldRef<"Faculty", 'String'>
    readonly profileImage: FieldRef<"Faculty", 'String'>
    readonly email: FieldRef<"Faculty", 'String'>
    readonly contactNo: FieldRef<"Faculty", 'String'>
    readonly gender: FieldRef<"Faculty", 'String'>
    readonly bloodGroup: FieldRef<"Faculty", 'String'>
    readonly designation: FieldRef<"Faculty", 'String'>
    readonly createdAt: FieldRef<"Faculty", 'DateTime'>
    readonly updatedAt: FieldRef<"Faculty", 'DateTime'>
    readonly academicDepartmentId: FieldRef<"Faculty", 'String'>
    readonly academicFacultyId: FieldRef<"Faculty", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }


  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }


  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }


  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }


  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }


  /**
   * Faculty create
   */
  export type FacultyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }


  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput
  }


  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
  }


  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }


  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput
  }


  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput
  }


  /**
   * Faculty.courses
   */
  export type Faculty$coursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    cursor?: CourseFacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }


  /**
   * Faculty.offeredCourseClassSchedules
   */
  export type Faculty$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }


  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FacultyInclude<ExtArgs> | null
  }



  /**
   * Model Building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingCountAggregateOutputType = {
    id: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuildingMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingCountAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Building to aggregate.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type BuildingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithAggregationInput | BuildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: BuildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    id: string
    title: string
    createdAt: Date
    updatedAt: Date
    _count: BuildingCountAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends BuildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type BuildingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>

  export type BuildingSelectScalar = {
    id?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuildingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BuildingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Building"
    objects: {
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      title: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["building"]>
    composites: {}
  }


  type BuildingGetPayload<S extends boolean | null | undefined | BuildingDefaultArgs> = $Result.GetResult<Prisma.$BuildingPayload, S>

  type BuildingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BuildingFindManyArgs, 'select' | 'include'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface BuildingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Building'], meta: { name: 'Building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {BuildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BuildingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingFindUniqueArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Building that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BuildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BuildingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BuildingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingFindFirstArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BuildingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BuildingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Building.
     * @param {BuildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
    **/
    create<T extends BuildingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingCreateArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Buildings.
     *     @param {BuildingCreateManyArgs} args - Arguments to create many Buildings.
     *     @example
     *     // Create many Buildings
     *     const building = await prisma.building.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BuildingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Building.
     * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
    **/
    delete<T extends BuildingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingDeleteArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Building.
     * @param {BuildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BuildingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingUpdateArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Buildings.
     * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BuildingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BuildingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BuildingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Building.
     * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
    **/
    upsert<T extends BuildingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BuildingUpsertArgs<ExtArgs>>
    ): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends BuildingCountArgs>(
      args?: Subset<T, BuildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingGroupByArgs['orderBy'] }
        : { orderBy?: BuildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Building model
   */
  readonly fields: BuildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rooms<T extends Building$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Building$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Building model
   */ 
  interface BuildingFieldRefs {
    readonly id: FieldRef<"Building", 'String'>
    readonly title: FieldRef<"Building", 'String'>
    readonly createdAt: FieldRef<"Building", 'DateTime'>
    readonly updatedAt: FieldRef<"Building", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Building findUnique
   */
  export type BuildingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }


  /**
   * Building findUniqueOrThrow
   */
  export type BuildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }


  /**
   * Building findFirst
   */
  export type BuildingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }


  /**
   * Building findFirstOrThrow
   */
  export type BuildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }


  /**
   * Building findMany
   */
  export type BuildingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Buildings to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }


  /**
   * Building create
   */
  export type BuildingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to create a Building.
     */
    data: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
  }


  /**
   * Building createMany
   */
  export type BuildingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Building update
   */
  export type BuildingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to update a Building.
     */
    data: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
    /**
     * Choose, which Building to update.
     */
    where: BuildingWhereUniqueInput
  }


  /**
   * Building updateMany
   */
  export type BuildingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buildings.
     */
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyInput>
    /**
     * Filter which Buildings to update
     */
    where?: BuildingWhereInput
  }


  /**
   * Building upsert
   */
  export type BuildingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The filter to search for the Building to update in case it exists.
     */
    where: BuildingWhereUniqueInput
    /**
     * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
     */
    create: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
    /**
     * In case the Building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
  }


  /**
   * Building delete
   */
  export type BuildingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter which Building to delete.
     */
    where: BuildingWhereUniqueInput
  }


  /**
   * Building deleteMany
   */
  export type BuildingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buildings to delete
     */
    where?: BuildingWhereInput
  }


  /**
   * Building.rooms
   */
  export type Building$roomsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Building without action
   */
  export type BuildingDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BuildingInclude<ExtArgs> | null
  }



  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    roomNumber: string | null
    floor: string | null
    createdAt: Date | null
    updatedAt: Date | null
    buildingId: string | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    roomNumber: string | null
    floor: string | null
    createdAt: Date | null
    updatedAt: Date | null
    buildingId: string | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    roomNumber: number
    floor: number
    createdAt: number
    updatedAt: number
    buildingId: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    createdAt?: true
    updatedAt?: true
    buildingId?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    createdAt?: true
    updatedAt?: true
    buildingId?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    roomNumber?: true
    floor?: true
    createdAt?: true
    updatedAt?: true
    buildingId?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    roomNumber: string
    floor: string
    createdAt: Date
    updatedAt: Date
    buildingId: string
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomNumber?: boolean
    floor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buildingId?: boolean
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Room$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    roomNumber?: boolean
    floor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buildingId?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | Room$offeredCourseClassSchedulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RoomPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      building: Prisma.$BuildingPayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      roomNumber: string
      floor: string
      createdAt: Date
      updatedAt: Date
      buildingId: string
    }, ExtArgs["result"]["room"]>
    composites: {}
  }


  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoomFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoomFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoomFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
    **/
    create<T extends RoomCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomCreateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rooms.
     *     @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     *     @example
     *     // Create many Rooms
     *     const room = await prisma.room.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoomCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
    **/
    delete<T extends RoomDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoomUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoomDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoomUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
    **/
    upsert<T extends RoomUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>
    ): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    building<T extends BuildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildingDefaultArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    offeredCourseClassSchedules<T extends Room$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Room$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly roomNumber: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
    readonly buildingId: FieldRef<"Room", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }


  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }


  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }


  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }


  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }


  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }


  /**
   * Room.offeredCourseClassSchedules
   */
  export type Room$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }


  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoomInclude<ExtArgs> | null
  }



  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    credits: number | null
  }

  export type CourseSumAggregateOutputType = {
    credits: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    code: string | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    code: number
    credits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    credits?: true
  }

  export type CourseSumAggregateInputType = {
    credits?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    code?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    code?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    code?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    code: string
    credits: number
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    code?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    preRequisite?: boolean | Course$preRequisiteArgs<ExtArgs>
    preRequisiteFor?: boolean | Course$preRequisiteForArgs<ExtArgs>
    faculties?: boolean | Course$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | Course$offeredCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Course$studentEnrolledCoursesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    code?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    preRequisite?: boolean | Course$preRequisiteArgs<ExtArgs>
    preRequisiteFor?: boolean | Course$preRequisiteForArgs<ExtArgs>
    faculties?: boolean | Course$facultiesArgs<ExtArgs>
    offeredCourses?: boolean | Course$offeredCoursesArgs<ExtArgs>
    studentEnrolledCourses?: boolean | Course$studentEnrolledCoursesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CoursePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      preRequisite: Prisma.$CourseToPrerequisitePayload<ExtArgs>[]
      preRequisiteFor: Prisma.$CourseToPrerequisitePayload<ExtArgs>[]
      faculties: Prisma.$CourseFacultyPayload<ExtArgs>[]
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
      studentEnrolledCourses: Prisma.$StudentEnrolledCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      title: string
      code: string
      credits: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }


  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
    **/
    create<T extends CourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseCreateArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Courses.
     *     @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     *     @example
     *     // Create many Courses
     *     const course = await prisma.course.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
    **/
    delete<T extends CourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
    **/
    upsert<T extends CourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>
    ): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    preRequisite<T extends Course$preRequisiteArgs<ExtArgs> = {}>(args?: Subset<T, Course$preRequisiteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'findMany'> | Null>;

    preRequisiteFor<T extends Course$preRequisiteForArgs<ExtArgs> = {}>(args?: Subset<T, Course$preRequisiteForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'findMany'> | Null>;

    faculties<T extends Course$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, Course$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'findMany'> | Null>;

    offeredCourses<T extends Course$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    studentEnrolledCourses<T extends Course$studentEnrolledCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$studentEnrolledCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly credits: FieldRef<"Course", 'Int'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }


  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }


  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }


  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }


  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }


  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }


  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }


  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }


  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }


  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }


  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }


  /**
   * Course.preRequisite
   */
  export type Course$preRequisiteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    where?: CourseToPrerequisiteWhereInput
    orderBy?: CourseToPrerequisiteOrderByWithRelationInput | CourseToPrerequisiteOrderByWithRelationInput[]
    cursor?: CourseToPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseToPrerequisiteScalarFieldEnum | CourseToPrerequisiteScalarFieldEnum[]
  }


  /**
   * Course.preRequisiteFor
   */
  export type Course$preRequisiteForArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    where?: CourseToPrerequisiteWhereInput
    orderBy?: CourseToPrerequisiteOrderByWithRelationInput | CourseToPrerequisiteOrderByWithRelationInput[]
    cursor?: CourseToPrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseToPrerequisiteScalarFieldEnum | CourseToPrerequisiteScalarFieldEnum[]
  }


  /**
   * Course.faculties
   */
  export type Course$facultiesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    cursor?: CourseFacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }


  /**
   * Course.offeredCourses
   */
  export type Course$offeredCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }


  /**
   * Course.studentEnrolledCourses
   */
  export type Course$studentEnrolledCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }


  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
  }



  /**
   * Model CourseToPrerequisite
   */

  export type AggregateCourseToPrerequisite = {
    _count: CourseToPrerequisiteCountAggregateOutputType | null
    _min: CourseToPrerequisiteMinAggregateOutputType | null
    _max: CourseToPrerequisiteMaxAggregateOutputType | null
  }

  export type CourseToPrerequisiteMinAggregateOutputType = {
    courseId: string | null
    preRequisiteId: string | null
  }

  export type CourseToPrerequisiteMaxAggregateOutputType = {
    courseId: string | null
    preRequisiteId: string | null
  }

  export type CourseToPrerequisiteCountAggregateOutputType = {
    courseId: number
    preRequisiteId: number
    _all: number
  }


  export type CourseToPrerequisiteMinAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
  }

  export type CourseToPrerequisiteMaxAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
  }

  export type CourseToPrerequisiteCountAggregateInputType = {
    courseId?: true
    preRequisiteId?: true
    _all?: true
  }

  export type CourseToPrerequisiteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseToPrerequisite to aggregate.
     */
    where?: CourseToPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPrerequisites to fetch.
     */
    orderBy?: CourseToPrerequisiteOrderByWithRelationInput | CourseToPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseToPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseToPrerequisites
    **/
    _count?: true | CourseToPrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseToPrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseToPrerequisiteMaxAggregateInputType
  }

  export type GetCourseToPrerequisiteAggregateType<T extends CourseToPrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseToPrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseToPrerequisite[P]>
      : GetScalarType<T[P], AggregateCourseToPrerequisite[P]>
  }




  export type CourseToPrerequisiteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseToPrerequisiteWhereInput
    orderBy?: CourseToPrerequisiteOrderByWithAggregationInput | CourseToPrerequisiteOrderByWithAggregationInput[]
    by: CourseToPrerequisiteScalarFieldEnum[] | CourseToPrerequisiteScalarFieldEnum
    having?: CourseToPrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseToPrerequisiteCountAggregateInputType | true
    _min?: CourseToPrerequisiteMinAggregateInputType
    _max?: CourseToPrerequisiteMaxAggregateInputType
  }

  export type CourseToPrerequisiteGroupByOutputType = {
    courseId: string
    preRequisiteId: string
    _count: CourseToPrerequisiteCountAggregateOutputType | null
    _min: CourseToPrerequisiteMinAggregateOutputType | null
    _max: CourseToPrerequisiteMaxAggregateOutputType | null
  }

  type GetCourseToPrerequisiteGroupByPayload<T extends CourseToPrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseToPrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseToPrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseToPrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], CourseToPrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type CourseToPrerequisiteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    preRequisiteId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    preRequisite?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseToPrerequisite"]>

  export type CourseToPrerequisiteSelectScalar = {
    courseId?: boolean
    preRequisiteId?: boolean
  }

  export type CourseToPrerequisiteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    preRequisite?: boolean | CourseDefaultArgs<ExtArgs>
  }


  export type $CourseToPrerequisitePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CourseToPrerequisite"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      preRequisite: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      courseId: string
      preRequisiteId: string
    }, ExtArgs["result"]["courseToPrerequisite"]>
    composites: {}
  }


  type CourseToPrerequisiteGetPayload<S extends boolean | null | undefined | CourseToPrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$CourseToPrerequisitePayload, S>

  type CourseToPrerequisiteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CourseToPrerequisiteFindManyArgs, 'select' | 'include'> & {
      select?: CourseToPrerequisiteCountAggregateInputType | true
    }

  export interface CourseToPrerequisiteDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseToPrerequisite'], meta: { name: 'CourseToPrerequisite' } }
    /**
     * Find zero or one CourseToPrerequisite that matches the filter.
     * @param {CourseToPrerequisiteFindUniqueArgs} args - Arguments to find a CourseToPrerequisite
     * @example
     * // Get one CourseToPrerequisite
     * const courseToPrerequisite = await prisma.courseToPrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseToPrerequisiteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CourseToPrerequisiteFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CourseToPrerequisite that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CourseToPrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a CourseToPrerequisite
     * @example
     * // Get one CourseToPrerequisite
     * const courseToPrerequisite = await prisma.courseToPrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourseToPrerequisiteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseToPrerequisiteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CourseToPrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPrerequisiteFindFirstArgs} args - Arguments to find a CourseToPrerequisite
     * @example
     * // Get one CourseToPrerequisite
     * const courseToPrerequisite = await prisma.courseToPrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseToPrerequisiteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseToPrerequisiteFindFirstArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CourseToPrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPrerequisiteFindFirstOrThrowArgs} args - Arguments to find a CourseToPrerequisite
     * @example
     * // Get one CourseToPrerequisite
     * const courseToPrerequisite = await prisma.courseToPrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourseToPrerequisiteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseToPrerequisiteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CourseToPrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPrerequisiteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseToPrerequisites
     * const courseToPrerequisites = await prisma.courseToPrerequisite.findMany()
     * 
     * // Get first 10 CourseToPrerequisites
     * const courseToPrerequisites = await prisma.courseToPrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseToPrerequisiteWithCourseIdOnly = await prisma.courseToPrerequisite.findMany({ select: { courseId: true } })
     * 
    **/
    findMany<T extends CourseToPrerequisiteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseToPrerequisiteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CourseToPrerequisite.
     * @param {CourseToPrerequisiteCreateArgs} args - Arguments to create a CourseToPrerequisite.
     * @example
     * // Create one CourseToPrerequisite
     * const CourseToPrerequisite = await prisma.courseToPrerequisite.create({
     *   data: {
     *     // ... data to create a CourseToPrerequisite
     *   }
     * })
     * 
    **/
    create<T extends CourseToPrerequisiteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseToPrerequisiteCreateArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CourseToPrerequisites.
     *     @param {CourseToPrerequisiteCreateManyArgs} args - Arguments to create many CourseToPrerequisites.
     *     @example
     *     // Create many CourseToPrerequisites
     *     const courseToPrerequisite = await prisma.courseToPrerequisite.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourseToPrerequisiteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseToPrerequisiteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseToPrerequisite.
     * @param {CourseToPrerequisiteDeleteArgs} args - Arguments to delete one CourseToPrerequisite.
     * @example
     * // Delete one CourseToPrerequisite
     * const CourseToPrerequisite = await prisma.courseToPrerequisite.delete({
     *   where: {
     *     // ... filter to delete one CourseToPrerequisite
     *   }
     * })
     * 
    **/
    delete<T extends CourseToPrerequisiteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourseToPrerequisiteDeleteArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CourseToPrerequisite.
     * @param {CourseToPrerequisiteUpdateArgs} args - Arguments to update one CourseToPrerequisite.
     * @example
     * // Update one CourseToPrerequisite
     * const courseToPrerequisite = await prisma.courseToPrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseToPrerequisiteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseToPrerequisiteUpdateArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CourseToPrerequisites.
     * @param {CourseToPrerequisiteDeleteManyArgs} args - Arguments to filter CourseToPrerequisites to delete.
     * @example
     * // Delete a few CourseToPrerequisites
     * const { count } = await prisma.courseToPrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseToPrerequisiteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseToPrerequisiteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseToPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseToPrerequisites
     * const courseToPrerequisite = await prisma.courseToPrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseToPrerequisiteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourseToPrerequisiteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseToPrerequisite.
     * @param {CourseToPrerequisiteUpsertArgs} args - Arguments to update or create a CourseToPrerequisite.
     * @example
     * // Update or create a CourseToPrerequisite
     * const courseToPrerequisite = await prisma.courseToPrerequisite.upsert({
     *   create: {
     *     // ... data to create a CourseToPrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseToPrerequisite we want to update
     *   }
     * })
    **/
    upsert<T extends CourseToPrerequisiteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourseToPrerequisiteUpsertArgs<ExtArgs>>
    ): Prisma__CourseToPrerequisiteClient<$Result.GetResult<Prisma.$CourseToPrerequisitePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CourseToPrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPrerequisiteCountArgs} args - Arguments to filter CourseToPrerequisites to count.
     * @example
     * // Count the number of CourseToPrerequisites
     * const count = await prisma.courseToPrerequisite.count({
     *   where: {
     *     // ... the filter for the CourseToPrerequisites we want to count
     *   }
     * })
    **/
    count<T extends CourseToPrerequisiteCountArgs>(
      args?: Subset<T, CourseToPrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseToPrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseToPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseToPrerequisiteAggregateArgs>(args: Subset<T, CourseToPrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetCourseToPrerequisiteAggregateType<T>>

    /**
     * Group by CourseToPrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseToPrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseToPrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseToPrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: CourseToPrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseToPrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseToPrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseToPrerequisite model
   */
  readonly fields: CourseToPrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseToPrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseToPrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    preRequisite<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CourseToPrerequisite model
   */ 
  interface CourseToPrerequisiteFieldRefs {
    readonly courseId: FieldRef<"CourseToPrerequisite", 'String'>
    readonly preRequisiteId: FieldRef<"CourseToPrerequisite", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CourseToPrerequisite findUnique
   */
  export type CourseToPrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPrerequisite to fetch.
     */
    where: CourseToPrerequisiteWhereUniqueInput
  }


  /**
   * CourseToPrerequisite findUniqueOrThrow
   */
  export type CourseToPrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPrerequisite to fetch.
     */
    where: CourseToPrerequisiteWhereUniqueInput
  }


  /**
   * CourseToPrerequisite findFirst
   */
  export type CourseToPrerequisiteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPrerequisite to fetch.
     */
    where?: CourseToPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPrerequisites to fetch.
     */
    orderBy?: CourseToPrerequisiteOrderByWithRelationInput | CourseToPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseToPrerequisites.
     */
    cursor?: CourseToPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseToPrerequisites.
     */
    distinct?: CourseToPrerequisiteScalarFieldEnum | CourseToPrerequisiteScalarFieldEnum[]
  }


  /**
   * CourseToPrerequisite findFirstOrThrow
   */
  export type CourseToPrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPrerequisite to fetch.
     */
    where?: CourseToPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPrerequisites to fetch.
     */
    orderBy?: CourseToPrerequisiteOrderByWithRelationInput | CourseToPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseToPrerequisites.
     */
    cursor?: CourseToPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseToPrerequisites.
     */
    distinct?: CourseToPrerequisiteScalarFieldEnum | CourseToPrerequisiteScalarFieldEnum[]
  }


  /**
   * CourseToPrerequisite findMany
   */
  export type CourseToPrerequisiteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which CourseToPrerequisites to fetch.
     */
    where?: CourseToPrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseToPrerequisites to fetch.
     */
    orderBy?: CourseToPrerequisiteOrderByWithRelationInput | CourseToPrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseToPrerequisites.
     */
    cursor?: CourseToPrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseToPrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseToPrerequisites.
     */
    skip?: number
    distinct?: CourseToPrerequisiteScalarFieldEnum | CourseToPrerequisiteScalarFieldEnum[]
  }


  /**
   * CourseToPrerequisite create
   */
  export type CourseToPrerequisiteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseToPrerequisite.
     */
    data: XOR<CourseToPrerequisiteCreateInput, CourseToPrerequisiteUncheckedCreateInput>
  }


  /**
   * CourseToPrerequisite createMany
   */
  export type CourseToPrerequisiteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseToPrerequisites.
     */
    data: CourseToPrerequisiteCreateManyInput | CourseToPrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CourseToPrerequisite update
   */
  export type CourseToPrerequisiteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseToPrerequisite.
     */
    data: XOR<CourseToPrerequisiteUpdateInput, CourseToPrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which CourseToPrerequisite to update.
     */
    where: CourseToPrerequisiteWhereUniqueInput
  }


  /**
   * CourseToPrerequisite updateMany
   */
  export type CourseToPrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseToPrerequisites.
     */
    data: XOR<CourseToPrerequisiteUpdateManyMutationInput, CourseToPrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which CourseToPrerequisites to update
     */
    where?: CourseToPrerequisiteWhereInput
  }


  /**
   * CourseToPrerequisite upsert
   */
  export type CourseToPrerequisiteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseToPrerequisite to update in case it exists.
     */
    where: CourseToPrerequisiteWhereUniqueInput
    /**
     * In case the CourseToPrerequisite found by the `where` argument doesn't exist, create a new CourseToPrerequisite with this data.
     */
    create: XOR<CourseToPrerequisiteCreateInput, CourseToPrerequisiteUncheckedCreateInput>
    /**
     * In case the CourseToPrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseToPrerequisiteUpdateInput, CourseToPrerequisiteUncheckedUpdateInput>
  }


  /**
   * CourseToPrerequisite delete
   */
  export type CourseToPrerequisiteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which CourseToPrerequisite to delete.
     */
    where: CourseToPrerequisiteWhereUniqueInput
  }


  /**
   * CourseToPrerequisite deleteMany
   */
  export type CourseToPrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseToPrerequisites to delete
     */
    where?: CourseToPrerequisiteWhereInput
  }


  /**
   * CourseToPrerequisite without action
   */
  export type CourseToPrerequisiteDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseToPrerequisite
     */
    select?: CourseToPrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseToPrerequisiteInclude<ExtArgs> | null
  }



  /**
   * Model CourseFaculty
   */

  export type AggregateCourseFaculty = {
    _count: CourseFacultyCountAggregateOutputType | null
    _min: CourseFacultyMinAggregateOutputType | null
    _max: CourseFacultyMaxAggregateOutputType | null
  }

  export type CourseFacultyMinAggregateOutputType = {
    courseId: string | null
    facultyId: string | null
  }

  export type CourseFacultyMaxAggregateOutputType = {
    courseId: string | null
    facultyId: string | null
  }

  export type CourseFacultyCountAggregateOutputType = {
    courseId: number
    facultyId: number
    _all: number
  }


  export type CourseFacultyMinAggregateInputType = {
    courseId?: true
    facultyId?: true
  }

  export type CourseFacultyMaxAggregateInputType = {
    courseId?: true
    facultyId?: true
  }

  export type CourseFacultyCountAggregateInputType = {
    courseId?: true
    facultyId?: true
    _all?: true
  }

  export type CourseFacultyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFaculty to aggregate.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseFaculties
    **/
    _count?: true | CourseFacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseFacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseFacultyMaxAggregateInputType
  }

  export type GetCourseFacultyAggregateType<T extends CourseFacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseFaculty[P]>
      : GetScalarType<T[P], AggregateCourseFaculty[P]>
  }




  export type CourseFacultyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseFacultyWhereInput
    orderBy?: CourseFacultyOrderByWithAggregationInput | CourseFacultyOrderByWithAggregationInput[]
    by: CourseFacultyScalarFieldEnum[] | CourseFacultyScalarFieldEnum
    having?: CourseFacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseFacultyCountAggregateInputType | true
    _min?: CourseFacultyMinAggregateInputType
    _max?: CourseFacultyMaxAggregateInputType
  }

  export type CourseFacultyGroupByOutputType = {
    courseId: string
    facultyId: string
    _count: CourseFacultyCountAggregateOutputType | null
    _min: CourseFacultyMinAggregateOutputType | null
    _max: CourseFacultyMaxAggregateOutputType | null
  }

  type GetCourseFacultyGroupByPayload<T extends CourseFacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseFacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseFacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseFacultyGroupByOutputType[P]>
            : GetScalarType<T[P], CourseFacultyGroupByOutputType[P]>
        }
      >
    >


  export type CourseFacultySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    courseId?: boolean
    facultyId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseFaculty"]>

  export type CourseFacultySelectScalar = {
    courseId?: boolean
    facultyId?: boolean
  }

  export type CourseFacultyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }


  export type $CourseFacultyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "CourseFaculty"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      courseId: string
      facultyId: string
    }, ExtArgs["result"]["courseFaculty"]>
    composites: {}
  }


  type CourseFacultyGetPayload<S extends boolean | null | undefined | CourseFacultyDefaultArgs> = $Result.GetResult<Prisma.$CourseFacultyPayload, S>

  type CourseFacultyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CourseFacultyFindManyArgs, 'select' | 'include'> & {
      select?: CourseFacultyCountAggregateInputType | true
    }

  export interface CourseFacultyDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseFaculty'], meta: { name: 'CourseFaculty' } }
    /**
     * Find zero or one CourseFaculty that matches the filter.
     * @param {CourseFacultyFindUniqueArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseFacultyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CourseFacultyFindUniqueArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CourseFaculty that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CourseFacultyFindUniqueOrThrowArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourseFacultyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFacultyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CourseFaculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindFirstArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseFacultyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFacultyFindFirstArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CourseFaculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindFirstOrThrowArgs} args - Arguments to find a CourseFaculty
     * @example
     * // Get one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourseFacultyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFacultyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CourseFaculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseFaculties
     * const courseFaculties = await prisma.courseFaculty.findMany()
     * 
     * // Get first 10 CourseFaculties
     * const courseFaculties = await prisma.courseFaculty.findMany({ take: 10 })
     * 
     * // Only select the `courseId`
     * const courseFacultyWithCourseIdOnly = await prisma.courseFaculty.findMany({ select: { courseId: true } })
     * 
    **/
    findMany<T extends CourseFacultyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFacultyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CourseFaculty.
     * @param {CourseFacultyCreateArgs} args - Arguments to create a CourseFaculty.
     * @example
     * // Create one CourseFaculty
     * const CourseFaculty = await prisma.courseFaculty.create({
     *   data: {
     *     // ... data to create a CourseFaculty
     *   }
     * })
     * 
    **/
    create<T extends CourseFacultyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseFacultyCreateArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CourseFaculties.
     *     @param {CourseFacultyCreateManyArgs} args - Arguments to create many CourseFaculties.
     *     @example
     *     // Create many CourseFaculties
     *     const courseFaculty = await prisma.courseFaculty.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourseFacultyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFacultyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CourseFaculty.
     * @param {CourseFacultyDeleteArgs} args - Arguments to delete one CourseFaculty.
     * @example
     * // Delete one CourseFaculty
     * const CourseFaculty = await prisma.courseFaculty.delete({
     *   where: {
     *     // ... filter to delete one CourseFaculty
     *   }
     * })
     * 
    **/
    delete<T extends CourseFacultyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourseFacultyDeleteArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CourseFaculty.
     * @param {CourseFacultyUpdateArgs} args - Arguments to update one CourseFaculty.
     * @example
     * // Update one CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseFacultyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseFacultyUpdateArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CourseFaculties.
     * @param {CourseFacultyDeleteManyArgs} args - Arguments to filter CourseFaculties to delete.
     * @example
     * // Delete a few CourseFaculties
     * const { count } = await prisma.courseFaculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseFacultyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFacultyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseFaculties
     * const courseFaculty = await prisma.courseFaculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseFacultyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourseFacultyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseFaculty.
     * @param {CourseFacultyUpsertArgs} args - Arguments to update or create a CourseFaculty.
     * @example
     * // Update or create a CourseFaculty
     * const courseFaculty = await prisma.courseFaculty.upsert({
     *   create: {
     *     // ... data to create a CourseFaculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseFaculty we want to update
     *   }
     * })
    **/
    upsert<T extends CourseFacultyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourseFacultyUpsertArgs<ExtArgs>>
    ): Prisma__CourseFacultyClient<$Result.GetResult<Prisma.$CourseFacultyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CourseFaculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyCountArgs} args - Arguments to filter CourseFaculties to count.
     * @example
     * // Count the number of CourseFaculties
     * const count = await prisma.courseFaculty.count({
     *   where: {
     *     // ... the filter for the CourseFaculties we want to count
     *   }
     * })
    **/
    count<T extends CourseFacultyCountArgs>(
      args?: Subset<T, CourseFacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseFacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseFacultyAggregateArgs>(args: Subset<T, CourseFacultyAggregateArgs>): Prisma.PrismaPromise<GetCourseFacultyAggregateType<T>>

    /**
     * Group by CourseFaculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseFacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseFacultyGroupByArgs['orderBy'] }
        : { orderBy?: CourseFacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseFacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseFaculty model
   */
  readonly fields: CourseFacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseFaculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseFacultyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CourseFaculty model
   */ 
  interface CourseFacultyFieldRefs {
    readonly courseId: FieldRef<"CourseFaculty", 'String'>
    readonly facultyId: FieldRef<"CourseFaculty", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CourseFaculty findUnique
   */
  export type CourseFacultyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where: CourseFacultyWhereUniqueInput
  }


  /**
   * CourseFaculty findUniqueOrThrow
   */
  export type CourseFacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where: CourseFacultyWhereUniqueInput
  }


  /**
   * CourseFaculty findFirst
   */
  export type CourseFacultyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFaculties.
     */
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }


  /**
   * CourseFaculty findFirstOrThrow
   */
  export type CourseFacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculty to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFaculties.
     */
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }


  /**
   * CourseFaculty findMany
   */
  export type CourseFacultyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter, which CourseFaculties to fetch.
     */
    where?: CourseFacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFaculties to fetch.
     */
    orderBy?: CourseFacultyOrderByWithRelationInput | CourseFacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseFaculties.
     */
    cursor?: CourseFacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFaculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFaculties.
     */
    skip?: number
    distinct?: CourseFacultyScalarFieldEnum | CourseFacultyScalarFieldEnum[]
  }


  /**
   * CourseFaculty create
   */
  export type CourseFacultyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseFaculty.
     */
    data: XOR<CourseFacultyCreateInput, CourseFacultyUncheckedCreateInput>
  }


  /**
   * CourseFaculty createMany
   */
  export type CourseFacultyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseFaculties.
     */
    data: CourseFacultyCreateManyInput | CourseFacultyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CourseFaculty update
   */
  export type CourseFacultyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseFaculty.
     */
    data: XOR<CourseFacultyUpdateInput, CourseFacultyUncheckedUpdateInput>
    /**
     * Choose, which CourseFaculty to update.
     */
    where: CourseFacultyWhereUniqueInput
  }


  /**
   * CourseFaculty updateMany
   */
  export type CourseFacultyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseFaculties.
     */
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyInput>
    /**
     * Filter which CourseFaculties to update
     */
    where?: CourseFacultyWhereInput
  }


  /**
   * CourseFaculty upsert
   */
  export type CourseFacultyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseFaculty to update in case it exists.
     */
    where: CourseFacultyWhereUniqueInput
    /**
     * In case the CourseFaculty found by the `where` argument doesn't exist, create a new CourseFaculty with this data.
     */
    create: XOR<CourseFacultyCreateInput, CourseFacultyUncheckedCreateInput>
    /**
     * In case the CourseFaculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseFacultyUpdateInput, CourseFacultyUncheckedUpdateInput>
  }


  /**
   * CourseFaculty delete
   */
  export type CourseFacultyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
    /**
     * Filter which CourseFaculty to delete.
     */
    where: CourseFacultyWhereUniqueInput
  }


  /**
   * CourseFaculty deleteMany
   */
  export type CourseFacultyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFaculties to delete
     */
    where?: CourseFacultyWhereInput
  }


  /**
   * CourseFaculty without action
   */
  export type CourseFacultyDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFaculty
     */
    select?: CourseFacultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseFacultyInclude<ExtArgs> | null
  }



  /**
   * Model SemesterRegistration
   */

  export type AggregateSemesterRegistration = {
    _count: SemesterRegistrationCountAggregateOutputType | null
    _avg: SemesterRegistrationAvgAggregateOutputType | null
    _sum: SemesterRegistrationSumAggregateOutputType | null
    _min: SemesterRegistrationMinAggregateOutputType | null
    _max: SemesterRegistrationMaxAggregateOutputType | null
  }

  export type SemesterRegistrationAvgAggregateOutputType = {
    minCredit: number | null
    maxCredit: number | null
  }

  export type SemesterRegistrationSumAggregateOutputType = {
    minCredit: number | null
    maxCredit: number | null
  }

  export type SemesterRegistrationMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SemesterRegistrationStatus | null
    minCredit: number | null
    maxCredit: number | null
    createdAt: Date | null
    updatedAt: Date | null
    academicSemesterId: string | null
  }

  export type SemesterRegistrationMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.SemesterRegistrationStatus | null
    minCredit: number | null
    maxCredit: number | null
    createdAt: Date | null
    updatedAt: Date | null
    academicSemesterId: string | null
  }

  export type SemesterRegistrationCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    status: number
    minCredit: number
    maxCredit: number
    createdAt: number
    updatedAt: number
    academicSemesterId: number
    _all: number
  }


  export type SemesterRegistrationAvgAggregateInputType = {
    minCredit?: true
    maxCredit?: true
  }

  export type SemesterRegistrationSumAggregateInputType = {
    minCredit?: true
    maxCredit?: true
  }

  export type SemesterRegistrationMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    minCredit?: true
    maxCredit?: true
    createdAt?: true
    updatedAt?: true
    academicSemesterId?: true
  }

  export type SemesterRegistrationMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    minCredit?: true
    maxCredit?: true
    createdAt?: true
    updatedAt?: true
    academicSemesterId?: true
  }

  export type SemesterRegistrationCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    status?: true
    minCredit?: true
    maxCredit?: true
    createdAt?: true
    updatedAt?: true
    academicSemesterId?: true
    _all?: true
  }

  export type SemesterRegistrationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemesterRegistration to aggregate.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SemesterRegistrations
    **/
    _count?: true | SemesterRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SemesterRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SemesterRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SemesterRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SemesterRegistrationMaxAggregateInputType
  }

  export type GetSemesterRegistrationAggregateType<T extends SemesterRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateSemesterRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemesterRegistration[P]>
      : GetScalarType<T[P], AggregateSemesterRegistration[P]>
  }




  export type SemesterRegistrationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SemesterRegistrationWhereInput
    orderBy?: SemesterRegistrationOrderByWithAggregationInput | SemesterRegistrationOrderByWithAggregationInput[]
    by: SemesterRegistrationScalarFieldEnum[] | SemesterRegistrationScalarFieldEnum
    having?: SemesterRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SemesterRegistrationCountAggregateInputType | true
    _avg?: SemesterRegistrationAvgAggregateInputType
    _sum?: SemesterRegistrationSumAggregateInputType
    _min?: SemesterRegistrationMinAggregateInputType
    _max?: SemesterRegistrationMaxAggregateInputType
  }

  export type SemesterRegistrationGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    status: $Enums.SemesterRegistrationStatus | null
    minCredit: number
    maxCredit: number
    createdAt: Date
    updatedAt: Date
    academicSemesterId: string
    _count: SemesterRegistrationCountAggregateOutputType | null
    _avg: SemesterRegistrationAvgAggregateOutputType | null
    _sum: SemesterRegistrationSumAggregateOutputType | null
    _min: SemesterRegistrationMinAggregateOutputType | null
    _max: SemesterRegistrationMaxAggregateOutputType | null
  }

  type GetSemesterRegistrationGroupByPayload<T extends SemesterRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SemesterRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SemesterRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SemesterRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], SemesterRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type SemesterRegistrationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    minCredit?: boolean
    maxCredit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicSemesterId?: boolean
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    offeredCourses?: boolean | SemesterRegistration$offeredCoursesArgs<ExtArgs>
    offeredCourseSections?: boolean | SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["semesterRegistration"]>

  export type SemesterRegistrationSelectScalar = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    minCredit?: boolean
    maxCredit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academicSemesterId?: boolean
  }

  export type SemesterRegistrationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    offeredCourses?: boolean | SemesterRegistration$offeredCoursesArgs<ExtArgs>
    offeredCourseSections?: boolean | SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrations?: boolean | SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | SemesterRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SemesterRegistrationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "SemesterRegistration"
    objects: {
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      offeredCourses: Prisma.$OfferedCoursePayload<ExtArgs>[]
      offeredCourseSections: Prisma.$OfferedCourseSectionPayload<ExtArgs>[]
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
      studentSemesterRegistrations: Prisma.$StudentSemesterRegistrationPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      startDate: Date
      endDate: Date
      status: $Enums.SemesterRegistrationStatus | null
      minCredit: number
      maxCredit: number
      createdAt: Date
      updatedAt: Date
      academicSemesterId: string
    }, ExtArgs["result"]["semesterRegistration"]>
    composites: {}
  }


  type SemesterRegistrationGetPayload<S extends boolean | null | undefined | SemesterRegistrationDefaultArgs> = $Result.GetResult<Prisma.$SemesterRegistrationPayload, S>

  type SemesterRegistrationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SemesterRegistrationFindManyArgs, 'select' | 'include'> & {
      select?: SemesterRegistrationCountAggregateInputType | true
    }

  export interface SemesterRegistrationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SemesterRegistration'], meta: { name: 'SemesterRegistration' } }
    /**
     * Find zero or one SemesterRegistration that matches the filter.
     * @param {SemesterRegistrationFindUniqueArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SemesterRegistrationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SemesterRegistrationFindUniqueArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SemesterRegistration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SemesterRegistrationFindUniqueOrThrowArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SemesterRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindFirstArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SemesterRegistrationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SemesterRegistrationFindFirstArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SemesterRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindFirstOrThrowArgs} args - Arguments to find a SemesterRegistration
     * @example
     * // Get one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SemesterRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SemesterRegistrations
     * const semesterRegistrations = await prisma.semesterRegistration.findMany()
     * 
     * // Get first 10 SemesterRegistrations
     * const semesterRegistrations = await prisma.semesterRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semesterRegistrationWithIdOnly = await prisma.semesterRegistration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SemesterRegistrationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemesterRegistrationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SemesterRegistration.
     * @param {SemesterRegistrationCreateArgs} args - Arguments to create a SemesterRegistration.
     * @example
     * // Create one SemesterRegistration
     * const SemesterRegistration = await prisma.semesterRegistration.create({
     *   data: {
     *     // ... data to create a SemesterRegistration
     *   }
     * })
     * 
    **/
    create<T extends SemesterRegistrationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SemesterRegistrationCreateArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SemesterRegistrations.
     *     @param {SemesterRegistrationCreateManyArgs} args - Arguments to create many SemesterRegistrations.
     *     @example
     *     // Create many SemesterRegistrations
     *     const semesterRegistration = await prisma.semesterRegistration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SemesterRegistrationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemesterRegistrationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SemesterRegistration.
     * @param {SemesterRegistrationDeleteArgs} args - Arguments to delete one SemesterRegistration.
     * @example
     * // Delete one SemesterRegistration
     * const SemesterRegistration = await prisma.semesterRegistration.delete({
     *   where: {
     *     // ... filter to delete one SemesterRegistration
     *   }
     * })
     * 
    **/
    delete<T extends SemesterRegistrationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SemesterRegistrationDeleteArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SemesterRegistration.
     * @param {SemesterRegistrationUpdateArgs} args - Arguments to update one SemesterRegistration.
     * @example
     * // Update one SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SemesterRegistrationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SemesterRegistrationUpdateArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SemesterRegistrations.
     * @param {SemesterRegistrationDeleteManyArgs} args - Arguments to filter SemesterRegistrations to delete.
     * @example
     * // Delete a few SemesterRegistrations
     * const { count } = await prisma.semesterRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SemesterRegistrationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SemesterRegistrationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SemesterRegistrations
     * const semesterRegistration = await prisma.semesterRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SemesterRegistrationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SemesterRegistrationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SemesterRegistration.
     * @param {SemesterRegistrationUpsertArgs} args - Arguments to update or create a SemesterRegistration.
     * @example
     * // Update or create a SemesterRegistration
     * const semesterRegistration = await prisma.semesterRegistration.upsert({
     *   create: {
     *     // ... data to create a SemesterRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SemesterRegistration we want to update
     *   }
     * })
    **/
    upsert<T extends SemesterRegistrationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SemesterRegistrationUpsertArgs<ExtArgs>>
    ): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationCountArgs} args - Arguments to filter SemesterRegistrations to count.
     * @example
     * // Count the number of SemesterRegistrations
     * const count = await prisma.semesterRegistration.count({
     *   where: {
     *     // ... the filter for the SemesterRegistrations we want to count
     *   }
     * })
    **/
    count<T extends SemesterRegistrationCountArgs>(
      args?: Subset<T, SemesterRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SemesterRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SemesterRegistrationAggregateArgs>(args: Subset<T, SemesterRegistrationAggregateArgs>): Prisma.PrismaPromise<GetSemesterRegistrationAggregateType<T>>

    /**
     * Group by SemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SemesterRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SemesterRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SemesterRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: SemesterRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SemesterRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemesterRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SemesterRegistration model
   */
  readonly fields: SemesterRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SemesterRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SemesterRegistrationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    offeredCourses<T extends SemesterRegistration$offeredCoursesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    offeredCourseSections<T extends SemesterRegistration$offeredCourseSectionsArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCourseSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findMany'> | Null>;

    offeredCourseClassSchedules<T extends SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findMany'> | Null>;

    studentSemesterRegistrations<T extends SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentSemesterRegistrationCourses<T extends SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SemesterRegistration model
   */ 
  interface SemesterRegistrationFieldRefs {
    readonly id: FieldRef<"SemesterRegistration", 'String'>
    readonly startDate: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly endDate: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly status: FieldRef<"SemesterRegistration", 'SemesterRegistrationStatus'>
    readonly minCredit: FieldRef<"SemesterRegistration", 'Int'>
    readonly maxCredit: FieldRef<"SemesterRegistration", 'Int'>
    readonly createdAt: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"SemesterRegistration", 'DateTime'>
    readonly academicSemesterId: FieldRef<"SemesterRegistration", 'String'>
  }
    

  // Custom InputTypes

  /**
   * SemesterRegistration findUnique
   */
  export type SemesterRegistrationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where: SemesterRegistrationWhereUniqueInput
  }


  /**
   * SemesterRegistration findUniqueOrThrow
   */
  export type SemesterRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where: SemesterRegistrationWhereUniqueInput
  }


  /**
   * SemesterRegistration findFirst
   */
  export type SemesterRegistrationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemesterRegistrations.
     */
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }


  /**
   * SemesterRegistration findFirstOrThrow
   */
  export type SemesterRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistration to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SemesterRegistrations.
     */
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }


  /**
   * SemesterRegistration findMany
   */
  export type SemesterRegistrationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which SemesterRegistrations to fetch.
     */
    where?: SemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SemesterRegistrations to fetch.
     */
    orderBy?: SemesterRegistrationOrderByWithRelationInput | SemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SemesterRegistrations.
     */
    cursor?: SemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SemesterRegistrations.
     */
    skip?: number
    distinct?: SemesterRegistrationScalarFieldEnum | SemesterRegistrationScalarFieldEnum[]
  }


  /**
   * SemesterRegistration create
   */
  export type SemesterRegistrationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a SemesterRegistration.
     */
    data: XOR<SemesterRegistrationCreateInput, SemesterRegistrationUncheckedCreateInput>
  }


  /**
   * SemesterRegistration createMany
   */
  export type SemesterRegistrationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SemesterRegistrations.
     */
    data: SemesterRegistrationCreateManyInput | SemesterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SemesterRegistration update
   */
  export type SemesterRegistrationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a SemesterRegistration.
     */
    data: XOR<SemesterRegistrationUpdateInput, SemesterRegistrationUncheckedUpdateInput>
    /**
     * Choose, which SemesterRegistration to update.
     */
    where: SemesterRegistrationWhereUniqueInput
  }


  /**
   * SemesterRegistration updateMany
   */
  export type SemesterRegistrationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SemesterRegistrations.
     */
    data: XOR<SemesterRegistrationUpdateManyMutationInput, SemesterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which SemesterRegistrations to update
     */
    where?: SemesterRegistrationWhereInput
  }


  /**
   * SemesterRegistration upsert
   */
  export type SemesterRegistrationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the SemesterRegistration to update in case it exists.
     */
    where: SemesterRegistrationWhereUniqueInput
    /**
     * In case the SemesterRegistration found by the `where` argument doesn't exist, create a new SemesterRegistration with this data.
     */
    create: XOR<SemesterRegistrationCreateInput, SemesterRegistrationUncheckedCreateInput>
    /**
     * In case the SemesterRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SemesterRegistrationUpdateInput, SemesterRegistrationUncheckedUpdateInput>
  }


  /**
   * SemesterRegistration delete
   */
  export type SemesterRegistrationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter which SemesterRegistration to delete.
     */
    where: SemesterRegistrationWhereUniqueInput
  }


  /**
   * SemesterRegistration deleteMany
   */
  export type SemesterRegistrationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SemesterRegistrations to delete
     */
    where?: SemesterRegistrationWhereInput
  }


  /**
   * SemesterRegistration.offeredCourses
   */
  export type SemesterRegistration$offeredCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    cursor?: OfferedCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }


  /**
   * SemesterRegistration.offeredCourseSections
   */
  export type SemesterRegistration$offeredCourseSectionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    cursor?: OfferedCourseSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }


  /**
   * SemesterRegistration.offeredCourseClassSchedules
   */
  export type SemesterRegistration$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }


  /**
   * SemesterRegistration.studentSemesterRegistrations
   */
  export type SemesterRegistration$studentSemesterRegistrationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }


  /**
   * SemesterRegistration.studentSemesterRegistrationCourses
   */
  export type SemesterRegistration$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }


  /**
   * SemesterRegistration without action
   */
  export type SemesterRegistrationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SemesterRegistration
     */
    select?: SemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SemesterRegistrationInclude<ExtArgs> | null
  }



  /**
   * Model OfferedCourse
   */

  export type AggregateOfferedCourse = {
    _count: OfferedCourseCountAggregateOutputType | null
    _min: OfferedCourseMinAggregateOutputType | null
    _max: OfferedCourseMaxAggregateOutputType | null
  }

  export type OfferedCourseMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: string | null
    academicDepartmentId: string | null
    semesterRegistrationId: string | null
  }

  export type OfferedCourseMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    courseId: string | null
    academicDepartmentId: string | null
    semesterRegistrationId: string | null
  }

  export type OfferedCourseCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    courseId: number
    academicDepartmentId: number
    semesterRegistrationId: number
    _all: number
  }


  export type OfferedCourseMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    academicDepartmentId?: true
    semesterRegistrationId?: true
  }

  export type OfferedCourseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    academicDepartmentId?: true
    semesterRegistrationId?: true
  }

  export type OfferedCourseCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    courseId?: true
    academicDepartmentId?: true
    semesterRegistrationId?: true
    _all?: true
  }

  export type OfferedCourseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourse to aggregate.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourses
    **/
    _count?: true | OfferedCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseMaxAggregateInputType
  }

  export type GetOfferedCourseAggregateType<T extends OfferedCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourse[P]>
      : GetScalarType<T[P], AggregateOfferedCourse[P]>
  }




  export type OfferedCourseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseWhereInput
    orderBy?: OfferedCourseOrderByWithAggregationInput | OfferedCourseOrderByWithAggregationInput[]
    by: OfferedCourseScalarFieldEnum[] | OfferedCourseScalarFieldEnum
    having?: OfferedCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseCountAggregateInputType | true
    _min?: OfferedCourseMinAggregateInputType
    _max?: OfferedCourseMaxAggregateInputType
  }

  export type OfferedCourseGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    courseId: string
    academicDepartmentId: string
    semesterRegistrationId: string
    _count: OfferedCourseCountAggregateOutputType | null
    _min: OfferedCourseMinAggregateOutputType | null
    _max: OfferedCourseMaxAggregateOutputType | null
  }

  type GetOfferedCourseGroupByPayload<T extends OfferedCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    academicDepartmentId?: boolean
    semesterRegistrationId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourseSections?: boolean | OfferedCourse$offeredCourseSectionsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourse"]>

  export type OfferedCourseSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    courseId?: boolean
    academicDepartmentId?: boolean
    semesterRegistrationId?: boolean
  }

  export type OfferedCourseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicDepartment?: boolean | AcademicDepartmentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourseSections?: boolean | OfferedCourse$offeredCourseSectionsArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OfferedCoursePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "OfferedCourse"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      academicDepartment: Prisma.$AcademicDepartmentPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      offeredCourseSections: Prisma.$OfferedCourseSectionPayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      courseId: string
      academicDepartmentId: string
      semesterRegistrationId: string
    }, ExtArgs["result"]["offeredCourse"]>
    composites: {}
  }


  type OfferedCourseGetPayload<S extends boolean | null | undefined | OfferedCourseDefaultArgs> = $Result.GetResult<Prisma.$OfferedCoursePayload, S>

  type OfferedCourseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfferedCourseFindManyArgs, 'select' | 'include'> & {
      select?: OfferedCourseCountAggregateInputType | true
    }

  export interface OfferedCourseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourse'], meta: { name: 'OfferedCourse' } }
    /**
     * Find zero or one OfferedCourse that matches the filter.
     * @param {OfferedCourseFindUniqueArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferedCourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OfferedCourse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfferedCourseFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfferedCourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OfferedCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindFirstArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferedCourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseFindFirstArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OfferedCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindFirstOrThrowArgs} args - Arguments to find a OfferedCourse
     * @example
     * // Get one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfferedCourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OfferedCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourses
     * const offeredCourses = await prisma.offeredCourse.findMany()
     * 
     * // Get first 10 OfferedCourses
     * const offeredCourses = await prisma.offeredCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseWithIdOnly = await prisma.offeredCourse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferedCourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OfferedCourse.
     * @param {OfferedCourseCreateArgs} args - Arguments to create a OfferedCourse.
     * @example
     * // Create one OfferedCourse
     * const OfferedCourse = await prisma.offeredCourse.create({
     *   data: {
     *     // ... data to create a OfferedCourse
     *   }
     * })
     * 
    **/
    create<T extends OfferedCourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseCreateArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OfferedCourses.
     *     @param {OfferedCourseCreateManyArgs} args - Arguments to create many OfferedCourses.
     *     @example
     *     // Create many OfferedCourses
     *     const offeredCourse = await prisma.offeredCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferedCourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourse.
     * @param {OfferedCourseDeleteArgs} args - Arguments to delete one OfferedCourse.
     * @example
     * // Delete one OfferedCourse
     * const OfferedCourse = await prisma.offeredCourse.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourse
     *   }
     * })
     * 
    **/
    delete<T extends OfferedCourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseDeleteArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OfferedCourse.
     * @param {OfferedCourseUpdateArgs} args - Arguments to update one OfferedCourse.
     * @example
     * // Update one OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferedCourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseUpdateArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OfferedCourses.
     * @param {OfferedCourseDeleteManyArgs} args - Arguments to filter OfferedCourses to delete.
     * @example
     * // Delete a few OfferedCourses
     * const { count } = await prisma.offeredCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferedCourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourses
     * const offeredCourse = await prisma.offeredCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferedCourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourse.
     * @param {OfferedCourseUpsertArgs} args - Arguments to update or create a OfferedCourse.
     * @example
     * // Update or create a OfferedCourse
     * const offeredCourse = await prisma.offeredCourse.upsert({
     *   create: {
     *     // ... data to create a OfferedCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourse we want to update
     *   }
     * })
    **/
    upsert<T extends OfferedCourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseUpsertArgs<ExtArgs>>
    ): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OfferedCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseCountArgs} args - Arguments to filter OfferedCourses to count.
     * @example
     * // Count the number of OfferedCourses
     * const count = await prisma.offeredCourse.count({
     *   where: {
     *     // ... the filter for the OfferedCourses we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseCountArgs>(
      args?: Subset<T, OfferedCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseAggregateArgs>(args: Subset<T, OfferedCourseAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseAggregateType<T>>

    /**
     * Group by OfferedCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourse model
   */
  readonly fields: OfferedCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicDepartment<T extends AcademicDepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicDepartmentDefaultArgs<ExtArgs>>): Prisma__AcademicDepartmentClient<$Result.GetResult<Prisma.$AcademicDepartmentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    offeredCourseSections<T extends OfferedCourse$offeredCourseSectionsArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourse$offeredCourseSectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findMany'> | Null>;

    studentSemesterRegistrationCourses<T extends OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OfferedCourse model
   */ 
  interface OfferedCourseFieldRefs {
    readonly id: FieldRef<"OfferedCourse", 'String'>
    readonly createdAt: FieldRef<"OfferedCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferedCourse", 'DateTime'>
    readonly courseId: FieldRef<"OfferedCourse", 'String'>
    readonly academicDepartmentId: FieldRef<"OfferedCourse", 'String'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourse", 'String'>
  }
    

  // Custom InputTypes

  /**
   * OfferedCourse findUnique
   */
  export type OfferedCourseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where: OfferedCourseWhereUniqueInput
  }


  /**
   * OfferedCourse findUniqueOrThrow
   */
  export type OfferedCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where: OfferedCourseWhereUniqueInput
  }


  /**
   * OfferedCourse findFirst
   */
  export type OfferedCourseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourses.
     */
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }


  /**
   * OfferedCourse findFirstOrThrow
   */
  export type OfferedCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourse to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourses.
     */
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }


  /**
   * OfferedCourse findMany
   */
  export type OfferedCourseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourses to fetch.
     */
    where?: OfferedCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourses to fetch.
     */
    orderBy?: OfferedCourseOrderByWithRelationInput | OfferedCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourses.
     */
    cursor?: OfferedCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourses.
     */
    skip?: number
    distinct?: OfferedCourseScalarFieldEnum | OfferedCourseScalarFieldEnum[]
  }


  /**
   * OfferedCourse create
   */
  export type OfferedCourseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourse.
     */
    data: XOR<OfferedCourseCreateInput, OfferedCourseUncheckedCreateInput>
  }


  /**
   * OfferedCourse createMany
   */
  export type OfferedCourseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourses.
     */
    data: OfferedCourseCreateManyInput | OfferedCourseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OfferedCourse update
   */
  export type OfferedCourseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourse.
     */
    data: XOR<OfferedCourseUpdateInput, OfferedCourseUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourse to update.
     */
    where: OfferedCourseWhereUniqueInput
  }


  /**
   * OfferedCourse updateMany
   */
  export type OfferedCourseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourses.
     */
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourses to update
     */
    where?: OfferedCourseWhereInput
  }


  /**
   * OfferedCourse upsert
   */
  export type OfferedCourseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourse to update in case it exists.
     */
    where: OfferedCourseWhereUniqueInput
    /**
     * In case the OfferedCourse found by the `where` argument doesn't exist, create a new OfferedCourse with this data.
     */
    create: XOR<OfferedCourseCreateInput, OfferedCourseUncheckedCreateInput>
    /**
     * In case the OfferedCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseUpdateInput, OfferedCourseUncheckedUpdateInput>
  }


  /**
   * OfferedCourse delete
   */
  export type OfferedCourseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourse to delete.
     */
    where: OfferedCourseWhereUniqueInput
  }


  /**
   * OfferedCourse deleteMany
   */
  export type OfferedCourseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourses to delete
     */
    where?: OfferedCourseWhereInput
  }


  /**
   * OfferedCourse.offeredCourseSections
   */
  export type OfferedCourse$offeredCourseSectionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    cursor?: OfferedCourseSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }


  /**
   * OfferedCourse.studentSemesterRegistrationCourses
   */
  export type OfferedCourse$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }


  /**
   * OfferedCourse without action
   */
  export type OfferedCourseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourse
     */
    select?: OfferedCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseInclude<ExtArgs> | null
  }



  /**
   * Model OfferedCourseSection
   */

  export type AggregateOfferedCourseSection = {
    _count: OfferedCourseSectionCountAggregateOutputType | null
    _avg: OfferedCourseSectionAvgAggregateOutputType | null
    _sum: OfferedCourseSectionSumAggregateOutputType | null
    _min: OfferedCourseSectionMinAggregateOutputType | null
    _max: OfferedCourseSectionMaxAggregateOutputType | null
  }

  export type OfferedCourseSectionAvgAggregateOutputType = {
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
  }

  export type OfferedCourseSectionSumAggregateOutputType = {
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
  }

  export type OfferedCourseSectionMinAggregateOutputType = {
    id: string | null
    title: string | null
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseId: string | null
    semesterRegistrationId: string | null
  }

  export type OfferedCourseSectionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    maxCapacity: number | null
    currentlyEnrolledStudent: number | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseId: string | null
    semesterRegistrationId: string | null
  }

  export type OfferedCourseSectionCountAggregateOutputType = {
    id: number
    title: number
    maxCapacity: number
    currentlyEnrolledStudent: number
    createdAt: number
    updatedAt: number
    offeredCourseId: number
    semesterRegistrationId: number
    _all: number
  }


  export type OfferedCourseSectionAvgAggregateInputType = {
    maxCapacity?: true
    currentlyEnrolledStudent?: true
  }

  export type OfferedCourseSectionSumAggregateInputType = {
    maxCapacity?: true
    currentlyEnrolledStudent?: true
  }

  export type OfferedCourseSectionMinAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseId?: true
    semesterRegistrationId?: true
  }

  export type OfferedCourseSectionMaxAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseId?: true
    semesterRegistrationId?: true
  }

  export type OfferedCourseSectionCountAggregateInputType = {
    id?: true
    title?: true
    maxCapacity?: true
    currentlyEnrolledStudent?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseId?: true
    semesterRegistrationId?: true
    _all?: true
  }

  export type OfferedCourseSectionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseSection to aggregate.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourseSections
    **/
    _count?: true | OfferedCourseSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferedCourseSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferedCourseSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseSectionMaxAggregateInputType
  }

  export type GetOfferedCourseSectionAggregateType<T extends OfferedCourseSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourseSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourseSection[P]>
      : GetScalarType<T[P], AggregateOfferedCourseSection[P]>
  }




  export type OfferedCourseSectionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseSectionWhereInput
    orderBy?: OfferedCourseSectionOrderByWithAggregationInput | OfferedCourseSectionOrderByWithAggregationInput[]
    by: OfferedCourseSectionScalarFieldEnum[] | OfferedCourseSectionScalarFieldEnum
    having?: OfferedCourseSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseSectionCountAggregateInputType | true
    _avg?: OfferedCourseSectionAvgAggregateInputType
    _sum?: OfferedCourseSectionSumAggregateInputType
    _min?: OfferedCourseSectionMinAggregateInputType
    _max?: OfferedCourseSectionMaxAggregateInputType
  }

  export type OfferedCourseSectionGroupByOutputType = {
    id: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent: number
    createdAt: Date
    updatedAt: Date
    offeredCourseId: string
    semesterRegistrationId: string
    _count: OfferedCourseSectionCountAggregateOutputType | null
    _avg: OfferedCourseSectionAvgAggregateOutputType | null
    _sum: OfferedCourseSectionSumAggregateOutputType | null
    _min: OfferedCourseSectionMinAggregateOutputType | null
    _max: OfferedCourseSectionMaxAggregateOutputType | null
  }

  type GetOfferedCourseSectionGroupByPayload<T extends OfferedCourseSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseSectionGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseSectionGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseSectionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    maxCapacity?: boolean
    currentlyEnrolledStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseId?: boolean
    semesterRegistrationId?: boolean
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourseSection"]>

  export type OfferedCourseSectionSelectScalar = {
    id?: boolean
    title?: boolean
    maxCapacity?: boolean
    currentlyEnrolledStudent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseId?: boolean
    semesterRegistrationId?: boolean
  }

  export type OfferedCourseSectionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    offeredCourseClassSchedules?: boolean | OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>
    studentSemesterRegistrationCourses?: boolean | OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>
    _count?: boolean | OfferedCourseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OfferedCourseSectionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "OfferedCourseSection"
    objects: {
      offeredCourse: Prisma.$OfferedCoursePayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      offeredCourseClassSchedules: Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>[]
      studentSemesterRegistrationCourses: Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      title: string
      maxCapacity: number
      currentlyEnrolledStudent: number
      createdAt: Date
      updatedAt: Date
      offeredCourseId: string
      semesterRegistrationId: string
    }, ExtArgs["result"]["offeredCourseSection"]>
    composites: {}
  }


  type OfferedCourseSectionGetPayload<S extends boolean | null | undefined | OfferedCourseSectionDefaultArgs> = $Result.GetResult<Prisma.$OfferedCourseSectionPayload, S>

  type OfferedCourseSectionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfferedCourseSectionFindManyArgs, 'select' | 'include'> & {
      select?: OfferedCourseSectionCountAggregateInputType | true
    }

  export interface OfferedCourseSectionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourseSection'], meta: { name: 'OfferedCourseSection' } }
    /**
     * Find zero or one OfferedCourseSection that matches the filter.
     * @param {OfferedCourseSectionFindUniqueArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferedCourseSectionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseSectionFindUniqueArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OfferedCourseSection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfferedCourseSectionFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OfferedCourseSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindFirstArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferedCourseSectionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseSectionFindFirstArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OfferedCourseSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindFirstOrThrowArgs} args - Arguments to find a OfferedCourseSection
     * @example
     * // Get one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OfferedCourseSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourseSections
     * const offeredCourseSections = await prisma.offeredCourseSection.findMany()
     * 
     * // Get first 10 OfferedCourseSections
     * const offeredCourseSections = await prisma.offeredCourseSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseSectionWithIdOnly = await prisma.offeredCourseSection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferedCourseSectionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseSectionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OfferedCourseSection.
     * @param {OfferedCourseSectionCreateArgs} args - Arguments to create a OfferedCourseSection.
     * @example
     * // Create one OfferedCourseSection
     * const OfferedCourseSection = await prisma.offeredCourseSection.create({
     *   data: {
     *     // ... data to create a OfferedCourseSection
     *   }
     * })
     * 
    **/
    create<T extends OfferedCourseSectionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseSectionCreateArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OfferedCourseSections.
     *     @param {OfferedCourseSectionCreateManyArgs} args - Arguments to create many OfferedCourseSections.
     *     @example
     *     // Create many OfferedCourseSections
     *     const offeredCourseSection = await prisma.offeredCourseSection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferedCourseSectionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseSectionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourseSection.
     * @param {OfferedCourseSectionDeleteArgs} args - Arguments to delete one OfferedCourseSection.
     * @example
     * // Delete one OfferedCourseSection
     * const OfferedCourseSection = await prisma.offeredCourseSection.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourseSection
     *   }
     * })
     * 
    **/
    delete<T extends OfferedCourseSectionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseSectionDeleteArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OfferedCourseSection.
     * @param {OfferedCourseSectionUpdateArgs} args - Arguments to update one OfferedCourseSection.
     * @example
     * // Update one OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferedCourseSectionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseSectionUpdateArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OfferedCourseSections.
     * @param {OfferedCourseSectionDeleteManyArgs} args - Arguments to filter OfferedCourseSections to delete.
     * @example
     * // Delete a few OfferedCourseSections
     * const { count } = await prisma.offeredCourseSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferedCourseSectionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseSectionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourseSections
     * const offeredCourseSection = await prisma.offeredCourseSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferedCourseSectionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseSectionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourseSection.
     * @param {OfferedCourseSectionUpsertArgs} args - Arguments to update or create a OfferedCourseSection.
     * @example
     * // Update or create a OfferedCourseSection
     * const offeredCourseSection = await prisma.offeredCourseSection.upsert({
     *   create: {
     *     // ... data to create a OfferedCourseSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourseSection we want to update
     *   }
     * })
    **/
    upsert<T extends OfferedCourseSectionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseSectionUpsertArgs<ExtArgs>>
    ): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OfferedCourseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionCountArgs} args - Arguments to filter OfferedCourseSections to count.
     * @example
     * // Count the number of OfferedCourseSections
     * const count = await prisma.offeredCourseSection.count({
     *   where: {
     *     // ... the filter for the OfferedCourseSections we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseSectionCountArgs>(
      args?: Subset<T, OfferedCourseSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseSectionAggregateArgs>(args: Subset<T, OfferedCourseSectionAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseSectionAggregateType<T>>

    /**
     * Group by OfferedCourseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseSectionGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourseSection model
   */
  readonly fields: OfferedCourseSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourseSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseSectionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    offeredCourse<T extends OfferedCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseDefaultArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    offeredCourseClassSchedules<T extends OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findMany'> | Null>;

    studentSemesterRegistrationCourses<T extends OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OfferedCourseSection model
   */ 
  interface OfferedCourseSectionFieldRefs {
    readonly id: FieldRef<"OfferedCourseSection", 'String'>
    readonly title: FieldRef<"OfferedCourseSection", 'String'>
    readonly maxCapacity: FieldRef<"OfferedCourseSection", 'Int'>
    readonly currentlyEnrolledStudent: FieldRef<"OfferedCourseSection", 'Int'>
    readonly createdAt: FieldRef<"OfferedCourseSection", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferedCourseSection", 'DateTime'>
    readonly offeredCourseId: FieldRef<"OfferedCourseSection", 'String'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourseSection", 'String'>
  }
    

  // Custom InputTypes

  /**
   * OfferedCourseSection findUnique
   */
  export type OfferedCourseSectionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }


  /**
   * OfferedCourseSection findUniqueOrThrow
   */
  export type OfferedCourseSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }


  /**
   * OfferedCourseSection findFirst
   */
  export type OfferedCourseSectionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseSections.
     */
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }


  /**
   * OfferedCourseSection findFirstOrThrow
   */
  export type OfferedCourseSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSection to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseSections.
     */
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }


  /**
   * OfferedCourseSection findMany
   */
  export type OfferedCourseSectionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseSections to fetch.
     */
    where?: OfferedCourseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseSections to fetch.
     */
    orderBy?: OfferedCourseSectionOrderByWithRelationInput | OfferedCourseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourseSections.
     */
    cursor?: OfferedCourseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseSections.
     */
    skip?: number
    distinct?: OfferedCourseSectionScalarFieldEnum | OfferedCourseSectionScalarFieldEnum[]
  }


  /**
   * OfferedCourseSection create
   */
  export type OfferedCourseSectionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourseSection.
     */
    data: XOR<OfferedCourseSectionCreateInput, OfferedCourseSectionUncheckedCreateInput>
  }


  /**
   * OfferedCourseSection createMany
   */
  export type OfferedCourseSectionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourseSections.
     */
    data: OfferedCourseSectionCreateManyInput | OfferedCourseSectionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OfferedCourseSection update
   */
  export type OfferedCourseSectionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourseSection.
     */
    data: XOR<OfferedCourseSectionUpdateInput, OfferedCourseSectionUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourseSection to update.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }


  /**
   * OfferedCourseSection updateMany
   */
  export type OfferedCourseSectionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourseSections.
     */
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourseSections to update
     */
    where?: OfferedCourseSectionWhereInput
  }


  /**
   * OfferedCourseSection upsert
   */
  export type OfferedCourseSectionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourseSection to update in case it exists.
     */
    where: OfferedCourseSectionWhereUniqueInput
    /**
     * In case the OfferedCourseSection found by the `where` argument doesn't exist, create a new OfferedCourseSection with this data.
     */
    create: XOR<OfferedCourseSectionCreateInput, OfferedCourseSectionUncheckedCreateInput>
    /**
     * In case the OfferedCourseSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseSectionUpdateInput, OfferedCourseSectionUncheckedUpdateInput>
  }


  /**
   * OfferedCourseSection delete
   */
  export type OfferedCourseSectionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourseSection to delete.
     */
    where: OfferedCourseSectionWhereUniqueInput
  }


  /**
   * OfferedCourseSection deleteMany
   */
  export type OfferedCourseSectionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseSections to delete
     */
    where?: OfferedCourseSectionWhereInput
  }


  /**
   * OfferedCourseSection.offeredCourseClassSchedules
   */
  export type OfferedCourseSection$offeredCourseClassSchedulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }


  /**
   * OfferedCourseSection.studentSemesterRegistrationCourses
   */
  export type OfferedCourseSection$studentSemesterRegistrationCoursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }


  /**
   * OfferedCourseSection without action
   */
  export type OfferedCourseSectionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseSection
     */
    select?: OfferedCourseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseSectionInclude<ExtArgs> | null
  }



  /**
   * Model OfferedCourseClassSchedule
   */

  export type AggregateOfferedCourseClassSchedule = {
    _count: OfferedCourseClassScheduleCountAggregateOutputType | null
    _min: OfferedCourseClassScheduleMinAggregateOutputType | null
    _max: OfferedCourseClassScheduleMaxAggregateOutputType | null
  }

  export type OfferedCourseClassScheduleMinAggregateOutputType = {
    id: string | null
    startTime: string | null
    endTime: string | null
    dayOfWeek: $Enums.WeekDays | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseSectionId: string | null
    semesterRegistrationId: string | null
    roomId: string | null
    facultyId: string | null
  }

  export type OfferedCourseClassScheduleMaxAggregateOutputType = {
    id: string | null
    startTime: string | null
    endTime: string | null
    dayOfWeek: $Enums.WeekDays | null
    createdAt: Date | null
    updatedAt: Date | null
    offeredCourseSectionId: string | null
    semesterRegistrationId: string | null
    roomId: string | null
    facultyId: string | null
  }

  export type OfferedCourseClassScheduleCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    dayOfWeek: number
    createdAt: number
    updatedAt: number
    offeredCourseSectionId: number
    semesterRegistrationId: number
    roomId: number
    facultyId: number
    _all: number
  }


  export type OfferedCourseClassScheduleMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
  }

  export type OfferedCourseClassScheduleMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
  }

  export type OfferedCourseClassScheduleCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    createdAt?: true
    updatedAt?: true
    offeredCourseSectionId?: true
    semesterRegistrationId?: true
    roomId?: true
    facultyId?: true
    _all?: true
  }

  export type OfferedCourseClassScheduleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseClassSchedule to aggregate.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferedCourseClassSchedules
    **/
    _count?: true | OfferedCourseClassScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferedCourseClassScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferedCourseClassScheduleMaxAggregateInputType
  }

  export type GetOfferedCourseClassScheduleAggregateType<T extends OfferedCourseClassScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferedCourseClassSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferedCourseClassSchedule[P]>
      : GetScalarType<T[P], AggregateOfferedCourseClassSchedule[P]>
  }




  export type OfferedCourseClassScheduleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OfferedCourseClassScheduleWhereInput
    orderBy?: OfferedCourseClassScheduleOrderByWithAggregationInput | OfferedCourseClassScheduleOrderByWithAggregationInput[]
    by: OfferedCourseClassScheduleScalarFieldEnum[] | OfferedCourseClassScheduleScalarFieldEnum
    having?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferedCourseClassScheduleCountAggregateInputType | true
    _min?: OfferedCourseClassScheduleMinAggregateInputType
    _max?: OfferedCourseClassScheduleMaxAggregateInputType
  }

  export type OfferedCourseClassScheduleGroupByOutputType = {
    id: string
    startTime: string
    endTime: string
    dayOfWeek: $Enums.WeekDays
    createdAt: Date
    updatedAt: Date
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
    _count: OfferedCourseClassScheduleCountAggregateOutputType | null
    _min: OfferedCourseClassScheduleMinAggregateOutputType | null
    _max: OfferedCourseClassScheduleMaxAggregateOutputType | null
  }

  type GetOfferedCourseClassScheduleGroupByPayload<T extends OfferedCourseClassScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferedCourseClassScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferedCourseClassScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferedCourseClassScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], OfferedCourseClassScheduleGroupByOutputType[P]>
        }
      >
    >


  export type OfferedCourseClassScheduleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseSectionId?: boolean
    semesterRegistrationId?: boolean
    roomId?: boolean
    facultyId?: boolean
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offeredCourseClassSchedule"]>

  export type OfferedCourseClassScheduleSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offeredCourseSectionId?: boolean
    semesterRegistrationId?: boolean
    roomId?: boolean
    facultyId?: boolean
  }

  export type OfferedCourseClassScheduleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    faculty?: boolean | FacultyDefaultArgs<ExtArgs>
  }


  export type $OfferedCourseClassSchedulePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "OfferedCourseClassSchedule"
    objects: {
      offeredCourseSection: Prisma.$OfferedCourseSectionPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      startTime: string
      endTime: string
      dayOfWeek: $Enums.WeekDays
      createdAt: Date
      updatedAt: Date
      offeredCourseSectionId: string
      semesterRegistrationId: string
      roomId: string
      facultyId: string
    }, ExtArgs["result"]["offeredCourseClassSchedule"]>
    composites: {}
  }


  type OfferedCourseClassScheduleGetPayload<S extends boolean | null | undefined | OfferedCourseClassScheduleDefaultArgs> = $Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload, S>

  type OfferedCourseClassScheduleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OfferedCourseClassScheduleFindManyArgs, 'select' | 'include'> & {
      select?: OfferedCourseClassScheduleCountAggregateInputType | true
    }

  export interface OfferedCourseClassScheduleDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferedCourseClassSchedule'], meta: { name: 'OfferedCourseClassSchedule' } }
    /**
     * Find zero or one OfferedCourseClassSchedule that matches the filter.
     * @param {OfferedCourseClassScheduleFindUniqueArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferedCourseClassScheduleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseClassScheduleFindUniqueArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OfferedCourseClassSchedule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfferedCourseClassScheduleFindUniqueOrThrowArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OfferedCourseClassSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindFirstArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferedCourseClassScheduleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseClassScheduleFindFirstArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OfferedCourseClassSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindFirstOrThrowArgs} args - Arguments to find a OfferedCourseClassSchedule
     * @example
     * // Get one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OfferedCourseClassSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferedCourseClassSchedules
     * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany()
     * 
     * // Get first 10 OfferedCourseClassSchedules
     * const offeredCourseClassSchedules = await prisma.offeredCourseClassSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeredCourseClassScheduleWithIdOnly = await prisma.offeredCourseClassSchedule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferedCourseClassScheduleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseClassScheduleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleCreateArgs} args - Arguments to create a OfferedCourseClassSchedule.
     * @example
     * // Create one OfferedCourseClassSchedule
     * const OfferedCourseClassSchedule = await prisma.offeredCourseClassSchedule.create({
     *   data: {
     *     // ... data to create a OfferedCourseClassSchedule
     *   }
     * })
     * 
    **/
    create<T extends OfferedCourseClassScheduleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseClassScheduleCreateArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OfferedCourseClassSchedules.
     *     @param {OfferedCourseClassScheduleCreateManyArgs} args - Arguments to create many OfferedCourseClassSchedules.
     *     @example
     *     // Create many OfferedCourseClassSchedules
     *     const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferedCourseClassScheduleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseClassScheduleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleDeleteArgs} args - Arguments to delete one OfferedCourseClassSchedule.
     * @example
     * // Delete one OfferedCourseClassSchedule
     * const OfferedCourseClassSchedule = await prisma.offeredCourseClassSchedule.delete({
     *   where: {
     *     // ... filter to delete one OfferedCourseClassSchedule
     *   }
     * })
     * 
    **/
    delete<T extends OfferedCourseClassScheduleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseClassScheduleDeleteArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleUpdateArgs} args - Arguments to update one OfferedCourseClassSchedule.
     * @example
     * // Update one OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferedCourseClassScheduleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseClassScheduleUpdateArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OfferedCourseClassSchedules.
     * @param {OfferedCourseClassScheduleDeleteManyArgs} args - Arguments to filter OfferedCourseClassSchedules to delete.
     * @example
     * // Delete a few OfferedCourseClassSchedules
     * const { count } = await prisma.offeredCourseClassSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferedCourseClassScheduleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OfferedCourseClassScheduleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferedCourseClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferedCourseClassSchedules
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferedCourseClassScheduleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseClassScheduleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferedCourseClassSchedule.
     * @param {OfferedCourseClassScheduleUpsertArgs} args - Arguments to update or create a OfferedCourseClassSchedule.
     * @example
     * // Update or create a OfferedCourseClassSchedule
     * const offeredCourseClassSchedule = await prisma.offeredCourseClassSchedule.upsert({
     *   create: {
     *     // ... data to create a OfferedCourseClassSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferedCourseClassSchedule we want to update
     *   }
     * })
    **/
    upsert<T extends OfferedCourseClassScheduleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OfferedCourseClassScheduleUpsertArgs<ExtArgs>>
    ): Prisma__OfferedCourseClassScheduleClient<$Result.GetResult<Prisma.$OfferedCourseClassSchedulePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OfferedCourseClassSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleCountArgs} args - Arguments to filter OfferedCourseClassSchedules to count.
     * @example
     * // Count the number of OfferedCourseClassSchedules
     * const count = await prisma.offeredCourseClassSchedule.count({
     *   where: {
     *     // ... the filter for the OfferedCourseClassSchedules we want to count
     *   }
     * })
    **/
    count<T extends OfferedCourseClassScheduleCountArgs>(
      args?: Subset<T, OfferedCourseClassScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferedCourseClassScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferedCourseClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferedCourseClassScheduleAggregateArgs>(args: Subset<T, OfferedCourseClassScheduleAggregateArgs>): Prisma.PrismaPromise<GetOfferedCourseClassScheduleAggregateType<T>>

    /**
     * Group by OfferedCourseClassSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferedCourseClassScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferedCourseClassScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferedCourseClassScheduleGroupByArgs['orderBy'] }
        : { orderBy?: OfferedCourseClassScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferedCourseClassScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferedCourseClassScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferedCourseClassSchedule model
   */
  readonly fields: OfferedCourseClassScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferedCourseClassSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferedCourseClassScheduleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    offeredCourseSection<T extends OfferedCourseSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSectionDefaultArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    faculty<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OfferedCourseClassSchedule model
   */ 
  interface OfferedCourseClassScheduleFieldRefs {
    readonly id: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly startTime: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly endTime: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly dayOfWeek: FieldRef<"OfferedCourseClassSchedule", 'WeekDays'>
    readonly createdAt: FieldRef<"OfferedCourseClassSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferedCourseClassSchedule", 'DateTime'>
    readonly offeredCourseSectionId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly semesterRegistrationId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly roomId: FieldRef<"OfferedCourseClassSchedule", 'String'>
    readonly facultyId: FieldRef<"OfferedCourseClassSchedule", 'String'>
  }
    

  // Custom InputTypes

  /**
   * OfferedCourseClassSchedule findUnique
   */
  export type OfferedCourseClassScheduleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }


  /**
   * OfferedCourseClassSchedule findUniqueOrThrow
   */
  export type OfferedCourseClassScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }


  /**
   * OfferedCourseClassSchedule findFirst
   */
  export type OfferedCourseClassScheduleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseClassSchedules.
     */
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }


  /**
   * OfferedCourseClassSchedule findFirstOrThrow
   */
  export type OfferedCourseClassScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedule to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferedCourseClassSchedules.
     */
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }


  /**
   * OfferedCourseClassSchedule findMany
   */
  export type OfferedCourseClassScheduleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter, which OfferedCourseClassSchedules to fetch.
     */
    where?: OfferedCourseClassScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferedCourseClassSchedules to fetch.
     */
    orderBy?: OfferedCourseClassScheduleOrderByWithRelationInput | OfferedCourseClassScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferedCourseClassSchedules.
     */
    cursor?: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferedCourseClassSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferedCourseClassSchedules.
     */
    skip?: number
    distinct?: OfferedCourseClassScheduleScalarFieldEnum | OfferedCourseClassScheduleScalarFieldEnum[]
  }


  /**
   * OfferedCourseClassSchedule create
   */
  export type OfferedCourseClassScheduleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferedCourseClassSchedule.
     */
    data: XOR<OfferedCourseClassScheduleCreateInput, OfferedCourseClassScheduleUncheckedCreateInput>
  }


  /**
   * OfferedCourseClassSchedule createMany
   */
  export type OfferedCourseClassScheduleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferedCourseClassSchedules.
     */
    data: OfferedCourseClassScheduleCreateManyInput | OfferedCourseClassScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OfferedCourseClassSchedule update
   */
  export type OfferedCourseClassScheduleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferedCourseClassSchedule.
     */
    data: XOR<OfferedCourseClassScheduleUpdateInput, OfferedCourseClassScheduleUncheckedUpdateInput>
    /**
     * Choose, which OfferedCourseClassSchedule to update.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }


  /**
   * OfferedCourseClassSchedule updateMany
   */
  export type OfferedCourseClassScheduleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferedCourseClassSchedules.
     */
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyInput>
    /**
     * Filter which OfferedCourseClassSchedules to update
     */
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * OfferedCourseClassSchedule upsert
   */
  export type OfferedCourseClassScheduleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferedCourseClassSchedule to update in case it exists.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
    /**
     * In case the OfferedCourseClassSchedule found by the `where` argument doesn't exist, create a new OfferedCourseClassSchedule with this data.
     */
    create: XOR<OfferedCourseClassScheduleCreateInput, OfferedCourseClassScheduleUncheckedCreateInput>
    /**
     * In case the OfferedCourseClassSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferedCourseClassScheduleUpdateInput, OfferedCourseClassScheduleUncheckedUpdateInput>
  }


  /**
   * OfferedCourseClassSchedule delete
   */
  export type OfferedCourseClassScheduleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
    /**
     * Filter which OfferedCourseClassSchedule to delete.
     */
    where: OfferedCourseClassScheduleWhereUniqueInput
  }


  /**
   * OfferedCourseClassSchedule deleteMany
   */
  export type OfferedCourseClassScheduleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferedCourseClassSchedules to delete
     */
    where?: OfferedCourseClassScheduleWhereInput
  }


  /**
   * OfferedCourseClassSchedule without action
   */
  export type OfferedCourseClassScheduleDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferedCourseClassSchedule
     */
    select?: OfferedCourseClassScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferedCourseClassScheduleInclude<ExtArgs> | null
  }



  /**
   * Model StudentSemesterRegistration
   */

  export type AggregateStudentSemesterRegistration = {
    _count: StudentSemesterRegistrationCountAggregateOutputType | null
    _avg: StudentSemesterRegistrationAvgAggregateOutputType | null
    _sum: StudentSemesterRegistrationSumAggregateOutputType | null
    _min: StudentSemesterRegistrationMinAggregateOutputType | null
    _max: StudentSemesterRegistrationMaxAggregateOutputType | null
  }

  export type StudentSemesterRegistrationAvgAggregateOutputType = {
    totalCreditsTaken: number | null
  }

  export type StudentSemesterRegistrationSumAggregateOutputType = {
    totalCreditsTaken: number | null
  }

  export type StudentSemesterRegistrationMinAggregateOutputType = {
    id: string | null
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    semesterRegistrationId: string | null
  }

  export type StudentSemesterRegistrationMaxAggregateOutputType = {
    id: string | null
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    semesterRegistrationId: string | null
  }

  export type StudentSemesterRegistrationCountAggregateOutputType = {
    id: number
    isConfirmed: number
    totalCreditsTaken: number
    createdAt: number
    updatedAt: number
    studentId: number
    semesterRegistrationId: number
    _all: number
  }


  export type StudentSemesterRegistrationAvgAggregateInputType = {
    totalCreditsTaken?: true
  }

  export type StudentSemesterRegistrationSumAggregateInputType = {
    totalCreditsTaken?: true
  }

  export type StudentSemesterRegistrationMinAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
  }

  export type StudentSemesterRegistrationMaxAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
  }

  export type StudentSemesterRegistrationCountAggregateInputType = {
    id?: true
    isConfirmed?: true
    totalCreditsTaken?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    semesterRegistrationId?: true
    _all?: true
  }

  export type StudentSemesterRegistrationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistration to aggregate.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterRegistrations
    **/
    _count?: true | StudentSemesterRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSemesterRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSemesterRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterRegistrationMaxAggregateInputType
  }

  export type GetStudentSemesterRegistrationAggregateType<T extends StudentSemesterRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterRegistration[P]>
      : GetScalarType<T[P], AggregateStudentSemesterRegistration[P]>
  }




  export type StudentSemesterRegistrationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationWhereInput
    orderBy?: StudentSemesterRegistrationOrderByWithAggregationInput | StudentSemesterRegistrationOrderByWithAggregationInput[]
    by: StudentSemesterRegistrationScalarFieldEnum[] | StudentSemesterRegistrationScalarFieldEnum
    having?: StudentSemesterRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterRegistrationCountAggregateInputType | true
    _avg?: StudentSemesterRegistrationAvgAggregateInputType
    _sum?: StudentSemesterRegistrationSumAggregateInputType
    _min?: StudentSemesterRegistrationMinAggregateInputType
    _max?: StudentSemesterRegistrationMaxAggregateInputType
  }

  export type StudentSemesterRegistrationGroupByOutputType = {
    id: string
    isConfirmed: boolean | null
    totalCreditsTaken: number | null
    createdAt: Date
    updatedAt: Date
    studentId: string
    semesterRegistrationId: string
    _count: StudentSemesterRegistrationCountAggregateOutputType | null
    _avg: StudentSemesterRegistrationAvgAggregateOutputType | null
    _sum: StudentSemesterRegistrationSumAggregateOutputType | null
    _min: StudentSemesterRegistrationMinAggregateOutputType | null
    _max: StudentSemesterRegistrationMaxAggregateOutputType | null
  }

  type GetStudentSemesterRegistrationGroupByPayload<T extends StudentSemesterRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterRegistrationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isConfirmed?: boolean
    totalCreditsTaken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    semesterRegistrationId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterRegistration"]>

  export type StudentSemesterRegistrationSelectScalar = {
    id?: boolean
    isConfirmed?: boolean
    totalCreditsTaken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    semesterRegistrationId?: boolean
  }

  export type StudentSemesterRegistrationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
  }


  export type $StudentSemesterRegistrationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StudentSemesterRegistration"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      isConfirmed: boolean | null
      totalCreditsTaken: number | null
      createdAt: Date
      updatedAt: Date
      studentId: string
      semesterRegistrationId: string
    }, ExtArgs["result"]["studentSemesterRegistration"]>
    composites: {}
  }


  type StudentSemesterRegistrationGetPayload<S extends boolean | null | undefined | StudentSemesterRegistrationDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterRegistrationPayload, S>

  type StudentSemesterRegistrationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentSemesterRegistrationFindManyArgs, 'select' | 'include'> & {
      select?: StudentSemesterRegistrationCountAggregateInputType | true
    }

  export interface StudentSemesterRegistrationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterRegistration'], meta: { name: 'StudentSemesterRegistration' } }
    /**
     * Find zero or one StudentSemesterRegistration that matches the filter.
     * @param {StudentSemesterRegistrationFindUniqueArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentSemesterRegistrationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentSemesterRegistration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentSemesterRegistrationFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentSemesterRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindFirstArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentSemesterRegistrationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationFindFirstArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentSemesterRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterRegistration
     * @example
     * // Get one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentSemesterRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterRegistrations
     * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany()
     * 
     * // Get first 10 StudentSemesterRegistrations
     * const studentSemesterRegistrations = await prisma.studentSemesterRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSemesterRegistrationWithIdOnly = await prisma.studentSemesterRegistration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentSemesterRegistrationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationCreateArgs} args - Arguments to create a StudentSemesterRegistration.
     * @example
     * // Create one StudentSemesterRegistration
     * const StudentSemesterRegistration = await prisma.studentSemesterRegistration.create({
     *   data: {
     *     // ... data to create a StudentSemesterRegistration
     *   }
     * })
     * 
    **/
    create<T extends StudentSemesterRegistrationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationCreateArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentSemesterRegistrations.
     *     @param {StudentSemesterRegistrationCreateManyArgs} args - Arguments to create many StudentSemesterRegistrations.
     *     @example
     *     // Create many StudentSemesterRegistrations
     *     const studentSemesterRegistration = await prisma.studentSemesterRegistration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentSemesterRegistrationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationDeleteArgs} args - Arguments to delete one StudentSemesterRegistration.
     * @example
     * // Delete one StudentSemesterRegistration
     * const StudentSemesterRegistration = await prisma.studentSemesterRegistration.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterRegistration
     *   }
     * })
     * 
    **/
    delete<T extends StudentSemesterRegistrationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationDeleteArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationUpdateArgs} args - Arguments to update one StudentSemesterRegistration.
     * @example
     * // Update one StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentSemesterRegistrationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationUpdateArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentSemesterRegistrations.
     * @param {StudentSemesterRegistrationDeleteManyArgs} args - Arguments to filter StudentSemesterRegistrations to delete.
     * @example
     * // Delete a few StudentSemesterRegistrations
     * const { count } = await prisma.studentSemesterRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentSemesterRegistrationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterRegistrations
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentSemesterRegistrationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterRegistration.
     * @param {StudentSemesterRegistrationUpsertArgs} args - Arguments to update or create a StudentSemesterRegistration.
     * @example
     * // Update or create a StudentSemesterRegistration
     * const studentSemesterRegistration = await prisma.studentSemesterRegistration.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterRegistration we want to update
     *   }
     * })
    **/
    upsert<T extends StudentSemesterRegistrationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationUpsertArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentSemesterRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCountArgs} args - Arguments to filter StudentSemesterRegistrations to count.
     * @example
     * // Count the number of StudentSemesterRegistrations
     * const count = await prisma.studentSemesterRegistration.count({
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrations we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterRegistrationCountArgs>(
      args?: Subset<T, StudentSemesterRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterRegistrationAggregateArgs>(args: Subset<T, StudentSemesterRegistrationAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterRegistrationAggregateType<T>>

    /**
     * Group by StudentSemesterRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterRegistration model
   */
  readonly fields: StudentSemesterRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterRegistrationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentSemesterRegistration model
   */ 
  interface StudentSemesterRegistrationFieldRefs {
    readonly id: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly isConfirmed: FieldRef<"StudentSemesterRegistration", 'Boolean'>
    readonly totalCreditsTaken: FieldRef<"StudentSemesterRegistration", 'Int'>
    readonly createdAt: FieldRef<"StudentSemesterRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterRegistration", 'DateTime'>
    readonly studentId: FieldRef<"StudentSemesterRegistration", 'String'>
    readonly semesterRegistrationId: FieldRef<"StudentSemesterRegistration", 'String'>
  }
    

  // Custom InputTypes

  /**
   * StudentSemesterRegistration findUnique
   */
  export type StudentSemesterRegistrationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }


  /**
   * StudentSemesterRegistration findUniqueOrThrow
   */
  export type StudentSemesterRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }


  /**
   * StudentSemesterRegistration findFirst
   */
  export type StudentSemesterRegistrationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrations.
     */
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }


  /**
   * StudentSemesterRegistration findFirstOrThrow
   */
  export type StudentSemesterRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistration to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrations.
     */
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }


  /**
   * StudentSemesterRegistration findMany
   */
  export type StudentSemesterRegistrationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrations to fetch.
     */
    where?: StudentSemesterRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrations to fetch.
     */
    orderBy?: StudentSemesterRegistrationOrderByWithRelationInput | StudentSemesterRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterRegistrations.
     */
    cursor?: StudentSemesterRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrations.
     */
    skip?: number
    distinct?: StudentSemesterRegistrationScalarFieldEnum | StudentSemesterRegistrationScalarFieldEnum[]
  }


  /**
   * StudentSemesterRegistration create
   */
  export type StudentSemesterRegistrationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterRegistration.
     */
    data: XOR<StudentSemesterRegistrationCreateInput, StudentSemesterRegistrationUncheckedCreateInput>
  }


  /**
   * StudentSemesterRegistration createMany
   */
  export type StudentSemesterRegistrationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterRegistrations.
     */
    data: StudentSemesterRegistrationCreateManyInput | StudentSemesterRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentSemesterRegistration update
   */
  export type StudentSemesterRegistrationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterRegistration.
     */
    data: XOR<StudentSemesterRegistrationUpdateInput, StudentSemesterRegistrationUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterRegistration to update.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }


  /**
   * StudentSemesterRegistration updateMany
   */
  export type StudentSemesterRegistrationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterRegistrations.
     */
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterRegistrations to update
     */
    where?: StudentSemesterRegistrationWhereInput
  }


  /**
   * StudentSemesterRegistration upsert
   */
  export type StudentSemesterRegistrationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterRegistration to update in case it exists.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
    /**
     * In case the StudentSemesterRegistration found by the `where` argument doesn't exist, create a new StudentSemesterRegistration with this data.
     */
    create: XOR<StudentSemesterRegistrationCreateInput, StudentSemesterRegistrationUncheckedCreateInput>
    /**
     * In case the StudentSemesterRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterRegistrationUpdateInput, StudentSemesterRegistrationUncheckedUpdateInput>
  }


  /**
   * StudentSemesterRegistration delete
   */
  export type StudentSemesterRegistrationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterRegistration to delete.
     */
    where: StudentSemesterRegistrationWhereUniqueInput
  }


  /**
   * StudentSemesterRegistration deleteMany
   */
  export type StudentSemesterRegistrationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrations to delete
     */
    where?: StudentSemesterRegistrationWhereInput
  }


  /**
   * StudentSemesterRegistration without action
   */
  export type StudentSemesterRegistrationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistration
     */
    select?: StudentSemesterRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationInclude<ExtArgs> | null
  }



  /**
   * Model StudentSemesterRegistrationCourse
   */

  export type AggregateStudentSemesterRegistrationCourse = {
    _count: StudentSemesterRegistrationCourseCountAggregateOutputType | null
    _min: StudentSemesterRegistrationCourseMinAggregateOutputType | null
    _max: StudentSemesterRegistrationCourseMaxAggregateOutputType | null
  }

  export type StudentSemesterRegistrationCourseMinAggregateOutputType = {
    semesterRegistrationId: string | null
    studentId: string | null
    offeredCourseId: string | null
    offeredCourseSectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSemesterRegistrationCourseMaxAggregateOutputType = {
    semesterRegistrationId: string | null
    studentId: string | null
    offeredCourseId: string | null
    offeredCourseSectionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentSemesterRegistrationCourseCountAggregateOutputType = {
    semesterRegistrationId: number
    studentId: number
    offeredCourseId: number
    offeredCourseSectionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentSemesterRegistrationCourseMinAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSemesterRegistrationCourseMaxAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentSemesterRegistrationCourseCountAggregateInputType = {
    semesterRegistrationId?: true
    studentId?: true
    offeredCourseId?: true
    offeredCourseSectionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentSemesterRegistrationCourseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrationCourse to aggregate.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterRegistrationCourses
    **/
    _count?: true | StudentSemesterRegistrationCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterRegistrationCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterRegistrationCourseMaxAggregateInputType
  }

  export type GetStudentSemesterRegistrationCourseAggregateType<T extends StudentSemesterRegistrationCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterRegistrationCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterRegistrationCourse[P]>
      : GetScalarType<T[P], AggregateStudentSemesterRegistrationCourse[P]>
  }




  export type StudentSemesterRegistrationCourseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterRegistrationCourseWhereInput
    orderBy?: StudentSemesterRegistrationCourseOrderByWithAggregationInput | StudentSemesterRegistrationCourseOrderByWithAggregationInput[]
    by: StudentSemesterRegistrationCourseScalarFieldEnum[] | StudentSemesterRegistrationCourseScalarFieldEnum
    having?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterRegistrationCourseCountAggregateInputType | true
    _min?: StudentSemesterRegistrationCourseMinAggregateInputType
    _max?: StudentSemesterRegistrationCourseMaxAggregateInputType
  }

  export type StudentSemesterRegistrationCourseGroupByOutputType = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt: Date
    updatedAt: Date
    _count: StudentSemesterRegistrationCourseCountAggregateOutputType | null
    _min: StudentSemesterRegistrationCourseMinAggregateOutputType | null
    _max: StudentSemesterRegistrationCourseMaxAggregateOutputType | null
  }

  type GetStudentSemesterRegistrationCourseGroupByPayload<T extends StudentSemesterRegistrationCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterRegistrationCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterRegistrationCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterRegistrationCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterRegistrationCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterRegistrationCourseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    semesterRegistrationId?: boolean
    studentId?: boolean
    offeredCourseId?: boolean
    offeredCourseSectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterRegistrationCourse"]>

  export type StudentSemesterRegistrationCourseSelectScalar = {
    semesterRegistrationId?: boolean
    studentId?: boolean
    offeredCourseId?: boolean
    offeredCourseSectionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentSemesterRegistrationCourseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    semesterRegistration?: boolean | SemesterRegistrationDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    offeredCourse?: boolean | OfferedCourseDefaultArgs<ExtArgs>
    offeredCourseSection?: boolean | OfferedCourseSectionDefaultArgs<ExtArgs>
  }


  export type $StudentSemesterRegistrationCoursePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StudentSemesterRegistrationCourse"
    objects: {
      semesterRegistration: Prisma.$SemesterRegistrationPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      offeredCourse: Prisma.$OfferedCoursePayload<ExtArgs>
      offeredCourseSection: Prisma.$OfferedCourseSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      semesterRegistrationId: string
      studentId: string
      offeredCourseId: string
      offeredCourseSectionId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentSemesterRegistrationCourse"]>
    composites: {}
  }


  type StudentSemesterRegistrationCourseGetPayload<S extends boolean | null | undefined | StudentSemesterRegistrationCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload, S>

  type StudentSemesterRegistrationCourseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentSemesterRegistrationCourseFindManyArgs, 'select' | 'include'> & {
      select?: StudentSemesterRegistrationCourseCountAggregateInputType | true
    }

  export interface StudentSemesterRegistrationCourseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterRegistrationCourse'], meta: { name: 'StudentSemesterRegistrationCourse' } }
    /**
     * Find zero or one StudentSemesterRegistrationCourse that matches the filter.
     * @param {StudentSemesterRegistrationCourseFindUniqueArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentSemesterRegistrationCourse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentSemesterRegistrationCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentSemesterRegistrationCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindFirstArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentSemesterRegistrationCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterRegistrationCourse
     * @example
     * // Get one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentSemesterRegistrationCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany()
     * 
     * // Get first 10 StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourses = await prisma.studentSemesterRegistrationCourse.findMany({ take: 10 })
     * 
     * // Only select the `semesterRegistrationId`
     * const studentSemesterRegistrationCourseWithSemesterRegistrationIdOnly = await prisma.studentSemesterRegistrationCourse.findMany({ select: { semesterRegistrationId: true } })
     * 
    **/
    findMany<T extends StudentSemesterRegistrationCourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseCreateArgs} args - Arguments to create a StudentSemesterRegistrationCourse.
     * @example
     * // Create one StudentSemesterRegistrationCourse
     * const StudentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.create({
     *   data: {
     *     // ... data to create a StudentSemesterRegistrationCourse
     *   }
     * })
     * 
    **/
    create<T extends StudentSemesterRegistrationCourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationCourseCreateArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentSemesterRegistrationCourses.
     *     @param {StudentSemesterRegistrationCourseCreateManyArgs} args - Arguments to create many StudentSemesterRegistrationCourses.
     *     @example
     *     // Create many StudentSemesterRegistrationCourses
     *     const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseDeleteArgs} args - Arguments to delete one StudentSemesterRegistrationCourse.
     * @example
     * // Delete one StudentSemesterRegistrationCourse
     * const StudentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterRegistrationCourse
     *   }
     * })
     * 
    **/
    delete<T extends StudentSemesterRegistrationCourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationCourseDeleteArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseUpdateArgs} args - Arguments to update one StudentSemesterRegistrationCourse.
     * @example
     * // Update one StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentSemesterRegistrationCourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationCourseUpdateArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentSemesterRegistrationCourses.
     * @param {StudentSemesterRegistrationCourseDeleteManyArgs} args - Arguments to filter StudentSemesterRegistrationCourses to delete.
     * @example
     * // Delete a few StudentSemesterRegistrationCourses
     * const { count } = await prisma.studentSemesterRegistrationCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterRegistrationCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterRegistrationCourses
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterRegistrationCourse.
     * @param {StudentSemesterRegistrationCourseUpsertArgs} args - Arguments to update or create a StudentSemesterRegistrationCourse.
     * @example
     * // Update or create a StudentSemesterRegistrationCourse
     * const studentSemesterRegistrationCourse = await prisma.studentSemesterRegistrationCourse.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterRegistrationCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrationCourse we want to update
     *   }
     * })
    **/
    upsert<T extends StudentSemesterRegistrationCourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterRegistrationCourseUpsertArgs<ExtArgs>>
    ): Prisma__StudentSemesterRegistrationCourseClient<$Result.GetResult<Prisma.$StudentSemesterRegistrationCoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentSemesterRegistrationCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseCountArgs} args - Arguments to filter StudentSemesterRegistrationCourses to count.
     * @example
     * // Count the number of StudentSemesterRegistrationCourses
     * const count = await prisma.studentSemesterRegistrationCourse.count({
     *   where: {
     *     // ... the filter for the StudentSemesterRegistrationCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterRegistrationCourseCountArgs>(
      args?: Subset<T, StudentSemesterRegistrationCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterRegistrationCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterRegistrationCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterRegistrationCourseAggregateArgs>(args: Subset<T, StudentSemesterRegistrationCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterRegistrationCourseAggregateType<T>>

    /**
     * Group by StudentSemesterRegistrationCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterRegistrationCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterRegistrationCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterRegistrationCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterRegistrationCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterRegistrationCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterRegistrationCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterRegistrationCourse model
   */
  readonly fields: StudentSemesterRegistrationCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterRegistrationCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterRegistrationCourseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    semesterRegistration<T extends SemesterRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SemesterRegistrationDefaultArgs<ExtArgs>>): Prisma__SemesterRegistrationClient<$Result.GetResult<Prisma.$SemesterRegistrationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    offeredCourse<T extends OfferedCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseDefaultArgs<ExtArgs>>): Prisma__OfferedCourseClient<$Result.GetResult<Prisma.$OfferedCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    offeredCourseSection<T extends OfferedCourseSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferedCourseSectionDefaultArgs<ExtArgs>>): Prisma__OfferedCourseSectionClient<$Result.GetResult<Prisma.$OfferedCourseSectionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentSemesterRegistrationCourse model
   */ 
  interface StudentSemesterRegistrationCourseFieldRefs {
    readonly semesterRegistrationId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly studentId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly offeredCourseId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly offeredCourseSectionId: FieldRef<"StudentSemesterRegistrationCourse", 'String'>
    readonly createdAt: FieldRef<"StudentSemesterRegistrationCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterRegistrationCourse", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * StudentSemesterRegistrationCourse findUnique
   */
  export type StudentSemesterRegistrationCourseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }


  /**
   * StudentSemesterRegistrationCourse findUniqueOrThrow
   */
  export type StudentSemesterRegistrationCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }


  /**
   * StudentSemesterRegistrationCourse findFirst
   */
  export type StudentSemesterRegistrationCourseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrationCourses.
     */
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }


  /**
   * StudentSemesterRegistrationCourse findFirstOrThrow
   */
  export type StudentSemesterRegistrationCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourse to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterRegistrationCourses.
     */
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }


  /**
   * StudentSemesterRegistrationCourse findMany
   */
  export type StudentSemesterRegistrationCourseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterRegistrationCourses to fetch.
     */
    where?: StudentSemesterRegistrationCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterRegistrationCourses to fetch.
     */
    orderBy?: StudentSemesterRegistrationCourseOrderByWithRelationInput | StudentSemesterRegistrationCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterRegistrationCourses.
     */
    cursor?: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterRegistrationCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterRegistrationCourses.
     */
    skip?: number
    distinct?: StudentSemesterRegistrationCourseScalarFieldEnum | StudentSemesterRegistrationCourseScalarFieldEnum[]
  }


  /**
   * StudentSemesterRegistrationCourse create
   */
  export type StudentSemesterRegistrationCourseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterRegistrationCourse.
     */
    data: XOR<StudentSemesterRegistrationCourseCreateInput, StudentSemesterRegistrationCourseUncheckedCreateInput>
  }


  /**
   * StudentSemesterRegistrationCourse createMany
   */
  export type StudentSemesterRegistrationCourseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterRegistrationCourses.
     */
    data: StudentSemesterRegistrationCourseCreateManyInput | StudentSemesterRegistrationCourseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentSemesterRegistrationCourse update
   */
  export type StudentSemesterRegistrationCourseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterRegistrationCourse.
     */
    data: XOR<StudentSemesterRegistrationCourseUpdateInput, StudentSemesterRegistrationCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterRegistrationCourse to update.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }


  /**
   * StudentSemesterRegistrationCourse updateMany
   */
  export type StudentSemesterRegistrationCourseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterRegistrationCourses.
     */
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterRegistrationCourses to update
     */
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * StudentSemesterRegistrationCourse upsert
   */
  export type StudentSemesterRegistrationCourseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterRegistrationCourse to update in case it exists.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    /**
     * In case the StudentSemesterRegistrationCourse found by the `where` argument doesn't exist, create a new StudentSemesterRegistrationCourse with this data.
     */
    create: XOR<StudentSemesterRegistrationCourseCreateInput, StudentSemesterRegistrationCourseUncheckedCreateInput>
    /**
     * In case the StudentSemesterRegistrationCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterRegistrationCourseUpdateInput, StudentSemesterRegistrationCourseUncheckedUpdateInput>
  }


  /**
   * StudentSemesterRegistrationCourse delete
   */
  export type StudentSemesterRegistrationCourseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterRegistrationCourse to delete.
     */
    where: StudentSemesterRegistrationCourseWhereUniqueInput
  }


  /**
   * StudentSemesterRegistrationCourse deleteMany
   */
  export type StudentSemesterRegistrationCourseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterRegistrationCourses to delete
     */
    where?: StudentSemesterRegistrationCourseWhereInput
  }


  /**
   * StudentSemesterRegistrationCourse without action
   */
  export type StudentSemesterRegistrationCourseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterRegistrationCourse
     */
    select?: StudentSemesterRegistrationCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterRegistrationCourseInclude<ExtArgs> | null
  }



  /**
   * Model StudentEnrolledCourse
   */

  export type AggregateStudentEnrolledCourse = {
    _count: StudentEnrolledCourseCountAggregateOutputType | null
    _avg: StudentEnrolledCourseAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseSumAggregateOutputType | null
    _min: StudentEnrolledCourseMinAggregateOutputType | null
    _max: StudentEnrolledCourseMaxAggregateOutputType | null
  }

  export type StudentEnrolledCourseAvgAggregateOutputType = {
    point: number | null
    totalMarks: number | null
  }

  export type StudentEnrolledCourseSumAggregateOutputType = {
    point: number | null
    totalMarks: number | null
  }

  export type StudentEnrolledCourseMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    courseId: string | null
    academicSemesterId: string | null
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    courseId: string | null
    academicSemesterId: string | null
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    studentId: number
    courseId: number
    academicSemesterId: number
    grade: number
    point: number
    totalMarks: number
    status: number
    _all: number
  }


  export type StudentEnrolledCourseAvgAggregateInputType = {
    point?: true
    totalMarks?: true
  }

  export type StudentEnrolledCourseSumAggregateInputType = {
    point?: true
    totalMarks?: true
  }

  export type StudentEnrolledCourseMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    courseId?: true
    academicSemesterId?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
  }

  export type StudentEnrolledCourseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    courseId?: true
    academicSemesterId?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
  }

  export type StudentEnrolledCourseCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    courseId?: true
    academicSemesterId?: true
    grade?: true
    point?: true
    totalMarks?: true
    status?: true
    _all?: true
  }

  export type StudentEnrolledCourseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourse to aggregate.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrolledCourses
    **/
    _count?: true | StudentEnrolledCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEnrolledCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEnrolledCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrolledCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrolledCourseMaxAggregateInputType
  }

  export type GetStudentEnrolledCourseAggregateType<T extends StudentEnrolledCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrolledCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrolledCourse[P]>
      : GetScalarType<T[P], AggregateStudentEnrolledCourse[P]>
  }




  export type StudentEnrolledCourseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseWhereInput
    orderBy?: StudentEnrolledCourseOrderByWithAggregationInput | StudentEnrolledCourseOrderByWithAggregationInput[]
    by: StudentEnrolledCourseScalarFieldEnum[] | StudentEnrolledCourseScalarFieldEnum
    having?: StudentEnrolledCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrolledCourseCountAggregateInputType | true
    _avg?: StudentEnrolledCourseAvgAggregateInputType
    _sum?: StudentEnrolledCourseSumAggregateInputType
    _min?: StudentEnrolledCourseMinAggregateInputType
    _max?: StudentEnrolledCourseMaxAggregateInputType
  }

  export type StudentEnrolledCourseGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    studentId: string
    courseId: string
    academicSemesterId: string
    grade: string | null
    point: number | null
    totalMarks: number | null
    status: $Enums.StudentEnrolledCourseStatus | null
    _count: StudentEnrolledCourseCountAggregateOutputType | null
    _avg: StudentEnrolledCourseAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseSumAggregateOutputType | null
    _min: StudentEnrolledCourseMinAggregateOutputType | null
    _max: StudentEnrolledCourseMaxAggregateOutputType | null
  }

  type GetStudentEnrolledCourseGroupByPayload<T extends StudentEnrolledCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrolledCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrolledCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrolledCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrolledCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrolledCourseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    courseId?: boolean
    academicSemesterId?: boolean
    grade?: boolean
    point?: boolean
    totalMarks?: boolean
    status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>
    _count?: boolean | StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrolledCourse"]>

  export type StudentEnrolledCourseSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    courseId?: boolean
    academicSemesterId?: boolean
    grade?: boolean
    point?: boolean
    totalMarks?: boolean
    status?: boolean
  }

  export type StudentEnrolledCourseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    studentEnrolledCourseMarks?: boolean | StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>
    _count?: boolean | StudentEnrolledCourseCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentEnrolledCoursePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StudentEnrolledCourse"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      studentEnrolledCourseMarks: Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      studentId: string
      courseId: string
      academicSemesterId: string
      grade: string | null
      point: number | null
      totalMarks: number | null
      status: $Enums.StudentEnrolledCourseStatus | null
    }, ExtArgs["result"]["studentEnrolledCourse"]>
    composites: {}
  }


  type StudentEnrolledCourseGetPayload<S extends boolean | null | undefined | StudentEnrolledCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrolledCoursePayload, S>

  type StudentEnrolledCourseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentEnrolledCourseFindManyArgs, 'select' | 'include'> & {
      select?: StudentEnrolledCourseCountAggregateInputType | true
    }

  export interface StudentEnrolledCourseDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrolledCourse'], meta: { name: 'StudentEnrolledCourse' } }
    /**
     * Find zero or one StudentEnrolledCourse that matches the filter.
     * @param {StudentEnrolledCourseFindUniqueArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentEnrolledCourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentEnrolledCourse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentEnrolledCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentEnrolledCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindFirstArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentEnrolledCourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseFindFirstArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentEnrolledCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindFirstOrThrowArgs} args - Arguments to find a StudentEnrolledCourse
     * @example
     * // Get one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentEnrolledCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrolledCourses
     * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany()
     * 
     * // Get first 10 StudentEnrolledCourses
     * const studentEnrolledCourses = await prisma.studentEnrolledCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrolledCourseWithIdOnly = await prisma.studentEnrolledCourse.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentEnrolledCourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentEnrolledCourse.
     * @param {StudentEnrolledCourseCreateArgs} args - Arguments to create a StudentEnrolledCourse.
     * @example
     * // Create one StudentEnrolledCourse
     * const StudentEnrolledCourse = await prisma.studentEnrolledCourse.create({
     *   data: {
     *     // ... data to create a StudentEnrolledCourse
     *   }
     * })
     * 
    **/
    create<T extends StudentEnrolledCourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseCreateArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentEnrolledCourses.
     *     @param {StudentEnrolledCourseCreateManyArgs} args - Arguments to create many StudentEnrolledCourses.
     *     @example
     *     // Create many StudentEnrolledCourses
     *     const studentEnrolledCourse = await prisma.studentEnrolledCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentEnrolledCourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentEnrolledCourse.
     * @param {StudentEnrolledCourseDeleteArgs} args - Arguments to delete one StudentEnrolledCourse.
     * @example
     * // Delete one StudentEnrolledCourse
     * const StudentEnrolledCourse = await prisma.studentEnrolledCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrolledCourse
     *   }
     * })
     * 
    **/
    delete<T extends StudentEnrolledCourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseDeleteArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentEnrolledCourse.
     * @param {StudentEnrolledCourseUpdateArgs} args - Arguments to update one StudentEnrolledCourse.
     * @example
     * // Update one StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentEnrolledCourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseUpdateArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentEnrolledCourses.
     * @param {StudentEnrolledCourseDeleteManyArgs} args - Arguments to filter StudentEnrolledCourses to delete.
     * @example
     * // Delete a few StudentEnrolledCourses
     * const { count } = await prisma.studentEnrolledCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentEnrolledCourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrolledCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrolledCourses
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentEnrolledCourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentEnrolledCourse.
     * @param {StudentEnrolledCourseUpsertArgs} args - Arguments to update or create a StudentEnrolledCourse.
     * @example
     * // Update or create a StudentEnrolledCourse
     * const studentEnrolledCourse = await prisma.studentEnrolledCourse.upsert({
     *   create: {
     *     // ... data to create a StudentEnrolledCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrolledCourse we want to update
     *   }
     * })
    **/
    upsert<T extends StudentEnrolledCourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseUpsertArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentEnrolledCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseCountArgs} args - Arguments to filter StudentEnrolledCourses to count.
     * @example
     * // Count the number of StudentEnrolledCourses
     * const count = await prisma.studentEnrolledCourse.count({
     *   where: {
     *     // ... the filter for the StudentEnrolledCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrolledCourseCountArgs>(
      args?: Subset<T, StudentEnrolledCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrolledCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrolledCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrolledCourseAggregateArgs>(args: Subset<T, StudentEnrolledCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrolledCourseAggregateType<T>>

    /**
     * Group by StudentEnrolledCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrolledCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrolledCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrolledCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrolledCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrolledCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrolledCourse model
   */
  readonly fields: StudentEnrolledCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrolledCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrolledCourseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    studentEnrolledCourseMarks<T extends StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentEnrolledCourse model
   */ 
  interface StudentEnrolledCourseFieldRefs {
    readonly id: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly createdAt: FieldRef<"StudentEnrolledCourse", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentEnrolledCourse", 'DateTime'>
    readonly studentId: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly courseId: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly academicSemesterId: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly grade: FieldRef<"StudentEnrolledCourse", 'String'>
    readonly point: FieldRef<"StudentEnrolledCourse", 'Float'>
    readonly totalMarks: FieldRef<"StudentEnrolledCourse", 'Int'>
    readonly status: FieldRef<"StudentEnrolledCourse", 'StudentEnrolledCourseStatus'>
  }
    

  // Custom InputTypes

  /**
   * StudentEnrolledCourse findUnique
   */
  export type StudentEnrolledCourseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }


  /**
   * StudentEnrolledCourse findUniqueOrThrow
   */
  export type StudentEnrolledCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }


  /**
   * StudentEnrolledCourse findFirst
   */
  export type StudentEnrolledCourseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourses.
     */
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }


  /**
   * StudentEnrolledCourse findFirstOrThrow
   */
  export type StudentEnrolledCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourse to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourses.
     */
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }


  /**
   * StudentEnrolledCourse findMany
   */
  export type StudentEnrolledCourseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourses to fetch.
     */
    where?: StudentEnrolledCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourses to fetch.
     */
    orderBy?: StudentEnrolledCourseOrderByWithRelationInput | StudentEnrolledCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrolledCourses.
     */
    cursor?: StudentEnrolledCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourses.
     */
    skip?: number
    distinct?: StudentEnrolledCourseScalarFieldEnum | StudentEnrolledCourseScalarFieldEnum[]
  }


  /**
   * StudentEnrolledCourse create
   */
  export type StudentEnrolledCourseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrolledCourse.
     */
    data: XOR<StudentEnrolledCourseCreateInput, StudentEnrolledCourseUncheckedCreateInput>
  }


  /**
   * StudentEnrolledCourse createMany
   */
  export type StudentEnrolledCourseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrolledCourses.
     */
    data: StudentEnrolledCourseCreateManyInput | StudentEnrolledCourseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentEnrolledCourse update
   */
  export type StudentEnrolledCourseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrolledCourse.
     */
    data: XOR<StudentEnrolledCourseUpdateInput, StudentEnrolledCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrolledCourse to update.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }


  /**
   * StudentEnrolledCourse updateMany
   */
  export type StudentEnrolledCourseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrolledCourses.
     */
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrolledCourses to update
     */
    where?: StudentEnrolledCourseWhereInput
  }


  /**
   * StudentEnrolledCourse upsert
   */
  export type StudentEnrolledCourseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrolledCourse to update in case it exists.
     */
    where: StudentEnrolledCourseWhereUniqueInput
    /**
     * In case the StudentEnrolledCourse found by the `where` argument doesn't exist, create a new StudentEnrolledCourse with this data.
     */
    create: XOR<StudentEnrolledCourseCreateInput, StudentEnrolledCourseUncheckedCreateInput>
    /**
     * In case the StudentEnrolledCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrolledCourseUpdateInput, StudentEnrolledCourseUncheckedUpdateInput>
  }


  /**
   * StudentEnrolledCourse delete
   */
  export type StudentEnrolledCourseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrolledCourse to delete.
     */
    where: StudentEnrolledCourseWhereUniqueInput
  }


  /**
   * StudentEnrolledCourse deleteMany
   */
  export type StudentEnrolledCourseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourses to delete
     */
    where?: StudentEnrolledCourseWhereInput
  }


  /**
   * StudentEnrolledCourse.studentEnrolledCourseMarks
   */
  export type StudentEnrolledCourse$studentEnrolledCourseMarksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }


  /**
   * StudentEnrolledCourse without action
   */
  export type StudentEnrolledCourseDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourse
     */
    select?: StudentEnrolledCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseInclude<ExtArgs> | null
  }



  /**
   * Model StudentEnrolledCourseMark
   */

  export type AggregateStudentEnrolledCourseMark = {
    _count: StudentEnrolledCourseMarkCountAggregateOutputType | null
    _avg: StudentEnrolledCourseMarkAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseMarkSumAggregateOutputType | null
    _min: StudentEnrolledCourseMarkMinAggregateOutputType | null
    _max: StudentEnrolledCourseMarkMaxAggregateOutputType | null
  }

  export type StudentEnrolledCourseMarkAvgAggregateOutputType = {
    marks: number | null
  }

  export type StudentEnrolledCourseMarkSumAggregateOutputType = {
    marks: number | null
  }

  export type StudentEnrolledCourseMarkMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    studentEnrolledCourseId: string | null
    academicSemesterId: string | null
    grade: string | null
    marks: number | null
    examType: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    studentEnrolledCourseId: string | null
    academicSemesterId: string | null
    grade: string | null
    marks: number | null
    examType: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    studentId: number
    studentEnrolledCourseId: number
    academicSemesterId: number
    grade: number
    marks: number
    examType: number
    _all: number
  }


  export type StudentEnrolledCourseMarkAvgAggregateInputType = {
    marks?: true
  }

  export type StudentEnrolledCourseMarkSumAggregateInputType = {
    marks?: true
  }

  export type StudentEnrolledCourseMarkMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    grade?: true
    marks?: true
    examType?: true
  }

  export type StudentEnrolledCourseMarkMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    grade?: true
    marks?: true
    examType?: true
  }

  export type StudentEnrolledCourseMarkCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    studentEnrolledCourseId?: true
    academicSemesterId?: true
    grade?: true
    marks?: true
    examType?: true
    _all?: true
  }

  export type StudentEnrolledCourseMarkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourseMark to aggregate.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentEnrolledCourseMarks
    **/
    _count?: true | StudentEnrolledCourseMarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentEnrolledCourseMarkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentEnrolledCourseMarkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentEnrolledCourseMarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentEnrolledCourseMarkMaxAggregateInputType
  }

  export type GetStudentEnrolledCourseMarkAggregateType<T extends StudentEnrolledCourseMarkAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentEnrolledCourseMark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentEnrolledCourseMark[P]>
      : GetScalarType<T[P], AggregateStudentEnrolledCourseMark[P]>
  }




  export type StudentEnrolledCourseMarkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentEnrolledCourseMarkWhereInput
    orderBy?: StudentEnrolledCourseMarkOrderByWithAggregationInput | StudentEnrolledCourseMarkOrderByWithAggregationInput[]
    by: StudentEnrolledCourseMarkScalarFieldEnum[] | StudentEnrolledCourseMarkScalarFieldEnum
    having?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentEnrolledCourseMarkCountAggregateInputType | true
    _avg?: StudentEnrolledCourseMarkAvgAggregateInputType
    _sum?: StudentEnrolledCourseMarkSumAggregateInputType
    _min?: StudentEnrolledCourseMarkMinAggregateInputType
    _max?: StudentEnrolledCourseMarkMaxAggregateInputType
  }

  export type StudentEnrolledCourseMarkGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    grade: string | null
    marks: number | null
    examType: $Enums.ExamType | null
    _count: StudentEnrolledCourseMarkCountAggregateOutputType | null
    _avg: StudentEnrolledCourseMarkAvgAggregateOutputType | null
    _sum: StudentEnrolledCourseMarkSumAggregateOutputType | null
    _min: StudentEnrolledCourseMarkMinAggregateOutputType | null
    _max: StudentEnrolledCourseMarkMaxAggregateOutputType | null
  }

  type GetStudentEnrolledCourseMarkGroupByPayload<T extends StudentEnrolledCourseMarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentEnrolledCourseMarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentEnrolledCourseMarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentEnrolledCourseMarkGroupByOutputType[P]>
            : GetScalarType<T[P], StudentEnrolledCourseMarkGroupByOutputType[P]>
        }
      >
    >


  export type StudentEnrolledCourseMarkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    studentEnrolledCourseId?: boolean
    academicSemesterId?: boolean
    grade?: boolean
    marks?: boolean
    examType?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentEnrolledCourse?: boolean | StudentEnrolledCourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentEnrolledCourseMark"]>

  export type StudentEnrolledCourseMarkSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    studentEnrolledCourseId?: boolean
    academicSemesterId?: boolean
    grade?: boolean
    marks?: boolean
    examType?: boolean
  }

  export type StudentEnrolledCourseMarkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    studentEnrolledCourse?: boolean | StudentEnrolledCourseDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
  }


  export type $StudentEnrolledCourseMarkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StudentEnrolledCourseMark"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      studentEnrolledCourse: Prisma.$StudentEnrolledCoursePayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      studentId: string
      studentEnrolledCourseId: string
      academicSemesterId: string
      grade: string | null
      marks: number | null
      examType: $Enums.ExamType | null
    }, ExtArgs["result"]["studentEnrolledCourseMark"]>
    composites: {}
  }


  type StudentEnrolledCourseMarkGetPayload<S extends boolean | null | undefined | StudentEnrolledCourseMarkDefaultArgs> = $Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload, S>

  type StudentEnrolledCourseMarkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentEnrolledCourseMarkFindManyArgs, 'select' | 'include'> & {
      select?: StudentEnrolledCourseMarkCountAggregateInputType | true
    }

  export interface StudentEnrolledCourseMarkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentEnrolledCourseMark'], meta: { name: 'StudentEnrolledCourseMark' } }
    /**
     * Find zero or one StudentEnrolledCourseMark that matches the filter.
     * @param {StudentEnrolledCourseMarkFindUniqueArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentEnrolledCourseMark that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentEnrolledCourseMarkFindUniqueOrThrowArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentEnrolledCourseMark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindFirstArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentEnrolledCourseMarkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseMarkFindFirstArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentEnrolledCourseMark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindFirstOrThrowArgs} args - Arguments to find a StudentEnrolledCourseMark
     * @example
     * // Get one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentEnrolledCourseMarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentEnrolledCourseMarks
     * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany()
     * 
     * // Get first 10 StudentEnrolledCourseMarks
     * const studentEnrolledCourseMarks = await prisma.studentEnrolledCourseMark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentEnrolledCourseMarkWithIdOnly = await prisma.studentEnrolledCourseMark.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentEnrolledCourseMarkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseMarkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkCreateArgs} args - Arguments to create a StudentEnrolledCourseMark.
     * @example
     * // Create one StudentEnrolledCourseMark
     * const StudentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.create({
     *   data: {
     *     // ... data to create a StudentEnrolledCourseMark
     *   }
     * })
     * 
    **/
    create<T extends StudentEnrolledCourseMarkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseMarkCreateArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentEnrolledCourseMarks.
     *     @param {StudentEnrolledCourseMarkCreateManyArgs} args - Arguments to create many StudentEnrolledCourseMarks.
     *     @example
     *     // Create many StudentEnrolledCourseMarks
     *     const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentEnrolledCourseMarkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseMarkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkDeleteArgs} args - Arguments to delete one StudentEnrolledCourseMark.
     * @example
     * // Delete one StudentEnrolledCourseMark
     * const StudentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.delete({
     *   where: {
     *     // ... filter to delete one StudentEnrolledCourseMark
     *   }
     * })
     * 
    **/
    delete<T extends StudentEnrolledCourseMarkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseMarkDeleteArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkUpdateArgs} args - Arguments to update one StudentEnrolledCourseMark.
     * @example
     * // Update one StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentEnrolledCourseMarkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseMarkUpdateArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentEnrolledCourseMarks.
     * @param {StudentEnrolledCourseMarkDeleteManyArgs} args - Arguments to filter StudentEnrolledCourseMarks to delete.
     * @example
     * // Delete a few StudentEnrolledCourseMarks
     * const { count } = await prisma.studentEnrolledCourseMark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentEnrolledCourseMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentEnrolledCourseMarks
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentEnrolledCourseMark.
     * @param {StudentEnrolledCourseMarkUpsertArgs} args - Arguments to update or create a StudentEnrolledCourseMark.
     * @example
     * // Update or create a StudentEnrolledCourseMark
     * const studentEnrolledCourseMark = await prisma.studentEnrolledCourseMark.upsert({
     *   create: {
     *     // ... data to create a StudentEnrolledCourseMark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentEnrolledCourseMark we want to update
     *   }
     * })
    **/
    upsert<T extends StudentEnrolledCourseMarkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentEnrolledCourseMarkUpsertArgs<ExtArgs>>
    ): Prisma__StudentEnrolledCourseMarkClient<$Result.GetResult<Prisma.$StudentEnrolledCourseMarkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentEnrolledCourseMarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkCountArgs} args - Arguments to filter StudentEnrolledCourseMarks to count.
     * @example
     * // Count the number of StudentEnrolledCourseMarks
     * const count = await prisma.studentEnrolledCourseMark.count({
     *   where: {
     *     // ... the filter for the StudentEnrolledCourseMarks we want to count
     *   }
     * })
    **/
    count<T extends StudentEnrolledCourseMarkCountArgs>(
      args?: Subset<T, StudentEnrolledCourseMarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentEnrolledCourseMarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentEnrolledCourseMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentEnrolledCourseMarkAggregateArgs>(args: Subset<T, StudentEnrolledCourseMarkAggregateArgs>): Prisma.PrismaPromise<GetStudentEnrolledCourseMarkAggregateType<T>>

    /**
     * Group by StudentEnrolledCourseMark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentEnrolledCourseMarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentEnrolledCourseMarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentEnrolledCourseMarkGroupByArgs['orderBy'] }
        : { orderBy?: StudentEnrolledCourseMarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentEnrolledCourseMarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentEnrolledCourseMarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentEnrolledCourseMark model
   */
  readonly fields: StudentEnrolledCourseMarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentEnrolledCourseMark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentEnrolledCourseMarkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    studentEnrolledCourse<T extends StudentEnrolledCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentEnrolledCourseDefaultArgs<ExtArgs>>): Prisma__StudentEnrolledCourseClient<$Result.GetResult<Prisma.$StudentEnrolledCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentEnrolledCourseMark model
   */ 
  interface StudentEnrolledCourseMarkFieldRefs {
    readonly id: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly createdAt: FieldRef<"StudentEnrolledCourseMark", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentEnrolledCourseMark", 'DateTime'>
    readonly studentId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly studentEnrolledCourseId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly academicSemesterId: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly grade: FieldRef<"StudentEnrolledCourseMark", 'String'>
    readonly marks: FieldRef<"StudentEnrolledCourseMark", 'Int'>
    readonly examType: FieldRef<"StudentEnrolledCourseMark", 'ExamType'>
  }
    

  // Custom InputTypes

  /**
   * StudentEnrolledCourseMark findUnique
   */
  export type StudentEnrolledCourseMarkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }


  /**
   * StudentEnrolledCourseMark findUniqueOrThrow
   */
  export type StudentEnrolledCourseMarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }


  /**
   * StudentEnrolledCourseMark findFirst
   */
  export type StudentEnrolledCourseMarkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourseMarks.
     */
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }


  /**
   * StudentEnrolledCourseMark findFirstOrThrow
   */
  export type StudentEnrolledCourseMarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMark to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentEnrolledCourseMarks.
     */
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }


  /**
   * StudentEnrolledCourseMark findMany
   */
  export type StudentEnrolledCourseMarkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter, which StudentEnrolledCourseMarks to fetch.
     */
    where?: StudentEnrolledCourseMarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentEnrolledCourseMarks to fetch.
     */
    orderBy?: StudentEnrolledCourseMarkOrderByWithRelationInput | StudentEnrolledCourseMarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentEnrolledCourseMarks.
     */
    cursor?: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentEnrolledCourseMarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentEnrolledCourseMarks.
     */
    skip?: number
    distinct?: StudentEnrolledCourseMarkScalarFieldEnum | StudentEnrolledCourseMarkScalarFieldEnum[]
  }


  /**
   * StudentEnrolledCourseMark create
   */
  export type StudentEnrolledCourseMarkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentEnrolledCourseMark.
     */
    data: XOR<StudentEnrolledCourseMarkCreateInput, StudentEnrolledCourseMarkUncheckedCreateInput>
  }


  /**
   * StudentEnrolledCourseMark createMany
   */
  export type StudentEnrolledCourseMarkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentEnrolledCourseMarks.
     */
    data: StudentEnrolledCourseMarkCreateManyInput | StudentEnrolledCourseMarkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentEnrolledCourseMark update
   */
  export type StudentEnrolledCourseMarkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentEnrolledCourseMark.
     */
    data: XOR<StudentEnrolledCourseMarkUpdateInput, StudentEnrolledCourseMarkUncheckedUpdateInput>
    /**
     * Choose, which StudentEnrolledCourseMark to update.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }


  /**
   * StudentEnrolledCourseMark updateMany
   */
  export type StudentEnrolledCourseMarkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentEnrolledCourseMarks.
     */
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyInput>
    /**
     * Filter which StudentEnrolledCourseMarks to update
     */
    where?: StudentEnrolledCourseMarkWhereInput
  }


  /**
   * StudentEnrolledCourseMark upsert
   */
  export type StudentEnrolledCourseMarkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentEnrolledCourseMark to update in case it exists.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
    /**
     * In case the StudentEnrolledCourseMark found by the `where` argument doesn't exist, create a new StudentEnrolledCourseMark with this data.
     */
    create: XOR<StudentEnrolledCourseMarkCreateInput, StudentEnrolledCourseMarkUncheckedCreateInput>
    /**
     * In case the StudentEnrolledCourseMark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentEnrolledCourseMarkUpdateInput, StudentEnrolledCourseMarkUncheckedUpdateInput>
  }


  /**
   * StudentEnrolledCourseMark delete
   */
  export type StudentEnrolledCourseMarkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
    /**
     * Filter which StudentEnrolledCourseMark to delete.
     */
    where: StudentEnrolledCourseMarkWhereUniqueInput
  }


  /**
   * StudentEnrolledCourseMark deleteMany
   */
  export type StudentEnrolledCourseMarkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentEnrolledCourseMarks to delete
     */
    where?: StudentEnrolledCourseMarkWhereInput
  }


  /**
   * StudentEnrolledCourseMark without action
   */
  export type StudentEnrolledCourseMarkDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentEnrolledCourseMark
     */
    select?: StudentEnrolledCourseMarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentEnrolledCourseMarkInclude<ExtArgs> | null
  }



  /**
   * Model StudentSemesterPayment
   */

  export type AggregateStudentSemesterPayment = {
    _count: StudentSemesterPaymentCountAggregateOutputType | null
    _avg: StudentSemesterPaymentAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentSumAggregateOutputType | null
    _min: StudentSemesterPaymentMinAggregateOutputType | null
    _max: StudentSemesterPaymentMaxAggregateOutputType | null
  }

  export type StudentSemesterPaymentAvgAggregateOutputType = {
    fullPaymentAmount: number | null
    partialPaymentAmount: number | null
    totalDueAmount: number | null
    totalPaidAmount: number | null
  }

  export type StudentSemesterPaymentSumAggregateOutputType = {
    fullPaymentAmount: number | null
    partialPaymentAmount: number | null
    totalDueAmount: number | null
    totalPaidAmount: number | null
  }

  export type StudentSemesterPaymentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
    fullPaymentAmount: number | null
    partialPaymentAmount: number | null
    totalDueAmount: number | null
    totalPaidAmount: number | null
    paymentStatus: $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    academicSemesterId: string | null
    fullPaymentAmount: number | null
    partialPaymentAmount: number | null
    totalDueAmount: number | null
    totalPaidAmount: number | null
    paymentStatus: $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    studentId: number
    academicSemesterId: number
    fullPaymentAmount: number
    partialPaymentAmount: number
    totalDueAmount: number
    totalPaidAmount: number
    paymentStatus: number
    _all: number
  }


  export type StudentSemesterPaymentAvgAggregateInputType = {
    fullPaymentAmount?: true
    partialPaymentAmount?: true
    totalDueAmount?: true
    totalPaidAmount?: true
  }

  export type StudentSemesterPaymentSumAggregateInputType = {
    fullPaymentAmount?: true
    partialPaymentAmount?: true
    totalDueAmount?: true
    totalPaidAmount?: true
  }

  export type StudentSemesterPaymentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    fullPaymentAmount?: true
    partialPaymentAmount?: true
    totalDueAmount?: true
    totalPaidAmount?: true
    paymentStatus?: true
  }

  export type StudentSemesterPaymentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    fullPaymentAmount?: true
    partialPaymentAmount?: true
    totalDueAmount?: true
    totalPaidAmount?: true
    paymentStatus?: true
  }

  export type StudentSemesterPaymentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    academicSemesterId?: true
    fullPaymentAmount?: true
    partialPaymentAmount?: true
    totalDueAmount?: true
    totalPaidAmount?: true
    paymentStatus?: true
    _all?: true
  }

  export type StudentSemesterPaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPayment to aggregate.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterPayments
    **/
    _count?: true | StudentSemesterPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSemesterPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSemesterPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterPaymentMaxAggregateInputType
  }

  export type GetStudentSemesterPaymentAggregateType<T extends StudentSemesterPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterPayment[P]>
      : GetScalarType<T[P], AggregateStudentSemesterPayment[P]>
  }




  export type StudentSemesterPaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentWhereInput
    orderBy?: StudentSemesterPaymentOrderByWithAggregationInput | StudentSemesterPaymentOrderByWithAggregationInput[]
    by: StudentSemesterPaymentScalarFieldEnum[] | StudentSemesterPaymentScalarFieldEnum
    having?: StudentSemesterPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterPaymentCountAggregateInputType | true
    _avg?: StudentSemesterPaymentAvgAggregateInputType
    _sum?: StudentSemesterPaymentSumAggregateInputType
    _min?: StudentSemesterPaymentMinAggregateInputType
    _max?: StudentSemesterPaymentMaxAggregateInputType
  }

  export type StudentSemesterPaymentGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    studentId: string
    academicSemesterId: string
    fullPaymentAmount: number | null
    partialPaymentAmount: number | null
    totalDueAmount: number | null
    totalPaidAmount: number | null
    paymentStatus: $Enums.PaymentStatus | null
    _count: StudentSemesterPaymentCountAggregateOutputType | null
    _avg: StudentSemesterPaymentAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentSumAggregateOutputType | null
    _min: StudentSemesterPaymentMinAggregateOutputType | null
    _max: StudentSemesterPaymentMaxAggregateOutputType | null
  }

  type GetStudentSemesterPaymentGroupByPayload<T extends StudentSemesterPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterPaymentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterPaymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    fullPaymentAmount?: boolean
    partialPaymentAmount?: boolean
    totalDueAmount?: boolean
    totalPaidAmount?: boolean
    paymentStatus?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    StudentSemesterPaymentHistory?: boolean | StudentSemesterPayment$StudentSemesterPaymentHistoryArgs<ExtArgs>
    _count?: boolean | StudentSemesterPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterPayment"]>

  export type StudentSemesterPaymentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    academicSemesterId?: boolean
    fullPaymentAmount?: boolean
    partialPaymentAmount?: boolean
    totalDueAmount?: boolean
    totalPaidAmount?: boolean
    paymentStatus?: boolean
  }

  export type StudentSemesterPaymentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    academicSemester?: boolean | AcademicSemesterDefaultArgs<ExtArgs>
    StudentSemesterPaymentHistory?: boolean | StudentSemesterPayment$StudentSemesterPaymentHistoryArgs<ExtArgs>
    _count?: boolean | StudentSemesterPaymentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentSemesterPaymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StudentSemesterPayment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      academicSemester: Prisma.$AcademicSemesterPayload<ExtArgs>
      StudentSemesterPaymentHistory: Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      studentId: string
      academicSemesterId: string
      fullPaymentAmount: number | null
      partialPaymentAmount: number | null
      totalDueAmount: number | null
      totalPaidAmount: number | null
      paymentStatus: $Enums.PaymentStatus | null
    }, ExtArgs["result"]["studentSemesterPayment"]>
    composites: {}
  }


  type StudentSemesterPaymentGetPayload<S extends boolean | null | undefined | StudentSemesterPaymentDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterPaymentPayload, S>

  type StudentSemesterPaymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentSemesterPaymentFindManyArgs, 'select' | 'include'> & {
      select?: StudentSemesterPaymentCountAggregateInputType | true
    }

  export interface StudentSemesterPaymentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterPayment'], meta: { name: 'StudentSemesterPayment' } }
    /**
     * Find zero or one StudentSemesterPayment that matches the filter.
     * @param {StudentSemesterPaymentFindUniqueArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentSemesterPaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentSemesterPayment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentSemesterPaymentFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentSemesterPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindFirstArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentSemesterPaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentFindFirstArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentSemesterPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterPayment
     * @example
     * // Get one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentSemesterPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterPayments
     * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany()
     * 
     * // Get first 10 StudentSemesterPayments
     * const studentSemesterPayments = await prisma.studentSemesterPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSemesterPaymentWithIdOnly = await prisma.studentSemesterPayment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentSemesterPaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentSemesterPayment.
     * @param {StudentSemesterPaymentCreateArgs} args - Arguments to create a StudentSemesterPayment.
     * @example
     * // Create one StudentSemesterPayment
     * const StudentSemesterPayment = await prisma.studentSemesterPayment.create({
     *   data: {
     *     // ... data to create a StudentSemesterPayment
     *   }
     * })
     * 
    **/
    create<T extends StudentSemesterPaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentCreateArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentSemesterPayments.
     *     @param {StudentSemesterPaymentCreateManyArgs} args - Arguments to create many StudentSemesterPayments.
     *     @example
     *     // Create many StudentSemesterPayments
     *     const studentSemesterPayment = await prisma.studentSemesterPayment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentSemesterPaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterPayment.
     * @param {StudentSemesterPaymentDeleteArgs} args - Arguments to delete one StudentSemesterPayment.
     * @example
     * // Delete one StudentSemesterPayment
     * const StudentSemesterPayment = await prisma.studentSemesterPayment.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterPayment
     *   }
     * })
     * 
    **/
    delete<T extends StudentSemesterPaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentDeleteArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentSemesterPayment.
     * @param {StudentSemesterPaymentUpdateArgs} args - Arguments to update one StudentSemesterPayment.
     * @example
     * // Update one StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentSemesterPaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentUpdateArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentSemesterPayments.
     * @param {StudentSemesterPaymentDeleteManyArgs} args - Arguments to filter StudentSemesterPayments to delete.
     * @example
     * // Delete a few StudentSemesterPayments
     * const { count } = await prisma.studentSemesterPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentSemesterPaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterPayments
     * const studentSemesterPayment = await prisma.studentSemesterPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentSemesterPaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterPayment.
     * @param {StudentSemesterPaymentUpsertArgs} args - Arguments to update or create a StudentSemesterPayment.
     * @example
     * // Update or create a StudentSemesterPayment
     * const studentSemesterPayment = await prisma.studentSemesterPayment.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterPayment we want to update
     *   }
     * })
    **/
    upsert<T extends StudentSemesterPaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentUpsertArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentSemesterPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentCountArgs} args - Arguments to filter StudentSemesterPayments to count.
     * @example
     * // Count the number of StudentSemesterPayments
     * const count = await prisma.studentSemesterPayment.count({
     *   where: {
     *     // ... the filter for the StudentSemesterPayments we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterPaymentCountArgs>(
      args?: Subset<T, StudentSemesterPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterPaymentAggregateArgs>(args: Subset<T, StudentSemesterPaymentAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterPaymentAggregateType<T>>

    /**
     * Group by StudentSemesterPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterPaymentGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterPayment model
   */
  readonly fields: StudentSemesterPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterPaymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    academicSemester<T extends AcademicSemesterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSemesterDefaultArgs<ExtArgs>>): Prisma__AcademicSemesterClient<$Result.GetResult<Prisma.$AcademicSemesterPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    StudentSemesterPaymentHistory<T extends StudentSemesterPayment$StudentSemesterPaymentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, StudentSemesterPayment$StudentSemesterPaymentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentSemesterPayment model
   */ 
  interface StudentSemesterPaymentFieldRefs {
    readonly id: FieldRef<"StudentSemesterPayment", 'String'>
    readonly createdAt: FieldRef<"StudentSemesterPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterPayment", 'DateTime'>
    readonly studentId: FieldRef<"StudentSemesterPayment", 'String'>
    readonly academicSemesterId: FieldRef<"StudentSemesterPayment", 'String'>
    readonly fullPaymentAmount: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly partialPaymentAmount: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly totalDueAmount: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly totalPaidAmount: FieldRef<"StudentSemesterPayment", 'Int'>
    readonly paymentStatus: FieldRef<"StudentSemesterPayment", 'PaymentStatus'>
  }
    

  // Custom InputTypes

  /**
   * StudentSemesterPayment findUnique
   */
  export type StudentSemesterPaymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }


  /**
   * StudentSemesterPayment findUniqueOrThrow
   */
  export type StudentSemesterPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }


  /**
   * StudentSemesterPayment findFirst
   */
  export type StudentSemesterPaymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPayments.
     */
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }


  /**
   * StudentSemesterPayment findFirstOrThrow
   */
  export type StudentSemesterPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayment to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPayments.
     */
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }


  /**
   * StudentSemesterPayment findMany
   */
  export type StudentSemesterPaymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPayments to fetch.
     */
    where?: StudentSemesterPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPayments to fetch.
     */
    orderBy?: StudentSemesterPaymentOrderByWithRelationInput | StudentSemesterPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterPayments.
     */
    cursor?: StudentSemesterPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPayments.
     */
    skip?: number
    distinct?: StudentSemesterPaymentScalarFieldEnum | StudentSemesterPaymentScalarFieldEnum[]
  }


  /**
   * StudentSemesterPayment create
   */
  export type StudentSemesterPaymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterPayment.
     */
    data: XOR<StudentSemesterPaymentCreateInput, StudentSemesterPaymentUncheckedCreateInput>
  }


  /**
   * StudentSemesterPayment createMany
   */
  export type StudentSemesterPaymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterPayments.
     */
    data: StudentSemesterPaymentCreateManyInput | StudentSemesterPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentSemesterPayment update
   */
  export type StudentSemesterPaymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterPayment.
     */
    data: XOR<StudentSemesterPaymentUpdateInput, StudentSemesterPaymentUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterPayment to update.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }


  /**
   * StudentSemesterPayment updateMany
   */
  export type StudentSemesterPaymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterPayments.
     */
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterPayments to update
     */
    where?: StudentSemesterPaymentWhereInput
  }


  /**
   * StudentSemesterPayment upsert
   */
  export type StudentSemesterPaymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterPayment to update in case it exists.
     */
    where: StudentSemesterPaymentWhereUniqueInput
    /**
     * In case the StudentSemesterPayment found by the `where` argument doesn't exist, create a new StudentSemesterPayment with this data.
     */
    create: XOR<StudentSemesterPaymentCreateInput, StudentSemesterPaymentUncheckedCreateInput>
    /**
     * In case the StudentSemesterPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterPaymentUpdateInput, StudentSemesterPaymentUncheckedUpdateInput>
  }


  /**
   * StudentSemesterPayment delete
   */
  export type StudentSemesterPaymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterPayment to delete.
     */
    where: StudentSemesterPaymentWhereUniqueInput
  }


  /**
   * StudentSemesterPayment deleteMany
   */
  export type StudentSemesterPaymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPayments to delete
     */
    where?: StudentSemesterPaymentWhereInput
  }


  /**
   * StudentSemesterPayment.StudentSemesterPaymentHistory
   */
  export type StudentSemesterPayment$StudentSemesterPaymentHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    where?: StudentSemesterPaymentHistoryWhereInput
    orderBy?: StudentSemesterPaymentHistoryOrderByWithRelationInput | StudentSemesterPaymentHistoryOrderByWithRelationInput[]
    cursor?: StudentSemesterPaymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSemesterPaymentHistoryScalarFieldEnum | StudentSemesterPaymentHistoryScalarFieldEnum[]
  }


  /**
   * StudentSemesterPayment without action
   */
  export type StudentSemesterPaymentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPayment
     */
    select?: StudentSemesterPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentInclude<ExtArgs> | null
  }



  /**
   * Model StudentSemesterPaymentHistory
   */

  export type AggregateStudentSemesterPaymentHistory = {
    _count: StudentSemesterPaymentHistoryCountAggregateOutputType | null
    _avg: StudentSemesterPaymentHistoryAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentHistorySumAggregateOutputType | null
    _min: StudentSemesterPaymentHistoryMinAggregateOutputType | null
    _max: StudentSemesterPaymentHistoryMaxAggregateOutputType | null
  }

  export type StudentSemesterPaymentHistoryAvgAggregateOutputType = {
    dueAmount: number | null
    paidAmount: number | null
  }

  export type StudentSemesterPaymentHistorySumAggregateOutputType = {
    dueAmount: number | null
    paidAmount: number | null
  }

  export type StudentSemesterPaymentHistoryMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentSemesterPaymentId: string | null
    transactionId: string | null
    dueAmount: number | null
    paidAmount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    isPaid: boolean | null
  }

  export type StudentSemesterPaymentHistoryMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentSemesterPaymentId: string | null
    transactionId: string | null
    dueAmount: number | null
    paidAmount: number | null
    paymentMethod: $Enums.PaymentMethod | null
    isPaid: boolean | null
  }

  export type StudentSemesterPaymentHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    studentSemesterPaymentId: number
    transactionId: number
    dueAmount: number
    paidAmount: number
    paymentMethod: number
    isPaid: number
    _all: number
  }


  export type StudentSemesterPaymentHistoryAvgAggregateInputType = {
    dueAmount?: true
    paidAmount?: true
  }

  export type StudentSemesterPaymentHistorySumAggregateInputType = {
    dueAmount?: true
    paidAmount?: true
  }

  export type StudentSemesterPaymentHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentSemesterPaymentId?: true
    transactionId?: true
    dueAmount?: true
    paidAmount?: true
    paymentMethod?: true
    isPaid?: true
  }

  export type StudentSemesterPaymentHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentSemesterPaymentId?: true
    transactionId?: true
    dueAmount?: true
    paidAmount?: true
    paymentMethod?: true
    isPaid?: true
  }

  export type StudentSemesterPaymentHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentSemesterPaymentId?: true
    transactionId?: true
    dueAmount?: true
    paidAmount?: true
    paymentMethod?: true
    isPaid?: true
    _all?: true
  }

  export type StudentSemesterPaymentHistoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPaymentHistory to aggregate.
     */
    where?: StudentSemesterPaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPaymentHistories to fetch.
     */
    orderBy?: StudentSemesterPaymentHistoryOrderByWithRelationInput | StudentSemesterPaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSemesterPaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSemesterPaymentHistories
    **/
    _count?: true | StudentSemesterPaymentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSemesterPaymentHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSemesterPaymentHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSemesterPaymentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSemesterPaymentHistoryMaxAggregateInputType
  }

  export type GetStudentSemesterPaymentHistoryAggregateType<T extends StudentSemesterPaymentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSemesterPaymentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSemesterPaymentHistory[P]>
      : GetScalarType<T[P], AggregateStudentSemesterPaymentHistory[P]>
  }




  export type StudentSemesterPaymentHistoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentSemesterPaymentHistoryWhereInput
    orderBy?: StudentSemesterPaymentHistoryOrderByWithAggregationInput | StudentSemesterPaymentHistoryOrderByWithAggregationInput[]
    by: StudentSemesterPaymentHistoryScalarFieldEnum[] | StudentSemesterPaymentHistoryScalarFieldEnum
    having?: StudentSemesterPaymentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSemesterPaymentHistoryCountAggregateInputType | true
    _avg?: StudentSemesterPaymentHistoryAvgAggregateInputType
    _sum?: StudentSemesterPaymentHistorySumAggregateInputType
    _min?: StudentSemesterPaymentHistoryMinAggregateInputType
    _max?: StudentSemesterPaymentHistoryMaxAggregateInputType
  }

  export type StudentSemesterPaymentHistoryGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    studentSemesterPaymentId: string
    transactionId: string
    dueAmount: number
    paidAmount: number
    paymentMethod: $Enums.PaymentMethod
    isPaid: boolean | null
    _count: StudentSemesterPaymentHistoryCountAggregateOutputType | null
    _avg: StudentSemesterPaymentHistoryAvgAggregateOutputType | null
    _sum: StudentSemesterPaymentHistorySumAggregateOutputType | null
    _min: StudentSemesterPaymentHistoryMinAggregateOutputType | null
    _max: StudentSemesterPaymentHistoryMaxAggregateOutputType | null
  }

  type GetStudentSemesterPaymentHistoryGroupByPayload<T extends StudentSemesterPaymentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSemesterPaymentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSemesterPaymentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSemesterPaymentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSemesterPaymentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type StudentSemesterPaymentHistorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentSemesterPaymentId?: boolean
    transactionId?: boolean
    dueAmount?: boolean
    paidAmount?: boolean
    paymentMethod?: boolean
    isPaid?: boolean
    studentSemesterPayment?: boolean | StudentSemesterPaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSemesterPaymentHistory"]>

  export type StudentSemesterPaymentHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentSemesterPaymentId?: boolean
    transactionId?: boolean
    dueAmount?: boolean
    paidAmount?: boolean
    paymentMethod?: boolean
    isPaid?: boolean
  }

  export type StudentSemesterPaymentHistoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    studentSemesterPayment?: boolean | StudentSemesterPaymentDefaultArgs<ExtArgs>
  }


  export type $StudentSemesterPaymentHistoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StudentSemesterPaymentHistory"
    objects: {
      studentSemesterPayment: Prisma.$StudentSemesterPaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      studentSemesterPaymentId: string
      transactionId: string
      dueAmount: number
      paidAmount: number
      paymentMethod: $Enums.PaymentMethod
      isPaid: boolean | null
    }, ExtArgs["result"]["studentSemesterPaymentHistory"]>
    composites: {}
  }


  type StudentSemesterPaymentHistoryGetPayload<S extends boolean | null | undefined | StudentSemesterPaymentHistoryDefaultArgs> = $Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload, S>

  type StudentSemesterPaymentHistoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentSemesterPaymentHistoryFindManyArgs, 'select' | 'include'> & {
      select?: StudentSemesterPaymentHistoryCountAggregateInputType | true
    }

  export interface StudentSemesterPaymentHistoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSemesterPaymentHistory'], meta: { name: 'StudentSemesterPaymentHistory' } }
    /**
     * Find zero or one StudentSemesterPaymentHistory that matches the filter.
     * @param {StudentSemesterPaymentHistoryFindUniqueArgs} args - Arguments to find a StudentSemesterPaymentHistory
     * @example
     * // Get one StudentSemesterPaymentHistory
     * const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentSemesterPaymentHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentSemesterPaymentHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentSemesterPaymentHistoryFindUniqueOrThrowArgs} args - Arguments to find a StudentSemesterPaymentHistory
     * @example
     * // Get one StudentSemesterPaymentHistory
     * const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentSemesterPaymentHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentSemesterPaymentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentHistoryFindFirstArgs} args - Arguments to find a StudentSemesterPaymentHistory
     * @example
     * // Get one StudentSemesterPaymentHistory
     * const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentSemesterPaymentHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentSemesterPaymentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentHistoryFindFirstOrThrowArgs} args - Arguments to find a StudentSemesterPaymentHistory
     * @example
     * // Get one StudentSemesterPaymentHistory
     * const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentSemesterPaymentHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentSemesterPaymentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSemesterPaymentHistories
     * const studentSemesterPaymentHistories = await prisma.studentSemesterPaymentHistory.findMany()
     * 
     * // Get first 10 StudentSemesterPaymentHistories
     * const studentSemesterPaymentHistories = await prisma.studentSemesterPaymentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSemesterPaymentHistoryWithIdOnly = await prisma.studentSemesterPaymentHistory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentSemesterPaymentHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentSemesterPaymentHistory.
     * @param {StudentSemesterPaymentHistoryCreateArgs} args - Arguments to create a StudentSemesterPaymentHistory.
     * @example
     * // Create one StudentSemesterPaymentHistory
     * const StudentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.create({
     *   data: {
     *     // ... data to create a StudentSemesterPaymentHistory
     *   }
     * })
     * 
    **/
    create<T extends StudentSemesterPaymentHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentHistoryCreateArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentSemesterPaymentHistories.
     *     @param {StudentSemesterPaymentHistoryCreateManyArgs} args - Arguments to create many StudentSemesterPaymentHistories.
     *     @example
     *     // Create many StudentSemesterPaymentHistories
     *     const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentSemesterPaymentHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentSemesterPaymentHistory.
     * @param {StudentSemesterPaymentHistoryDeleteArgs} args - Arguments to delete one StudentSemesterPaymentHistory.
     * @example
     * // Delete one StudentSemesterPaymentHistory
     * const StudentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.delete({
     *   where: {
     *     // ... filter to delete one StudentSemesterPaymentHistory
     *   }
     * })
     * 
    **/
    delete<T extends StudentSemesterPaymentHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentHistoryDeleteArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentSemesterPaymentHistory.
     * @param {StudentSemesterPaymentHistoryUpdateArgs} args - Arguments to update one StudentSemesterPaymentHistory.
     * @example
     * // Update one StudentSemesterPaymentHistory
     * const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentSemesterPaymentHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentHistoryUpdateArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentSemesterPaymentHistories.
     * @param {StudentSemesterPaymentHistoryDeleteManyArgs} args - Arguments to filter StudentSemesterPaymentHistories to delete.
     * @example
     * // Delete a few StudentSemesterPaymentHistories
     * const { count } = await prisma.studentSemesterPaymentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentSemesterPaymentHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentSemesterPaymentHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSemesterPaymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSemesterPaymentHistories
     * const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentSemesterPaymentHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSemesterPaymentHistory.
     * @param {StudentSemesterPaymentHistoryUpsertArgs} args - Arguments to update or create a StudentSemesterPaymentHistory.
     * @example
     * // Update or create a StudentSemesterPaymentHistory
     * const studentSemesterPaymentHistory = await prisma.studentSemesterPaymentHistory.upsert({
     *   create: {
     *     // ... data to create a StudentSemesterPaymentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSemesterPaymentHistory we want to update
     *   }
     * })
    **/
    upsert<T extends StudentSemesterPaymentHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentSemesterPaymentHistoryUpsertArgs<ExtArgs>>
    ): Prisma__StudentSemesterPaymentHistoryClient<$Result.GetResult<Prisma.$StudentSemesterPaymentHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentSemesterPaymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentHistoryCountArgs} args - Arguments to filter StudentSemesterPaymentHistories to count.
     * @example
     * // Count the number of StudentSemesterPaymentHistories
     * const count = await prisma.studentSemesterPaymentHistory.count({
     *   where: {
     *     // ... the filter for the StudentSemesterPaymentHistories we want to count
     *   }
     * })
    **/
    count<T extends StudentSemesterPaymentHistoryCountArgs>(
      args?: Subset<T, StudentSemesterPaymentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSemesterPaymentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSemesterPaymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSemesterPaymentHistoryAggregateArgs>(args: Subset<T, StudentSemesterPaymentHistoryAggregateArgs>): Prisma.PrismaPromise<GetStudentSemesterPaymentHistoryAggregateType<T>>

    /**
     * Group by StudentSemesterPaymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSemesterPaymentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSemesterPaymentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSemesterPaymentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: StudentSemesterPaymentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSemesterPaymentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSemesterPaymentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSemesterPaymentHistory model
   */
  readonly fields: StudentSemesterPaymentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSemesterPaymentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSemesterPaymentHistoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    studentSemesterPayment<T extends StudentSemesterPaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentSemesterPaymentDefaultArgs<ExtArgs>>): Prisma__StudentSemesterPaymentClient<$Result.GetResult<Prisma.$StudentSemesterPaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentSemesterPaymentHistory model
   */ 
  interface StudentSemesterPaymentHistoryFieldRefs {
    readonly id: FieldRef<"StudentSemesterPaymentHistory", 'String'>
    readonly createdAt: FieldRef<"StudentSemesterPaymentHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentSemesterPaymentHistory", 'DateTime'>
    readonly studentSemesterPaymentId: FieldRef<"StudentSemesterPaymentHistory", 'String'>
    readonly transactionId: FieldRef<"StudentSemesterPaymentHistory", 'String'>
    readonly dueAmount: FieldRef<"StudentSemesterPaymentHistory", 'Int'>
    readonly paidAmount: FieldRef<"StudentSemesterPaymentHistory", 'Int'>
    readonly paymentMethod: FieldRef<"StudentSemesterPaymentHistory", 'PaymentMethod'>
    readonly isPaid: FieldRef<"StudentSemesterPaymentHistory", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * StudentSemesterPaymentHistory findUnique
   */
  export type StudentSemesterPaymentHistoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPaymentHistory to fetch.
     */
    where: StudentSemesterPaymentHistoryWhereUniqueInput
  }


  /**
   * StudentSemesterPaymentHistory findUniqueOrThrow
   */
  export type StudentSemesterPaymentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPaymentHistory to fetch.
     */
    where: StudentSemesterPaymentHistoryWhereUniqueInput
  }


  /**
   * StudentSemesterPaymentHistory findFirst
   */
  export type StudentSemesterPaymentHistoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPaymentHistory to fetch.
     */
    where?: StudentSemesterPaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPaymentHistories to fetch.
     */
    orderBy?: StudentSemesterPaymentHistoryOrderByWithRelationInput | StudentSemesterPaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPaymentHistories.
     */
    cursor?: StudentSemesterPaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPaymentHistories.
     */
    distinct?: StudentSemesterPaymentHistoryScalarFieldEnum | StudentSemesterPaymentHistoryScalarFieldEnum[]
  }


  /**
   * StudentSemesterPaymentHistory findFirstOrThrow
   */
  export type StudentSemesterPaymentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPaymentHistory to fetch.
     */
    where?: StudentSemesterPaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPaymentHistories to fetch.
     */
    orderBy?: StudentSemesterPaymentHistoryOrderByWithRelationInput | StudentSemesterPaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSemesterPaymentHistories.
     */
    cursor?: StudentSemesterPaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPaymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSemesterPaymentHistories.
     */
    distinct?: StudentSemesterPaymentHistoryScalarFieldEnum | StudentSemesterPaymentHistoryScalarFieldEnum[]
  }


  /**
   * StudentSemesterPaymentHistory findMany
   */
  export type StudentSemesterPaymentHistoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which StudentSemesterPaymentHistories to fetch.
     */
    where?: StudentSemesterPaymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSemesterPaymentHistories to fetch.
     */
    orderBy?: StudentSemesterPaymentHistoryOrderByWithRelationInput | StudentSemesterPaymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSemesterPaymentHistories.
     */
    cursor?: StudentSemesterPaymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSemesterPaymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSemesterPaymentHistories.
     */
    skip?: number
    distinct?: StudentSemesterPaymentHistoryScalarFieldEnum | StudentSemesterPaymentHistoryScalarFieldEnum[]
  }


  /**
   * StudentSemesterPaymentHistory create
   */
  export type StudentSemesterPaymentHistoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSemesterPaymentHistory.
     */
    data: XOR<StudentSemesterPaymentHistoryCreateInput, StudentSemesterPaymentHistoryUncheckedCreateInput>
  }


  /**
   * StudentSemesterPaymentHistory createMany
   */
  export type StudentSemesterPaymentHistoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSemesterPaymentHistories.
     */
    data: StudentSemesterPaymentHistoryCreateManyInput | StudentSemesterPaymentHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentSemesterPaymentHistory update
   */
  export type StudentSemesterPaymentHistoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSemesterPaymentHistory.
     */
    data: XOR<StudentSemesterPaymentHistoryUpdateInput, StudentSemesterPaymentHistoryUncheckedUpdateInput>
    /**
     * Choose, which StudentSemesterPaymentHistory to update.
     */
    where: StudentSemesterPaymentHistoryWhereUniqueInput
  }


  /**
   * StudentSemesterPaymentHistory updateMany
   */
  export type StudentSemesterPaymentHistoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSemesterPaymentHistories.
     */
    data: XOR<StudentSemesterPaymentHistoryUpdateManyMutationInput, StudentSemesterPaymentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which StudentSemesterPaymentHistories to update
     */
    where?: StudentSemesterPaymentHistoryWhereInput
  }


  /**
   * StudentSemesterPaymentHistory upsert
   */
  export type StudentSemesterPaymentHistoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSemesterPaymentHistory to update in case it exists.
     */
    where: StudentSemesterPaymentHistoryWhereUniqueInput
    /**
     * In case the StudentSemesterPaymentHistory found by the `where` argument doesn't exist, create a new StudentSemesterPaymentHistory with this data.
     */
    create: XOR<StudentSemesterPaymentHistoryCreateInput, StudentSemesterPaymentHistoryUncheckedCreateInput>
    /**
     * In case the StudentSemesterPaymentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSemesterPaymentHistoryUpdateInput, StudentSemesterPaymentHistoryUncheckedUpdateInput>
  }


  /**
   * StudentSemesterPaymentHistory delete
   */
  export type StudentSemesterPaymentHistoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
    /**
     * Filter which StudentSemesterPaymentHistory to delete.
     */
    where: StudentSemesterPaymentHistoryWhereUniqueInput
  }


  /**
   * StudentSemesterPaymentHistory deleteMany
   */
  export type StudentSemesterPaymentHistoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSemesterPaymentHistories to delete
     */
    where?: StudentSemesterPaymentHistoryWhereInput
  }


  /**
   * StudentSemesterPaymentHistory without action
   */
  export type StudentSemesterPaymentHistoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSemesterPaymentHistory
     */
    select?: StudentSemesterPaymentHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentSemesterPaymentHistoryInclude<ExtArgs> | null
  }



  /**
   * Model StudentAcademicInfo
   */

  export type AggregateStudentAcademicInfo = {
    _count: StudentAcademicInfoCountAggregateOutputType | null
    _avg: StudentAcademicInfoAvgAggregateOutputType | null
    _sum: StudentAcademicInfoSumAggregateOutputType | null
    _min: StudentAcademicInfoMinAggregateOutputType | null
    _max: StudentAcademicInfoMaxAggregateOutputType | null
  }

  export type StudentAcademicInfoAvgAggregateOutputType = {
    totalCompletedCredit: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoSumAggregateOutputType = {
    totalCompletedCredit: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    totalCompletedCredit: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    studentId: string | null
    totalCompletedCredit: number | null
    cgpa: number | null
  }

  export type StudentAcademicInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    studentId: number
    totalCompletedCredit: number
    cgpa: number
    _all: number
  }


  export type StudentAcademicInfoAvgAggregateInputType = {
    totalCompletedCredit?: true
    cgpa?: true
  }

  export type StudentAcademicInfoSumAggregateInputType = {
    totalCompletedCredit?: true
    cgpa?: true
  }

  export type StudentAcademicInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredit?: true
    cgpa?: true
  }

  export type StudentAcademicInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredit?: true
    cgpa?: true
  }

  export type StudentAcademicInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    studentId?: true
    totalCompletedCredit?: true
    cgpa?: true
    _all?: true
  }

  export type StudentAcademicInfoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicInfo to aggregate.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAcademicInfos
    **/
    _count?: true | StudentAcademicInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAcademicInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentAcademicInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAcademicInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAcademicInfoMaxAggregateInputType
  }

  export type GetStudentAcademicInfoAggregateType<T extends StudentAcademicInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAcademicInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAcademicInfo[P]>
      : GetScalarType<T[P], AggregateStudentAcademicInfo[P]>
  }




  export type StudentAcademicInfoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: StudentAcademicInfoWhereInput
    orderBy?: StudentAcademicInfoOrderByWithAggregationInput | StudentAcademicInfoOrderByWithAggregationInput[]
    by: StudentAcademicInfoScalarFieldEnum[] | StudentAcademicInfoScalarFieldEnum
    having?: StudentAcademicInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAcademicInfoCountAggregateInputType | true
    _avg?: StudentAcademicInfoAvgAggregateInputType
    _sum?: StudentAcademicInfoSumAggregateInputType
    _min?: StudentAcademicInfoMinAggregateInputType
    _max?: StudentAcademicInfoMaxAggregateInputType
  }

  export type StudentAcademicInfoGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    studentId: string
    totalCompletedCredit: number | null
    cgpa: number | null
    _count: StudentAcademicInfoCountAggregateOutputType | null
    _avg: StudentAcademicInfoAvgAggregateOutputType | null
    _sum: StudentAcademicInfoSumAggregateOutputType | null
    _min: StudentAcademicInfoMinAggregateOutputType | null
    _max: StudentAcademicInfoMaxAggregateOutputType | null
  }

  type GetStudentAcademicInfoGroupByPayload<T extends StudentAcademicInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAcademicInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAcademicInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAcademicInfoGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAcademicInfoGroupByOutputType[P]>
        }
      >
    >


  export type StudentAcademicInfoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    totalCompletedCredit?: boolean
    cgpa?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAcademicInfo"]>

  export type StudentAcademicInfoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentId?: boolean
    totalCompletedCredit?: boolean
    cgpa?: boolean
  }

  export type StudentAcademicInfoInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }


  export type $StudentAcademicInfoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "StudentAcademicInfo"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      studentId: string
      totalCompletedCredit: number | null
      cgpa: number | null
    }, ExtArgs["result"]["studentAcademicInfo"]>
    composites: {}
  }


  type StudentAcademicInfoGetPayload<S extends boolean | null | undefined | StudentAcademicInfoDefaultArgs> = $Result.GetResult<Prisma.$StudentAcademicInfoPayload, S>

  type StudentAcademicInfoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<StudentAcademicInfoFindManyArgs, 'select' | 'include'> & {
      select?: StudentAcademicInfoCountAggregateInputType | true
    }

  export interface StudentAcademicInfoDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAcademicInfo'], meta: { name: 'StudentAcademicInfo' } }
    /**
     * Find zero or one StudentAcademicInfo that matches the filter.
     * @param {StudentAcademicInfoFindUniqueArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentAcademicInfoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentAcademicInfoFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentAcademicInfo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentAcademicInfoFindUniqueOrThrowArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentAcademicInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindFirstArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentAcademicInfoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentAcademicInfoFindFirstArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentAcademicInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindFirstOrThrowArgs} args - Arguments to find a StudentAcademicInfo
     * @example
     * // Get one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentAcademicInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAcademicInfos
     * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany()
     * 
     * // Get first 10 StudentAcademicInfos
     * const studentAcademicInfos = await prisma.studentAcademicInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAcademicInfoWithIdOnly = await prisma.studentAcademicInfo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StudentAcademicInfoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentAcademicInfoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentAcademicInfo.
     * @param {StudentAcademicInfoCreateArgs} args - Arguments to create a StudentAcademicInfo.
     * @example
     * // Create one StudentAcademicInfo
     * const StudentAcademicInfo = await prisma.studentAcademicInfo.create({
     *   data: {
     *     // ... data to create a StudentAcademicInfo
     *   }
     * })
     * 
    **/
    create<T extends StudentAcademicInfoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentAcademicInfoCreateArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentAcademicInfos.
     *     @param {StudentAcademicInfoCreateManyArgs} args - Arguments to create many StudentAcademicInfos.
     *     @example
     *     // Create many StudentAcademicInfos
     *     const studentAcademicInfo = await prisma.studentAcademicInfo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentAcademicInfoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentAcademicInfoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentAcademicInfo.
     * @param {StudentAcademicInfoDeleteArgs} args - Arguments to delete one StudentAcademicInfo.
     * @example
     * // Delete one StudentAcademicInfo
     * const StudentAcademicInfo = await prisma.studentAcademicInfo.delete({
     *   where: {
     *     // ... filter to delete one StudentAcademicInfo
     *   }
     * })
     * 
    **/
    delete<T extends StudentAcademicInfoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentAcademicInfoDeleteArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentAcademicInfo.
     * @param {StudentAcademicInfoUpdateArgs} args - Arguments to update one StudentAcademicInfo.
     * @example
     * // Update one StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentAcademicInfoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentAcademicInfoUpdateArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentAcademicInfos.
     * @param {StudentAcademicInfoDeleteManyArgs} args - Arguments to filter StudentAcademicInfos to delete.
     * @example
     * // Delete a few StudentAcademicInfos
     * const { count } = await prisma.studentAcademicInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentAcademicInfoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentAcademicInfoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAcademicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAcademicInfos
     * const studentAcademicInfo = await prisma.studentAcademicInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentAcademicInfoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentAcademicInfoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAcademicInfo.
     * @param {StudentAcademicInfoUpsertArgs} args - Arguments to update or create a StudentAcademicInfo.
     * @example
     * // Update or create a StudentAcademicInfo
     * const studentAcademicInfo = await prisma.studentAcademicInfo.upsert({
     *   create: {
     *     // ... data to create a StudentAcademicInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAcademicInfo we want to update
     *   }
     * })
    **/
    upsert<T extends StudentAcademicInfoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentAcademicInfoUpsertArgs<ExtArgs>>
    ): Prisma__StudentAcademicInfoClient<$Result.GetResult<Prisma.$StudentAcademicInfoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentAcademicInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoCountArgs} args - Arguments to filter StudentAcademicInfos to count.
     * @example
     * // Count the number of StudentAcademicInfos
     * const count = await prisma.studentAcademicInfo.count({
     *   where: {
     *     // ... the filter for the StudentAcademicInfos we want to count
     *   }
     * })
    **/
    count<T extends StudentAcademicInfoCountArgs>(
      args?: Subset<T, StudentAcademicInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAcademicInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAcademicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAcademicInfoAggregateArgs>(args: Subset<T, StudentAcademicInfoAggregateArgs>): Prisma.PrismaPromise<GetStudentAcademicInfoAggregateType<T>>

    /**
     * Group by StudentAcademicInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAcademicInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAcademicInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAcademicInfoGroupByArgs['orderBy'] }
        : { orderBy?: StudentAcademicInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAcademicInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAcademicInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAcademicInfo model
   */
  readonly fields: StudentAcademicInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAcademicInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAcademicInfoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentAcademicInfo model
   */ 
  interface StudentAcademicInfoFieldRefs {
    readonly id: FieldRef<"StudentAcademicInfo", 'String'>
    readonly createdAt: FieldRef<"StudentAcademicInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentAcademicInfo", 'DateTime'>
    readonly studentId: FieldRef<"StudentAcademicInfo", 'String'>
    readonly totalCompletedCredit: FieldRef<"StudentAcademicInfo", 'Int'>
    readonly cgpa: FieldRef<"StudentAcademicInfo", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * StudentAcademicInfo findUnique
   */
  export type StudentAcademicInfoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }


  /**
   * StudentAcademicInfo findUniqueOrThrow
   */
  export type StudentAcademicInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }


  /**
   * StudentAcademicInfo findFirst
   */
  export type StudentAcademicInfoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicInfos.
     */
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }


  /**
   * StudentAcademicInfo findFirstOrThrow
   */
  export type StudentAcademicInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfo to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAcademicInfos.
     */
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }


  /**
   * StudentAcademicInfo findMany
   */
  export type StudentAcademicInfoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter, which StudentAcademicInfos to fetch.
     */
    where?: StudentAcademicInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAcademicInfos to fetch.
     */
    orderBy?: StudentAcademicInfoOrderByWithRelationInput | StudentAcademicInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAcademicInfos.
     */
    cursor?: StudentAcademicInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAcademicInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAcademicInfos.
     */
    skip?: number
    distinct?: StudentAcademicInfoScalarFieldEnum | StudentAcademicInfoScalarFieldEnum[]
  }


  /**
   * StudentAcademicInfo create
   */
  export type StudentAcademicInfoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAcademicInfo.
     */
    data: XOR<StudentAcademicInfoCreateInput, StudentAcademicInfoUncheckedCreateInput>
  }


  /**
   * StudentAcademicInfo createMany
   */
  export type StudentAcademicInfoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAcademicInfos.
     */
    data: StudentAcademicInfoCreateManyInput | StudentAcademicInfoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * StudentAcademicInfo update
   */
  export type StudentAcademicInfoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAcademicInfo.
     */
    data: XOR<StudentAcademicInfoUpdateInput, StudentAcademicInfoUncheckedUpdateInput>
    /**
     * Choose, which StudentAcademicInfo to update.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }


  /**
   * StudentAcademicInfo updateMany
   */
  export type StudentAcademicInfoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAcademicInfos.
     */
    data: XOR<StudentAcademicInfoUpdateManyMutationInput, StudentAcademicInfoUncheckedUpdateManyInput>
    /**
     * Filter which StudentAcademicInfos to update
     */
    where?: StudentAcademicInfoWhereInput
  }


  /**
   * StudentAcademicInfo upsert
   */
  export type StudentAcademicInfoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAcademicInfo to update in case it exists.
     */
    where: StudentAcademicInfoWhereUniqueInput
    /**
     * In case the StudentAcademicInfo found by the `where` argument doesn't exist, create a new StudentAcademicInfo with this data.
     */
    create: XOR<StudentAcademicInfoCreateInput, StudentAcademicInfoUncheckedCreateInput>
    /**
     * In case the StudentAcademicInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAcademicInfoUpdateInput, StudentAcademicInfoUncheckedUpdateInput>
  }


  /**
   * StudentAcademicInfo delete
   */
  export type StudentAcademicInfoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
    /**
     * Filter which StudentAcademicInfo to delete.
     */
    where: StudentAcademicInfoWhereUniqueInput
  }


  /**
   * StudentAcademicInfo deleteMany
   */
  export type StudentAcademicInfoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAcademicInfos to delete
     */
    where?: StudentAcademicInfoWhereInput
  }


  /**
   * StudentAcademicInfo without action
   */
  export type StudentAcademicInfoDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAcademicInfo
     */
    select?: StudentAcademicInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentAcademicInfoInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AcademicSemesterScalarFieldEnum: {
    id: 'id',
    year: 'year',
    title: 'title',
    code: 'code',
    startMonth: 'startMonth',
    endMonth: 'endMonth',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicSemesterScalarFieldEnum = (typeof AcademicSemesterScalarFieldEnum)[keyof typeof AcademicSemesterScalarFieldEnum]


  export const AcademicFacultyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicFacultyScalarFieldEnum = (typeof AcademicFacultyScalarFieldEnum)[keyof typeof AcademicFacultyScalarFieldEnum]


  export const AcademicDepartmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicFacultyId: 'academicFacultyId'
  };

  export type AcademicDepartmentScalarFieldEnum = (typeof AcademicDepartmentScalarFieldEnum)[keyof typeof AcademicDepartmentScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    bloodGroup: 'bloodGroup',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicSemesterId: 'academicSemesterId',
    academicDepartmentId: 'academicDepartmentId',
    academicFacultyId: 'academicFacultyId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    facultyId: 'facultyId',
    firstName: 'firstName',
    lastName: 'lastName',
    middleName: 'middleName',
    profileImage: 'profileImage',
    email: 'email',
    contactNo: 'contactNo',
    gender: 'gender',
    bloodGroup: 'bloodGroup',
    designation: 'designation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicDepartmentId: 'academicDepartmentId',
    academicFacultyId: 'academicFacultyId'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const BuildingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    roomNumber: 'roomNumber',
    floor: 'floor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    buildingId: 'buildingId'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    code: 'code',
    credits: 'credits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseToPrerequisiteScalarFieldEnum: {
    courseId: 'courseId',
    preRequisiteId: 'preRequisiteId'
  };

  export type CourseToPrerequisiteScalarFieldEnum = (typeof CourseToPrerequisiteScalarFieldEnum)[keyof typeof CourseToPrerequisiteScalarFieldEnum]


  export const CourseFacultyScalarFieldEnum: {
    courseId: 'courseId',
    facultyId: 'facultyId'
  };

  export type CourseFacultyScalarFieldEnum = (typeof CourseFacultyScalarFieldEnum)[keyof typeof CourseFacultyScalarFieldEnum]


  export const SemesterRegistrationScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    minCredit: 'minCredit',
    maxCredit: 'maxCredit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academicSemesterId: 'academicSemesterId'
  };

  export type SemesterRegistrationScalarFieldEnum = (typeof SemesterRegistrationScalarFieldEnum)[keyof typeof SemesterRegistrationScalarFieldEnum]


  export const OfferedCourseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    courseId: 'courseId',
    academicDepartmentId: 'academicDepartmentId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type OfferedCourseScalarFieldEnum = (typeof OfferedCourseScalarFieldEnum)[keyof typeof OfferedCourseScalarFieldEnum]


  export const OfferedCourseSectionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    maxCapacity: 'maxCapacity',
    currentlyEnrolledStudent: 'currentlyEnrolledStudent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    offeredCourseId: 'offeredCourseId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type OfferedCourseSectionScalarFieldEnum = (typeof OfferedCourseSectionScalarFieldEnum)[keyof typeof OfferedCourseSectionScalarFieldEnum]


  export const OfferedCourseClassScheduleScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    dayOfWeek: 'dayOfWeek',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    offeredCourseSectionId: 'offeredCourseSectionId',
    semesterRegistrationId: 'semesterRegistrationId',
    roomId: 'roomId',
    facultyId: 'facultyId'
  };

  export type OfferedCourseClassScheduleScalarFieldEnum = (typeof OfferedCourseClassScheduleScalarFieldEnum)[keyof typeof OfferedCourseClassScheduleScalarFieldEnum]


  export const StudentSemesterRegistrationScalarFieldEnum: {
    id: 'id',
    isConfirmed: 'isConfirmed',
    totalCreditsTaken: 'totalCreditsTaken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    semesterRegistrationId: 'semesterRegistrationId'
  };

  export type StudentSemesterRegistrationScalarFieldEnum = (typeof StudentSemesterRegistrationScalarFieldEnum)[keyof typeof StudentSemesterRegistrationScalarFieldEnum]


  export const StudentSemesterRegistrationCourseScalarFieldEnum: {
    semesterRegistrationId: 'semesterRegistrationId',
    studentId: 'studentId',
    offeredCourseId: 'offeredCourseId',
    offeredCourseSectionId: 'offeredCourseSectionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentSemesterRegistrationCourseScalarFieldEnum = (typeof StudentSemesterRegistrationCourseScalarFieldEnum)[keyof typeof StudentSemesterRegistrationCourseScalarFieldEnum]


  export const StudentEnrolledCourseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    courseId: 'courseId',
    academicSemesterId: 'academicSemesterId',
    grade: 'grade',
    point: 'point',
    totalMarks: 'totalMarks',
    status: 'status'
  };

  export type StudentEnrolledCourseScalarFieldEnum = (typeof StudentEnrolledCourseScalarFieldEnum)[keyof typeof StudentEnrolledCourseScalarFieldEnum]


  export const StudentEnrolledCourseMarkScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    studentEnrolledCourseId: 'studentEnrolledCourseId',
    academicSemesterId: 'academicSemesterId',
    grade: 'grade',
    marks: 'marks',
    examType: 'examType'
  };

  export type StudentEnrolledCourseMarkScalarFieldEnum = (typeof StudentEnrolledCourseMarkScalarFieldEnum)[keyof typeof StudentEnrolledCourseMarkScalarFieldEnum]


  export const StudentSemesterPaymentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    academicSemesterId: 'academicSemesterId',
    fullPaymentAmount: 'fullPaymentAmount',
    partialPaymentAmount: 'partialPaymentAmount',
    totalDueAmount: 'totalDueAmount',
    totalPaidAmount: 'totalPaidAmount',
    paymentStatus: 'paymentStatus'
  };

  export type StudentSemesterPaymentScalarFieldEnum = (typeof StudentSemesterPaymentScalarFieldEnum)[keyof typeof StudentSemesterPaymentScalarFieldEnum]


  export const StudentSemesterPaymentHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentSemesterPaymentId: 'studentSemesterPaymentId',
    transactionId: 'transactionId',
    dueAmount: 'dueAmount',
    paidAmount: 'paidAmount',
    paymentMethod: 'paymentMethod',
    isPaid: 'isPaid'
  };

  export type StudentSemesterPaymentHistoryScalarFieldEnum = (typeof StudentSemesterPaymentHistoryScalarFieldEnum)[keyof typeof StudentSemesterPaymentHistoryScalarFieldEnum]


  export const StudentAcademicInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    studentId: 'studentId',
    totalCompletedCredit: 'totalCompletedCredit',
    cgpa: 'cgpa'
  };

  export type StudentAcademicInfoScalarFieldEnum = (typeof StudentAcademicInfoScalarFieldEnum)[keyof typeof StudentAcademicInfoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SemesterRegistrationStatus'
   */
  export type EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SemesterRegistrationStatus'>
    


  /**
   * Reference to a field of type 'SemesterRegistrationStatus[]'
   */
  export type ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SemesterRegistrationStatus[]'>
    


  /**
   * Reference to a field of type 'WeekDays'
   */
  export type EnumWeekDaysFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDays'>
    


  /**
   * Reference to a field of type 'WeekDays[]'
   */
  export type ListEnumWeekDaysFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WeekDays[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StudentEnrolledCourseStatus'
   */
  export type EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentEnrolledCourseStatus'>
    


  /**
   * Reference to a field of type 'StudentEnrolledCourseStatus[]'
   */
  export type ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentEnrolledCourseStatus[]'>
    


  /**
   * Reference to a field of type 'ExamType'
   */
  export type EnumExamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamType'>
    


  /**
   * Reference to a field of type 'ExamType[]'
   */
  export type ListEnumExamTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    
  /**
   * Deep Input Types
   */


  export type AcademicSemesterWhereInput = {
    AND?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    OR?: AcademicSemesterWhereInput[]
    NOT?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    id?: StringFilter<"AcademicSemester"> | string
    year?: IntFilter<"AcademicSemester"> | number
    title?: StringFilter<"AcademicSemester"> | string
    code?: StringFilter<"AcademicSemester"> | string
    startMonth?: StringFilter<"AcademicSemester"> | string
    endMonth?: StringFilter<"AcademicSemester"> | string
    isCurrent?: BoolNullableFilter<"AcademicSemester"> | boolean | null
    createdAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    students?: StudentListRelationFilter
    semesterRegistrations?: SemesterRegistrationListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
  }

  export type AcademicSemesterOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    students?: StudentOrderByRelationAggregateInput
    semesterRegistrations?: SemesterRegistrationOrderByRelationAggregateInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    studentSemesterPayments?: StudentSemesterPaymentOrderByRelationAggregateInput
  }

  export type AcademicSemesterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    OR?: AcademicSemesterWhereInput[]
    NOT?: AcademicSemesterWhereInput | AcademicSemesterWhereInput[]
    year?: IntFilter<"AcademicSemester"> | number
    title?: StringFilter<"AcademicSemester"> | string
    code?: StringFilter<"AcademicSemester"> | string
    startMonth?: StringFilter<"AcademicSemester"> | string
    endMonth?: StringFilter<"AcademicSemester"> | string
    isCurrent?: BoolNullableFilter<"AcademicSemester"> | boolean | null
    createdAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSemester"> | Date | string
    students?: StudentListRelationFilter
    semesterRegistrations?: SemesterRegistrationListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
  }, "id">

  export type AcademicSemesterOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicSemesterCountOrderByAggregateInput
    _avg?: AcademicSemesterAvgOrderByAggregateInput
    _max?: AcademicSemesterMaxOrderByAggregateInput
    _min?: AcademicSemesterMinOrderByAggregateInput
    _sum?: AcademicSemesterSumOrderByAggregateInput
  }

  export type AcademicSemesterScalarWhereWithAggregatesInput = {
    AND?: AcademicSemesterScalarWhereWithAggregatesInput | AcademicSemesterScalarWhereWithAggregatesInput[]
    OR?: AcademicSemesterScalarWhereWithAggregatesInput[]
    NOT?: AcademicSemesterScalarWhereWithAggregatesInput | AcademicSemesterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicSemester"> | string
    year?: IntWithAggregatesFilter<"AcademicSemester"> | number
    title?: StringWithAggregatesFilter<"AcademicSemester"> | string
    code?: StringWithAggregatesFilter<"AcademicSemester"> | string
    startMonth?: StringWithAggregatesFilter<"AcademicSemester"> | string
    endMonth?: StringWithAggregatesFilter<"AcademicSemester"> | string
    isCurrent?: BoolNullableWithAggregatesFilter<"AcademicSemester"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"AcademicSemester"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicSemester"> | Date | string
  }

  export type AcademicFacultyWhereInput = {
    AND?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    OR?: AcademicFacultyWhereInput[]
    NOT?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    id?: StringFilter<"AcademicFaculty"> | string
    title?: StringFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    academicDepartments?: AcademicDepartmentListRelationFilter
    students?: StudentListRelationFilter
    faculties?: FacultyListRelationFilter
  }

  export type AcademicFacultyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartments?: AcademicDepartmentOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    faculties?: FacultyOrderByRelationAggregateInput
  }

  export type AcademicFacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    OR?: AcademicFacultyWhereInput[]
    NOT?: AcademicFacultyWhereInput | AcademicFacultyWhereInput[]
    title?: StringFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicFaculty"> | Date | string
    academicDepartments?: AcademicDepartmentListRelationFilter
    students?: StudentListRelationFilter
    faculties?: FacultyListRelationFilter
  }, "id">

  export type AcademicFacultyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicFacultyCountOrderByAggregateInput
    _max?: AcademicFacultyMaxOrderByAggregateInput
    _min?: AcademicFacultyMinOrderByAggregateInput
  }

  export type AcademicFacultyScalarWhereWithAggregatesInput = {
    AND?: AcademicFacultyScalarWhereWithAggregatesInput | AcademicFacultyScalarWhereWithAggregatesInput[]
    OR?: AcademicFacultyScalarWhereWithAggregatesInput[]
    NOT?: AcademicFacultyScalarWhereWithAggregatesInput | AcademicFacultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicFaculty"> | string
    title?: StringWithAggregatesFilter<"AcademicFaculty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicFaculty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicFaculty"> | Date | string
  }

  export type AcademicDepartmentWhereInput = {
    AND?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    OR?: AcademicDepartmentWhereInput[]
    NOT?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    id?: StringFilter<"AcademicDepartment"> | string
    title?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
    academicFaculty?: XOR<AcademicFacultyRelationFilter, AcademicFacultyWhereInput>
    students?: StudentListRelationFilter
    faculties?: FacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }

  export type AcademicDepartmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFacultyId?: SortOrder
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    faculties?: FacultyOrderByRelationAggregateInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
  }

  export type AcademicDepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    OR?: AcademicDepartmentWhereInput[]
    NOT?: AcademicDepartmentWhereInput | AcademicDepartmentWhereInput[]
    title?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
    academicFaculty?: XOR<AcademicFacultyRelationFilter, AcademicFacultyWhereInput>
    students?: StudentListRelationFilter
    faculties?: FacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
  }, "id">

  export type AcademicDepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFacultyId?: SortOrder
    _count?: AcademicDepartmentCountOrderByAggregateInput
    _max?: AcademicDepartmentMaxOrderByAggregateInput
    _min?: AcademicDepartmentMinOrderByAggregateInput
  }

  export type AcademicDepartmentScalarWhereWithAggregatesInput = {
    AND?: AcademicDepartmentScalarWhereWithAggregatesInput | AcademicDepartmentScalarWhereWithAggregatesInput[]
    OR?: AcademicDepartmentScalarWhereWithAggregatesInput[]
    NOT?: AcademicDepartmentScalarWhereWithAggregatesInput | AcademicDepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    title?: StringWithAggregatesFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicDepartment"> | Date | string
    academicFacultyId?: StringWithAggregatesFilter<"AcademicDepartment"> | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringFilter<"Student"> | string
    contactNo?: StringFilter<"Student"> | string
    gender?: StringFilter<"Student"> | string
    bloodGroup?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    academicSemesterId?: StringFilter<"Student"> | string
    academicDepartmentId?: StringFilter<"Student"> | string
    academicFacultyId?: StringFilter<"Student"> | string
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    academicDepartment?: XOR<AcademicDepartmentRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyRelationFilter, AcademicFacultyWhereInput>
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    studentAcademicInfos?: StudentAcademicInfoListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
    studentSemesterPayments?: StudentSemesterPaymentOrderByRelationAggregateInput
    studentAcademicInfos?: StudentAcademicInfoOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    studentId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringFilter<"Student"> | string
    contactNo?: StringFilter<"Student"> | string
    gender?: StringFilter<"Student"> | string
    bloodGroup?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    academicSemesterId?: StringFilter<"Student"> | string
    academicDepartmentId?: StringFilter<"Student"> | string
    academicFacultyId?: StringFilter<"Student"> | string
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    academicDepartment?: XOR<AcademicDepartmentRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyRelationFilter, AcademicFacultyWhereInput>
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
    studentSemesterPayments?: StudentSemesterPaymentListRelationFilter
    studentAcademicInfos?: StudentAcademicInfoListRelationFilter
  }, "id">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    studentId?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    middleName?: StringWithAggregatesFilter<"Student"> | string
    profileImage?: StringNullableWithAggregatesFilter<"Student"> | string | null
    email?: StringWithAggregatesFilter<"Student"> | string
    contactNo?: StringWithAggregatesFilter<"Student"> | string
    gender?: StringWithAggregatesFilter<"Student"> | string
    bloodGroup?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    academicSemesterId?: StringWithAggregatesFilter<"Student"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"Student"> | string
    academicFacultyId?: StringWithAggregatesFilter<"Student"> | string
  }

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    id?: StringFilter<"Faculty"> | string
    facultyId?: StringFilter<"Faculty"> | string
    firstName?: StringFilter<"Faculty"> | string
    lastName?: StringFilter<"Faculty"> | string
    middleName?: StringFilter<"Faculty"> | string
    profileImage?: StringFilter<"Faculty"> | string
    email?: StringFilter<"Faculty"> | string
    contactNo?: StringFilter<"Faculty"> | string
    gender?: StringFilter<"Faculty"> | string
    bloodGroup?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    academicDepartmentId?: StringFilter<"Faculty"> | string
    academicFacultyId?: StringFilter<"Faculty"> | string
    academicDepartment?: XOR<AcademicDepartmentRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyRelationFilter, AcademicFacultyWhereInput>
    courses?: CourseFacultyListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    academicFaculty?: AcademicFacultyOrderByWithRelationInput
    courses?: CourseFacultyOrderByRelationAggregateInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
  }

  export type FacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    facultyId?: StringFilter<"Faculty"> | string
    firstName?: StringFilter<"Faculty"> | string
    lastName?: StringFilter<"Faculty"> | string
    middleName?: StringFilter<"Faculty"> | string
    profileImage?: StringFilter<"Faculty"> | string
    email?: StringFilter<"Faculty"> | string
    contactNo?: StringFilter<"Faculty"> | string
    gender?: StringFilter<"Faculty"> | string
    bloodGroup?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    academicDepartmentId?: StringFilter<"Faculty"> | string
    academicFacultyId?: StringFilter<"Faculty"> | string
    academicDepartment?: XOR<AcademicDepartmentRelationFilter, AcademicDepartmentWhereInput>
    academicFaculty?: XOR<AcademicFacultyRelationFilter, AcademicFacultyWhereInput>
    courses?: CourseFacultyListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }, "id">

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    OR?: FacultyScalarWhereWithAggregatesInput[]
    NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Faculty"> | string
    facultyId?: StringWithAggregatesFilter<"Faculty"> | string
    firstName?: StringWithAggregatesFilter<"Faculty"> | string
    lastName?: StringWithAggregatesFilter<"Faculty"> | string
    middleName?: StringWithAggregatesFilter<"Faculty"> | string
    profileImage?: StringWithAggregatesFilter<"Faculty"> | string
    email?: StringWithAggregatesFilter<"Faculty"> | string
    contactNo?: StringWithAggregatesFilter<"Faculty"> | string
    gender?: StringWithAggregatesFilter<"Faculty"> | string
    bloodGroup?: StringWithAggregatesFilter<"Faculty"> | string
    designation?: StringWithAggregatesFilter<"Faculty"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
    academicDepartmentId?: StringWithAggregatesFilter<"Faculty"> | string
    academicFacultyId?: StringWithAggregatesFilter<"Faculty"> | string
  }

  export type BuildingWhereInput = {
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    id?: StringFilter<"Building"> | string
    title?: StringFilter<"Building"> | string
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    rooms?: RoomListRelationFilter
  }

  export type BuildingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rooms?: RoomOrderByRelationAggregateInput
  }

  export type BuildingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    title?: StringFilter<"Building"> | string
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    rooms?: RoomListRelationFilter
  }, "id">

  export type BuildingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuildingCountOrderByAggregateInput
    _max?: BuildingMaxOrderByAggregateInput
    _min?: BuildingMinOrderByAggregateInput
  }

  export type BuildingScalarWhereWithAggregatesInput = {
    AND?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    OR?: BuildingScalarWhereWithAggregatesInput[]
    NOT?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Building"> | string
    title?: StringWithAggregatesFilter<"Building"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    buildingId?: StringFilter<"Room"> | string
    building?: XOR<BuildingRelationFilter, BuildingWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buildingId?: SortOrder
    building?: BuildingOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    buildingId?: StringFilter<"Room"> | string
    building?: XOR<BuildingRelationFilter, BuildingWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buildingId?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    roomNumber?: StringWithAggregatesFilter<"Room"> | string
    floor?: StringWithAggregatesFilter<"Room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    buildingId?: StringWithAggregatesFilter<"Room"> | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    preRequisite?: CourseToPrerequisiteListRelationFilter
    preRequisiteFor?: CourseToPrerequisiteListRelationFilter
    faculties?: CourseFacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    preRequisite?: CourseToPrerequisiteOrderByRelationAggregateInput
    preRequisiteFor?: CourseToPrerequisiteOrderByRelationAggregateInput
    faculties?: CourseFacultyOrderByRelationAggregateInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    studentEnrolledCourses?: StudentEnrolledCourseOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    code?: StringFilter<"Course"> | string
    credits?: IntFilter<"Course"> | number
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    preRequisite?: CourseToPrerequisiteListRelationFilter
    preRequisiteFor?: CourseToPrerequisiteListRelationFilter
    faculties?: CourseFacultyListRelationFilter
    offeredCourses?: OfferedCourseListRelationFilter
    studentEnrolledCourses?: StudentEnrolledCourseListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    code?: StringWithAggregatesFilter<"Course"> | string
    credits?: IntWithAggregatesFilter<"Course"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseToPrerequisiteWhereInput = {
    AND?: CourseToPrerequisiteWhereInput | CourseToPrerequisiteWhereInput[]
    OR?: CourseToPrerequisiteWhereInput[]
    NOT?: CourseToPrerequisiteWhereInput | CourseToPrerequisiteWhereInput[]
    courseId?: StringFilter<"CourseToPrerequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPrerequisite"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    preRequisite?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CourseToPrerequisiteOrderByWithRelationInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
    course?: CourseOrderByWithRelationInput
    preRequisite?: CourseOrderByWithRelationInput
  }

  export type CourseToPrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    courseId_preRequisiteId?: CourseToPrerequisiteCourseIdPreRequisiteIdCompoundUniqueInput
    AND?: CourseToPrerequisiteWhereInput | CourseToPrerequisiteWhereInput[]
    OR?: CourseToPrerequisiteWhereInput[]
    NOT?: CourseToPrerequisiteWhereInput | CourseToPrerequisiteWhereInput[]
    courseId?: StringFilter<"CourseToPrerequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPrerequisite"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    preRequisite?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "courseId_preRequisiteId">

  export type CourseToPrerequisiteOrderByWithAggregationInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
    _count?: CourseToPrerequisiteCountOrderByAggregateInput
    _max?: CourseToPrerequisiteMaxOrderByAggregateInput
    _min?: CourseToPrerequisiteMinOrderByAggregateInput
  }

  export type CourseToPrerequisiteScalarWhereWithAggregatesInput = {
    AND?: CourseToPrerequisiteScalarWhereWithAggregatesInput | CourseToPrerequisiteScalarWhereWithAggregatesInput[]
    OR?: CourseToPrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: CourseToPrerequisiteScalarWhereWithAggregatesInput | CourseToPrerequisiteScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseToPrerequisite"> | string
    preRequisiteId?: StringWithAggregatesFilter<"CourseToPrerequisite"> | string
  }

  export type CourseFacultyWhereInput = {
    AND?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    OR?: CourseFacultyWhereInput[]
    NOT?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
  }

  export type CourseFacultyOrderByWithRelationInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
    course?: CourseOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
  }

  export type CourseFacultyWhereUniqueInput = Prisma.AtLeast<{
    courseId_facultyId?: CourseFacultyCourseIdFacultyIdCompoundUniqueInput
    AND?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    OR?: CourseFacultyWhereInput[]
    NOT?: CourseFacultyWhereInput | CourseFacultyWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
  }, "courseId_facultyId">

  export type CourseFacultyOrderByWithAggregationInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
    _count?: CourseFacultyCountOrderByAggregateInput
    _max?: CourseFacultyMaxOrderByAggregateInput
    _min?: CourseFacultyMinOrderByAggregateInput
  }

  export type CourseFacultyScalarWhereWithAggregatesInput = {
    AND?: CourseFacultyScalarWhereWithAggregatesInput | CourseFacultyScalarWhereWithAggregatesInput[]
    OR?: CourseFacultyScalarWhereWithAggregatesInput[]
    NOT?: CourseFacultyScalarWhereWithAggregatesInput | CourseFacultyScalarWhereWithAggregatesInput[]
    courseId?: StringWithAggregatesFilter<"CourseFaculty"> | string
    facultyId?: StringWithAggregatesFilter<"CourseFaculty"> | string
  }

  export type SemesterRegistrationWhereInput = {
    AND?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    OR?: SemesterRegistrationWhereInput[]
    NOT?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    id?: StringFilter<"SemesterRegistration"> | string
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFilter<"SemesterRegistration"> | number
    maxCredit?: IntFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    offeredCourses?: OfferedCourseListRelationFilter
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type SemesterRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrderInput | SortOrder
    minCredit?: SortOrder
    maxCredit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    offeredCourses?: OfferedCourseOrderByRelationAggregateInput
    offeredCourseSections?: OfferedCourseSectionOrderByRelationAggregateInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    studentSemesterRegistrations?: StudentSemesterRegistrationOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
  }

  export type SemesterRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    OR?: SemesterRegistrationWhereInput[]
    NOT?: SemesterRegistrationWhereInput | SemesterRegistrationWhereInput[]
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFilter<"SemesterRegistration"> | number
    maxCredit?: IntFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    offeredCourses?: OfferedCourseListRelationFilter
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrations?: StudentSemesterRegistrationListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type SemesterRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrderInput | SortOrder
    minCredit?: SortOrder
    maxCredit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
    _count?: SemesterRegistrationCountOrderByAggregateInput
    _avg?: SemesterRegistrationAvgOrderByAggregateInput
    _max?: SemesterRegistrationMaxOrderByAggregateInput
    _min?: SemesterRegistrationMinOrderByAggregateInput
    _sum?: SemesterRegistrationSumOrderByAggregateInput
  }

  export type SemesterRegistrationScalarWhereWithAggregatesInput = {
    AND?: SemesterRegistrationScalarWhereWithAggregatesInput | SemesterRegistrationScalarWhereWithAggregatesInput[]
    OR?: SemesterRegistrationScalarWhereWithAggregatesInput[]
    NOT?: SemesterRegistrationScalarWhereWithAggregatesInput | SemesterRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SemesterRegistration"> | string
    startDate?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableWithAggregatesFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntWithAggregatesFilter<"SemesterRegistration"> | number
    maxCredit?: IntWithAggregatesFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringWithAggregatesFilter<"SemesterRegistration"> | string
  }

  export type OfferedCourseWhereInput = {
    AND?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    OR?: OfferedCourseWhereInput[]
    NOT?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    id?: StringFilter<"OfferedCourse"> | string
    createdAt?: DateTimeFilter<"OfferedCourse"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourse"> | Date | string
    courseId?: StringFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    academicDepartment?: XOR<AcademicDepartmentRelationFilter, AcademicDepartmentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type OfferedCourseOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    academicDepartmentId?: SortOrder
    semesterRegistrationId?: SortOrder
    course?: CourseOrderByWithRelationInput
    academicDepartment?: AcademicDepartmentOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    offeredCourseSections?: OfferedCourseSectionOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
  }

  export type OfferedCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    OR?: OfferedCourseWhereInput[]
    NOT?: OfferedCourseWhereInput | OfferedCourseWhereInput[]
    createdAt?: DateTimeFilter<"OfferedCourse"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourse"> | Date | string
    courseId?: StringFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    academicDepartment?: XOR<AcademicDepartmentRelationFilter, AcademicDepartmentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    offeredCourseSections?: OfferedCourseSectionListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type OfferedCourseOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    academicDepartmentId?: SortOrder
    semesterRegistrationId?: SortOrder
    _count?: OfferedCourseCountOrderByAggregateInput
    _max?: OfferedCourseMaxOrderByAggregateInput
    _min?: OfferedCourseMinOrderByAggregateInput
  }

  export type OfferedCourseScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseScalarWhereWithAggregatesInput | OfferedCourseScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseScalarWhereWithAggregatesInput | OfferedCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OfferedCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferedCourse"> | Date | string
    courseId?: StringWithAggregatesFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringWithAggregatesFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourse"> | string
  }

  export type OfferedCourseSectionWhereInput = {
    AND?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    OR?: OfferedCourseSectionWhereInput[]
    NOT?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    id?: StringFilter<"OfferedCourseSection"> | string
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourse?: XOR<OfferedCourseRelationFilter, OfferedCourseWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }

  export type OfferedCourseSectionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseId?: SortOrder
    semesterRegistrationId?: SortOrder
    offeredCourse?: OfferedCourseOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleOrderByRelationAggregateInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseOrderByRelationAggregateInput
  }

  export type OfferedCourseSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    OR?: OfferedCourseSectionWhereInput[]
    NOT?: OfferedCourseSectionWhereInput | OfferedCourseSectionWhereInput[]
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
    offeredCourse?: XOR<OfferedCourseRelationFilter, OfferedCourseWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    offeredCourseClassSchedules?: OfferedCourseClassScheduleListRelationFilter
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseListRelationFilter
  }, "id">

  export type OfferedCourseSectionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseId?: SortOrder
    semesterRegistrationId?: SortOrder
    _count?: OfferedCourseSectionCountOrderByAggregateInput
    _avg?: OfferedCourseSectionAvgOrderByAggregateInput
    _max?: OfferedCourseSectionMaxOrderByAggregateInput
    _min?: OfferedCourseSectionMinOrderByAggregateInput
    _sum?: OfferedCourseSectionSumOrderByAggregateInput
  }

  export type OfferedCourseSectionScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseSectionScalarWhereWithAggregatesInput | OfferedCourseSectionScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseSectionScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseSectionScalarWhereWithAggregatesInput | OfferedCourseSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    title?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntWithAggregatesFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntWithAggregatesFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferedCourseSection"> | Date | string
    offeredCourseId?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourseSection"> | string
  }

  export type OfferedCourseClassScheduleWhereInput = {
    AND?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    OR?: OfferedCourseClassScheduleWhereInput[]
    NOT?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    id?: StringFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
    offeredCourseSection?: XOR<OfferedCourseSectionRelationFilter, OfferedCourseSectionWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
  }

  export type OfferedCourseClassScheduleOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
    offeredCourseSection?: OfferedCourseSectionOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
  }

  export type OfferedCourseClassScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    OR?: OfferedCourseClassScheduleWhereInput[]
    NOT?: OfferedCourseClassScheduleWhereInput | OfferedCourseClassScheduleWhereInput[]
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
    offeredCourseSection?: XOR<OfferedCourseSectionRelationFilter, OfferedCourseSectionWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    faculty?: XOR<FacultyRelationFilter, FacultyWhereInput>
  }, "id">

  export type OfferedCourseClassScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
    _count?: OfferedCourseClassScheduleCountOrderByAggregateInput
    _max?: OfferedCourseClassScheduleMaxOrderByAggregateInput
    _min?: OfferedCourseClassScheduleMinOrderByAggregateInput
  }

  export type OfferedCourseClassScheduleScalarWhereWithAggregatesInput = {
    AND?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput | OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    OR?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    NOT?: OfferedCourseClassScheduleScalarWhereWithAggregatesInput | OfferedCourseClassScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysWithAggregatesFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeWithAggregatesFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringWithAggregatesFilter<"OfferedCourseClassSchedule"> | string
  }

  export type StudentSemesterRegistrationWhereInput = {
    AND?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    OR?: StudentSemesterRegistrationWhereInput[]
    NOT?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    id?: StringFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
  }

  export type StudentSemesterRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    isConfirmed?: SortOrderInput | SortOrder
    totalCreditsTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
    student?: StudentOrderByWithRelationInput
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
  }

  export type StudentSemesterRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    OR?: StudentSemesterRegistrationWhereInput[]
    NOT?: StudentSemesterRegistrationWhereInput | StudentSemesterRegistrationWhereInput[]
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
  }, "id">

  export type StudentSemesterRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    isConfirmed?: SortOrderInput | SortOrder
    totalCreditsTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
    _count?: StudentSemesterRegistrationCountOrderByAggregateInput
    _avg?: StudentSemesterRegistrationAvgOrderByAggregateInput
    _max?: StudentSemesterRegistrationMaxOrderByAggregateInput
    _min?: StudentSemesterRegistrationMinOrderByAggregateInput
    _sum?: StudentSemesterRegistrationSumOrderByAggregateInput
  }

  export type StudentSemesterRegistrationScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterRegistrationScalarWhereWithAggregatesInput | StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterRegistrationScalarWhereWithAggregatesInput | StudentSemesterRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableWithAggregatesFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableWithAggregatesFilter<"StudentSemesterRegistration"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringWithAggregatesFilter<"StudentSemesterRegistration"> | string
  }

  export type StudentSemesterRegistrationCourseWhereInput = {
    AND?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    OR?: StudentSemesterRegistrationCourseWhereInput[]
    NOT?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    offeredCourse?: XOR<OfferedCourseRelationFilter, OfferedCourseWhereInput>
    offeredCourseSection?: XOR<OfferedCourseSectionRelationFilter, OfferedCourseSectionWhereInput>
  }

  export type StudentSemesterRegistrationCourseOrderByWithRelationInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    semesterRegistration?: SemesterRegistrationOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    offeredCourse?: OfferedCourseOrderByWithRelationInput
    offeredCourseSection?: OfferedCourseSectionOrderByWithRelationInput
  }

  export type StudentSemesterRegistrationCourseWhereUniqueInput = Prisma.AtLeast<{
    semesterRegistrationId_studentId_offeredCourseId?: StudentSemesterRegistrationCourseSemesterRegistrationIdStudentIdOfferedCourseIdCompoundUniqueInput
    AND?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    OR?: StudentSemesterRegistrationCourseWhereInput[]
    NOT?: StudentSemesterRegistrationCourseWhereInput | StudentSemesterRegistrationCourseWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    semesterRegistration?: XOR<SemesterRegistrationRelationFilter, SemesterRegistrationWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    offeredCourse?: XOR<OfferedCourseRelationFilter, OfferedCourseWhereInput>
    offeredCourseSection?: XOR<OfferedCourseSectionRelationFilter, OfferedCourseSectionWhereInput>
  }, "semesterRegistrationId_studentId_offeredCourseId">

  export type StudentSemesterRegistrationCourseOrderByWithAggregationInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentSemesterRegistrationCourseCountOrderByAggregateInput
    _max?: StudentSemesterRegistrationCourseMaxOrderByAggregateInput
    _min?: StudentSemesterRegistrationCourseMinOrderByAggregateInput
  }

  export type StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput | StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput | StudentSemesterRegistrationCourseScalarWhereWithAggregatesInput[]
    semesterRegistrationId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterRegistrationCourse"> | Date | string
  }

  export type StudentEnrolledCourseWhereInput = {
    AND?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    OR?: StudentEnrolledCourseWhereInput[]
    NOT?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    id?: StringFilter<"StudentEnrolledCourse"> | string
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
  }

  export type StudentEnrolledCourseOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkOrderByRelationAggregateInput
  }

  export type StudentEnrolledCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    OR?: StudentEnrolledCourseWhereInput[]
    NOT?: StudentEnrolledCourseWhereInput | StudentEnrolledCourseWhereInput[]
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkListRelationFilter
  }, "id">

  export type StudentEnrolledCourseOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrderInput | SortOrder
    point?: SortOrderInput | SortOrder
    totalMarks?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: StudentEnrolledCourseCountOrderByAggregateInput
    _avg?: StudentEnrolledCourseAvgOrderByAggregateInput
    _max?: StudentEnrolledCourseMaxOrderByAggregateInput
    _min?: StudentEnrolledCourseMinOrderByAggregateInput
    _sum?: StudentEnrolledCourseSumOrderByAggregateInput
  }

  export type StudentEnrolledCourseScalarWhereWithAggregatesInput = {
    AND?: StudentEnrolledCourseScalarWhereWithAggregatesInput | StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    OR?: StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrolledCourseScalarWhereWithAggregatesInput | StudentEnrolledCourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    courseId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableWithAggregatesFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableWithAggregatesFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableWithAggregatesFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMarkWhereInput = {
    AND?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    OR?: StudentEnrolledCourseMarkWhereInput[]
    NOT?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    id?: StringFilter<"StudentEnrolledCourseMark"> | string
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourseMark"> | string | null
    marks?: IntNullableFilter<"StudentEnrolledCourseMark"> | number | null
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentEnrolledCourse?: XOR<StudentEnrolledCourseRelationFilter, StudentEnrolledCourseWhereInput>
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
  }

  export type StudentEnrolledCourseMarkOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrderInput | SortOrder
    marks?: SortOrderInput | SortOrder
    examType?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    studentEnrolledCourse?: StudentEnrolledCourseOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
  }

  export type StudentEnrolledCourseMarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    OR?: StudentEnrolledCourseMarkWhereInput[]
    NOT?: StudentEnrolledCourseMarkWhereInput | StudentEnrolledCourseMarkWhereInput[]
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourseMark"> | string | null
    marks?: IntNullableFilter<"StudentEnrolledCourseMark"> | number | null
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    studentEnrolledCourse?: XOR<StudentEnrolledCourseRelationFilter, StudentEnrolledCourseWhereInput>
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
  }, "id">

  export type StudentEnrolledCourseMarkOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrderInput | SortOrder
    marks?: SortOrderInput | SortOrder
    examType?: SortOrderInput | SortOrder
    _count?: StudentEnrolledCourseMarkCountOrderByAggregateInput
    _avg?: StudentEnrolledCourseMarkAvgOrderByAggregateInput
    _max?: StudentEnrolledCourseMarkMaxOrderByAggregateInput
    _min?: StudentEnrolledCourseMarkMinOrderByAggregateInput
    _sum?: StudentEnrolledCourseMarkSumOrderByAggregateInput
  }

  export type StudentEnrolledCourseMarkScalarWhereWithAggregatesInput = {
    AND?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput | StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    OR?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    NOT?: StudentEnrolledCourseMarkScalarWhereWithAggregatesInput | StudentEnrolledCourseMarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentEnrolledCourseMark"> | string
    grade?: StringNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | string | null
    marks?: IntNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | number | null
    examType?: EnumExamTypeNullableWithAggregatesFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
  }

  export type StudentSemesterPaymentWhereInput = {
    AND?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    OR?: StudentSemesterPaymentWhereInput[]
    NOT?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    id?: StringFilter<"StudentSemesterPayment"> | string
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
    fullPaymentAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    partialPaymentAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    totalDueAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    totalPaidAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryListRelationFilter
  }

  export type StudentSemesterPaymentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    fullPaymentAmount?: SortOrderInput | SortOrder
    partialPaymentAmount?: SortOrderInput | SortOrder
    totalDueAmount?: SortOrderInput | SortOrder
    totalPaidAmount?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    academicSemester?: AcademicSemesterOrderByWithRelationInput
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryOrderByRelationAggregateInput
  }

  export type StudentSemesterPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    OR?: StudentSemesterPaymentWhereInput[]
    NOT?: StudentSemesterPaymentWhereInput | StudentSemesterPaymentWhereInput[]
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
    fullPaymentAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    partialPaymentAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    totalDueAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    totalPaidAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    academicSemester?: XOR<AcademicSemesterRelationFilter, AcademicSemesterWhereInput>
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryListRelationFilter
  }, "id">

  export type StudentSemesterPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    fullPaymentAmount?: SortOrderInput | SortOrder
    partialPaymentAmount?: SortOrderInput | SortOrder
    totalDueAmount?: SortOrderInput | SortOrder
    totalPaidAmount?: SortOrderInput | SortOrder
    paymentStatus?: SortOrderInput | SortOrder
    _count?: StudentSemesterPaymentCountOrderByAggregateInput
    _avg?: StudentSemesterPaymentAvgOrderByAggregateInput
    _max?: StudentSemesterPaymentMaxOrderByAggregateInput
    _min?: StudentSemesterPaymentMinOrderByAggregateInput
    _sum?: StudentSemesterPaymentSumOrderByAggregateInput
  }

  export type StudentSemesterPaymentScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterPaymentScalarWhereWithAggregatesInput | StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterPaymentScalarWhereWithAggregatesInput | StudentSemesterPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringWithAggregatesFilter<"StudentSemesterPayment"> | string
    fullPaymentAmount?: IntNullableWithAggregatesFilter<"StudentSemesterPayment"> | number | null
    partialPaymentAmount?: IntNullableWithAggregatesFilter<"StudentSemesterPayment"> | number | null
    totalDueAmount?: IntNullableWithAggregatesFilter<"StudentSemesterPayment"> | number | null
    totalPaidAmount?: IntNullableWithAggregatesFilter<"StudentSemesterPayment"> | number | null
    paymentStatus?: EnumPaymentStatusNullableWithAggregatesFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentHistoryWhereInput = {
    AND?: StudentSemesterPaymentHistoryWhereInput | StudentSemesterPaymentHistoryWhereInput[]
    OR?: StudentSemesterPaymentHistoryWhereInput[]
    NOT?: StudentSemesterPaymentHistoryWhereInput | StudentSemesterPaymentHistoryWhereInput[]
    id?: StringFilter<"StudentSemesterPaymentHistory"> | string
    createdAt?: DateTimeFilter<"StudentSemesterPaymentHistory"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPaymentHistory"> | Date | string
    studentSemesterPaymentId?: StringFilter<"StudentSemesterPaymentHistory"> | string
    transactionId?: StringFilter<"StudentSemesterPaymentHistory"> | string
    dueAmount?: IntFilter<"StudentSemesterPaymentHistory"> | number
    paidAmount?: IntFilter<"StudentSemesterPaymentHistory"> | number
    paymentMethod?: EnumPaymentMethodFilter<"StudentSemesterPaymentHistory"> | $Enums.PaymentMethod
    isPaid?: BoolNullableFilter<"StudentSemesterPaymentHistory"> | boolean | null
    studentSemesterPayment?: XOR<StudentSemesterPaymentRelationFilter, StudentSemesterPaymentWhereInput>
  }

  export type StudentSemesterPaymentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentSemesterPaymentId?: SortOrder
    transactionId?: SortOrder
    dueAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    isPaid?: SortOrderInput | SortOrder
    studentSemesterPayment?: StudentSemesterPaymentOrderByWithRelationInput
  }

  export type StudentSemesterPaymentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentSemesterPaymentHistoryWhereInput | StudentSemesterPaymentHistoryWhereInput[]
    OR?: StudentSemesterPaymentHistoryWhereInput[]
    NOT?: StudentSemesterPaymentHistoryWhereInput | StudentSemesterPaymentHistoryWhereInput[]
    createdAt?: DateTimeFilter<"StudentSemesterPaymentHistory"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPaymentHistory"> | Date | string
    studentSemesterPaymentId?: StringFilter<"StudentSemesterPaymentHistory"> | string
    transactionId?: StringFilter<"StudentSemesterPaymentHistory"> | string
    dueAmount?: IntFilter<"StudentSemesterPaymentHistory"> | number
    paidAmount?: IntFilter<"StudentSemesterPaymentHistory"> | number
    paymentMethod?: EnumPaymentMethodFilter<"StudentSemesterPaymentHistory"> | $Enums.PaymentMethod
    isPaid?: BoolNullableFilter<"StudentSemesterPaymentHistory"> | boolean | null
    studentSemesterPayment?: XOR<StudentSemesterPaymentRelationFilter, StudentSemesterPaymentWhereInput>
  }, "id">

  export type StudentSemesterPaymentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentSemesterPaymentId?: SortOrder
    transactionId?: SortOrder
    dueAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    isPaid?: SortOrderInput | SortOrder
    _count?: StudentSemesterPaymentHistoryCountOrderByAggregateInput
    _avg?: StudentSemesterPaymentHistoryAvgOrderByAggregateInput
    _max?: StudentSemesterPaymentHistoryMaxOrderByAggregateInput
    _min?: StudentSemesterPaymentHistoryMinOrderByAggregateInput
    _sum?: StudentSemesterPaymentHistorySumOrderByAggregateInput
  }

  export type StudentSemesterPaymentHistoryScalarWhereWithAggregatesInput = {
    AND?: StudentSemesterPaymentHistoryScalarWhereWithAggregatesInput | StudentSemesterPaymentHistoryScalarWhereWithAggregatesInput[]
    OR?: StudentSemesterPaymentHistoryScalarWhereWithAggregatesInput[]
    NOT?: StudentSemesterPaymentHistoryScalarWhereWithAggregatesInput | StudentSemesterPaymentHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSemesterPaymentHistory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSemesterPaymentHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentSemesterPaymentHistory"> | Date | string
    studentSemesterPaymentId?: StringWithAggregatesFilter<"StudentSemesterPaymentHistory"> | string
    transactionId?: StringWithAggregatesFilter<"StudentSemesterPaymentHistory"> | string
    dueAmount?: IntWithAggregatesFilter<"StudentSemesterPaymentHistory"> | number
    paidAmount?: IntWithAggregatesFilter<"StudentSemesterPaymentHistory"> | number
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"StudentSemesterPaymentHistory"> | $Enums.PaymentMethod
    isPaid?: BoolNullableWithAggregatesFilter<"StudentSemesterPaymentHistory"> | boolean | null
  }

  export type StudentAcademicInfoWhereInput = {
    AND?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    OR?: StudentAcademicInfoWhereInput[]
    NOT?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    id?: StringFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredit?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type StudentAcademicInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredit?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentAcademicInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    OR?: StudentAcademicInfoWhereInput[]
    NOT?: StudentAcademicInfoWhereInput | StudentAcademicInfoWhereInput[]
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredit?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type StudentAcademicInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredit?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    _count?: StudentAcademicInfoCountOrderByAggregateInput
    _avg?: StudentAcademicInfoAvgOrderByAggregateInput
    _max?: StudentAcademicInfoMaxOrderByAggregateInput
    _min?: StudentAcademicInfoMinOrderByAggregateInput
    _sum?: StudentAcademicInfoSumOrderByAggregateInput
  }

  export type StudentAcademicInfoScalarWhereWithAggregatesInput = {
    AND?: StudentAcademicInfoScalarWhereWithAggregatesInput | StudentAcademicInfoScalarWhereWithAggregatesInput[]
    OR?: StudentAcademicInfoScalarWhereWithAggregatesInput[]
    NOT?: StudentAcademicInfoScalarWhereWithAggregatesInput | StudentAcademicInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringWithAggregatesFilter<"StudentAcademicInfo"> | string
    totalCompletedCredit?: IntNullableWithAggregatesFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableWithAggregatesFilter<"StudentAcademicInfo"> | number | null
  }

  export type AcademicSemesterCreateInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterCreateManyInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicSemesterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSemesterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicFacultyCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicFacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicFacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFacultyId: string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFacultyId: string
  }

  export type AcademicDepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicDepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyCreateInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    academicFacultyId: string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateManyInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    academicFacultyId: string
  }

  export type FacultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
  }

  export type BuildingCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUncheckedCreateInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingCreateManyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingId: string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseToPrerequisiteCreateInput = {
    course: CourseCreateNestedOneWithoutPreRequisiteInput
    preRequisite: CourseCreateNestedOneWithoutPreRequisiteForInput
  }

  export type CourseToPrerequisiteUncheckedCreateInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPrerequisiteUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutPreRequisiteNestedInput
    preRequisite?: CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput
  }

  export type CourseToPrerequisiteUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPrerequisiteCreateManyInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPrerequisiteUpdateManyMutationInput = {

  }

  export type CourseToPrerequisiteUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyCreateInput = {
    course: CourseCreateNestedOneWithoutFacultiesInput
    faculty: FacultyCreateNestedOneWithoutCoursesInput
  }

  export type CourseFacultyUncheckedCreateInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutFacultiesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseFacultyUncheckedUpdateInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyCreateManyInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyUpdateManyMutationInput = {

  }

  export type CourseFacultyUncheckedUpdateManyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type SemesterRegistrationCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
  }

  export type SemesterRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SemesterRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicDepartmentId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicDepartmentId: string
    semesterRegistrationId: string
  }

  export type OfferedCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseSectionCreateInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
    semesterRegistrationId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionCreateManyInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
    semesterRegistrationId: string
  }

  export type OfferedCourseSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleCreateInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleCreateManyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateManyInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseCreateManyInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
    academicSemesterId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
    academicSemesterId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMarkCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    academicSemesterId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentSemesterPaymentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryCreateNestedManyWithoutStudentSemesterPaymentInput
  }

  export type StudentSemesterPaymentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUncheckedCreateNestedManyWithoutStudentSemesterPaymentInput
  }

  export type StudentSemesterPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUpdateManyWithoutStudentSemesterPaymentNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUncheckedUpdateManyWithoutStudentSemesterPaymentNestedInput
  }

  export type StudentSemesterPaymentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentHistoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId: string
    dueAmount?: number
    paidAmount?: number
    paymentMethod?: $Enums.PaymentMethod
    isPaid?: boolean | null
    studentSemesterPayment: StudentSemesterPaymentCreateNestedOneWithoutStudentSemesterPaymentHistoryInput
  }

  export type StudentSemesterPaymentHistoryUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterPaymentId: string
    transactionId: string
    dueAmount?: number
    paidAmount?: number
    paymentMethod?: $Enums.PaymentMethod
    isPaid?: boolean | null
  }

  export type StudentSemesterPaymentHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    dueAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    studentSemesterPayment?: StudentSemesterPaymentUpdateOneRequiredWithoutStudentSemesterPaymentHistoryNestedInput
  }

  export type StudentSemesterPaymentHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterPaymentId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    dueAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentSemesterPaymentHistoryCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentSemesterPaymentId: string
    transactionId: string
    dueAmount?: number
    paidAmount?: number
    paymentMethod?: $Enums.PaymentMethod
    isPaid?: boolean | null
  }

  export type StudentSemesterPaymentHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    dueAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentSemesterPaymentHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSemesterPaymentId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    dueAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentAcademicInfoCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredit?: number | null
    cgpa?: number | null
    student: StudentCreateNestedOneWithoutStudentAcademicInfosInput
  }

  export type StudentAcademicInfoUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    totalCompletedCredit?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredit?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutStudentAcademicInfosNestedInput
  }

  export type StudentAcademicInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalCompletedCredit?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    totalCompletedCredit?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredit?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    totalCompletedCredit?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type SemesterRegistrationListRelationFilter = {
    every?: SemesterRegistrationWhereInput
    some?: SemesterRegistrationWhereInput
    none?: SemesterRegistrationWhereInput
  }

  export type StudentEnrolledCourseListRelationFilter = {
    every?: StudentEnrolledCourseWhereInput
    some?: StudentEnrolledCourseWhereInput
    none?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseMarkListRelationFilter = {
    every?: StudentEnrolledCourseMarkWhereInput
    some?: StudentEnrolledCourseMarkWhereInput
    none?: StudentEnrolledCourseMarkWhereInput
  }

  export type StudentSemesterPaymentListRelationFilter = {
    every?: StudentSemesterPaymentWhereInput
    some?: StudentSemesterPaymentWhereInput
    none?: StudentSemesterPaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemesterRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrolledCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentEnrolledCourseMarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSemesterPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicSemesterCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSemesterAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type AcademicSemesterMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSemesterMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    title?: SortOrder
    code?: SortOrder
    startMonth?: SortOrder
    endMonth?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSemesterSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AcademicDepartmentListRelationFilter = {
    every?: AcademicDepartmentWhereInput
    some?: AcademicDepartmentWhereInput
    none?: AcademicDepartmentWhereInput
  }

  export type FacultyListRelationFilter = {
    every?: FacultyWhereInput
    some?: FacultyWhereInput
    none?: FacultyWhereInput
  }

  export type AcademicDepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicFacultyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicFacultyRelationFilter = {
    is?: AcademicFacultyWhereInput
    isNot?: AcademicFacultyWhereInput
  }

  export type OfferedCourseListRelationFilter = {
    every?: OfferedCourseWhereInput
    some?: OfferedCourseWhereInput
    none?: OfferedCourseWhereInput
  }

  export type OfferedCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicDepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type AcademicDepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type AcademicDepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AcademicSemesterRelationFilter = {
    is?: AcademicSemesterWhereInput
    isNot?: AcademicSemesterWhereInput
  }

  export type AcademicDepartmentRelationFilter = {
    is?: AcademicDepartmentWhereInput
    isNot?: AcademicDepartmentWhereInput
  }

  export type StudentSemesterRegistrationListRelationFilter = {
    every?: StudentSemesterRegistrationWhereInput
    some?: StudentSemesterRegistrationWhereInput
    none?: StudentSemesterRegistrationWhereInput
  }

  export type StudentSemesterRegistrationCourseListRelationFilter = {
    every?: StudentSemesterRegistrationCourseWhereInput
    some?: StudentSemesterRegistrationCourseWhereInput
    none?: StudentSemesterRegistrationCourseWhereInput
  }

  export type StudentAcademicInfoListRelationFilter = {
    every?: StudentAcademicInfoWhereInput
    some?: StudentAcademicInfoWhereInput
    none?: StudentAcademicInfoWhereInput
  }

  export type StudentSemesterRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSemesterRegistrationCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAcademicInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CourseFacultyListRelationFilter = {
    every?: CourseFacultyWhereInput
    some?: CourseFacultyWhereInput
    none?: CourseFacultyWhereInput
  }

  export type OfferedCourseClassScheduleListRelationFilter = {
    every?: OfferedCourseClassScheduleWhereInput
    some?: OfferedCourseClassScheduleWhereInput
    none?: OfferedCourseClassScheduleWhereInput
  }

  export type CourseFacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferedCourseClassScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    middleName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    designation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicDepartmentId?: SortOrder
    academicFacultyId?: SortOrder
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingRelationFilter = {
    is?: BuildingWhereInput
    isNot?: BuildingWhereInput
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buildingId?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buildingId?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buildingId?: SortOrder
  }

  export type CourseToPrerequisiteListRelationFilter = {
    every?: CourseToPrerequisiteWhereInput
    some?: CourseToPrerequisiteWhereInput
    none?: CourseToPrerequisiteWhereInput
  }

  export type CourseToPrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    code?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseToPrerequisiteCourseIdPreRequisiteIdCompoundUniqueInput = {
    courseId: string
    preRequisiteId: string
  }

  export type CourseToPrerequisiteCountOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type CourseToPrerequisiteMaxOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type CourseToPrerequisiteMinOrderByAggregateInput = {
    courseId?: SortOrder
    preRequisiteId?: SortOrder
  }

  export type FacultyRelationFilter = {
    is?: FacultyWhereInput
    isNot?: FacultyWhereInput
  }

  export type CourseFacultyCourseIdFacultyIdCompoundUniqueInput = {
    courseId: string
    facultyId: string
  }

  export type CourseFacultyCountOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type CourseFacultyMaxOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type CourseFacultyMinOrderByAggregateInput = {
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type EnumSemesterRegistrationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
  }

  export type OfferedCourseSectionListRelationFilter = {
    every?: OfferedCourseSectionWhereInput
    some?: OfferedCourseSectionWhereInput
    none?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SemesterRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    minCredit?: SortOrder
    maxCredit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationAvgOrderByAggregateInput = {
    minCredit?: SortOrder
    maxCredit?: SortOrder
  }

  export type SemesterRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    minCredit?: SortOrder
    maxCredit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    minCredit?: SortOrder
    maxCredit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academicSemesterId?: SortOrder
  }

  export type SemesterRegistrationSumOrderByAggregateInput = {
    minCredit?: SortOrder
    maxCredit?: SortOrder
  }

  export type EnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
  }

  export type SemesterRegistrationRelationFilter = {
    is?: SemesterRegistrationWhereInput
    isNot?: SemesterRegistrationWhereInput
  }

  export type OfferedCourseCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    academicDepartmentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    academicDepartmentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    courseId?: SortOrder
    academicDepartmentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseRelationFilter = {
    is?: OfferedCourseWhereInput
    isNot?: OfferedCourseWhereInput
  }

  export type OfferedCourseSectionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseSectionAvgOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
  }

  export type OfferedCourseSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseSectionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type OfferedCourseSectionSumOrderByAggregateInput = {
    maxCapacity?: SortOrder
    currentlyEnrolledStudent?: SortOrder
  }

  export type EnumWeekDaysFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDaysFilter<$PrismaModel> | $Enums.WeekDays
  }

  export type OfferedCourseSectionRelationFilter = {
    is?: OfferedCourseSectionWhereInput
    isNot?: OfferedCourseSectionWhereInput
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type OfferedCourseClassScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type OfferedCourseClassScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type OfferedCourseClassScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offeredCourseSectionId?: SortOrder
    semesterRegistrationId?: SortOrder
    roomId?: SortOrder
    facultyId?: SortOrder
  }

  export type EnumWeekDaysWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel> | $Enums.WeekDays
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDaysFilter<$PrismaModel>
    _max?: NestedEnumWeekDaysFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type StudentSemesterRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationAvgOrderByAggregateInput = {
    totalCreditsTaken?: SortOrder
  }

  export type StudentSemesterRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    isConfirmed?: SortOrder
    totalCreditsTaken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    semesterRegistrationId?: SortOrder
  }

  export type StudentSemesterRegistrationSumOrderByAggregateInput = {
    totalCreditsTaken?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StudentSemesterRegistrationCourseSemesterRegistrationIdStudentIdOfferedCourseIdCompoundUniqueInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
  }

  export type StudentSemesterRegistrationCourseCountOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSemesterRegistrationCourseMaxOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSemesterRegistrationCourseMinOrderByAggregateInput = {
    semesterRegistrationId?: SortOrder
    studentId?: SortOrder
    offeredCourseId?: SortOrder
    offeredCourseSectionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
  }

  export type StudentEnrolledCourseAvgOrderByAggregateInput = {
    point?: SortOrder
    totalMarks?: SortOrder
  }

  export type StudentEnrolledCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
  }

  export type StudentEnrolledCourseMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrder
    point?: SortOrder
    totalMarks?: SortOrder
    status?: SortOrder
  }

  export type StudentEnrolledCourseSumOrderByAggregateInput = {
    point?: SortOrder
    totalMarks?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
  }

  export type EnumExamTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExamTypeNullableFilter<$PrismaModel> | $Enums.ExamType | null
  }

  export type StudentEnrolledCourseRelationFilter = {
    is?: StudentEnrolledCourseWhereInput
    isNot?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseMarkCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrder
    marks?: SortOrder
    examType?: SortOrder
  }

  export type StudentEnrolledCourseMarkAvgOrderByAggregateInput = {
    marks?: SortOrder
  }

  export type StudentEnrolledCourseMarkMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrder
    marks?: SortOrder
    examType?: SortOrder
  }

  export type StudentEnrolledCourseMarkMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    studentEnrolledCourseId?: SortOrder
    academicSemesterId?: SortOrder
    grade?: SortOrder
    marks?: SortOrder
    examType?: SortOrder
  }

  export type StudentEnrolledCourseMarkSumOrderByAggregateInput = {
    marks?: SortOrder
  }

  export type EnumExamTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExamType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExamTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumExamTypeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentHistoryListRelationFilter = {
    every?: StudentSemesterPaymentHistoryWhereInput
    some?: StudentSemesterPaymentHistoryWhereInput
    none?: StudentSemesterPaymentHistoryWhereInput
  }

  export type StudentSemesterPaymentHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSemesterPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    fullPaymentAmount?: SortOrder
    partialPaymentAmount?: SortOrder
    totalDueAmount?: SortOrder
    totalPaidAmount?: SortOrder
    paymentStatus?: SortOrder
  }

  export type StudentSemesterPaymentAvgOrderByAggregateInput = {
    fullPaymentAmount?: SortOrder
    partialPaymentAmount?: SortOrder
    totalDueAmount?: SortOrder
    totalPaidAmount?: SortOrder
  }

  export type StudentSemesterPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    fullPaymentAmount?: SortOrder
    partialPaymentAmount?: SortOrder
    totalDueAmount?: SortOrder
    totalPaidAmount?: SortOrder
    paymentStatus?: SortOrder
  }

  export type StudentSemesterPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    academicSemesterId?: SortOrder
    fullPaymentAmount?: SortOrder
    partialPaymentAmount?: SortOrder
    totalDueAmount?: SortOrder
    totalPaidAmount?: SortOrder
    paymentStatus?: SortOrder
  }

  export type StudentSemesterPaymentSumOrderByAggregateInput = {
    fullPaymentAmount?: SortOrder
    partialPaymentAmount?: SortOrder
    totalDueAmount?: SortOrder
    totalPaidAmount?: SortOrder
  }

  export type EnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type StudentSemesterPaymentRelationFilter = {
    is?: StudentSemesterPaymentWhereInput
    isNot?: StudentSemesterPaymentWhereInput
  }

  export type StudentSemesterPaymentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentSemesterPaymentId?: SortOrder
    transactionId?: SortOrder
    dueAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    isPaid?: SortOrder
  }

  export type StudentSemesterPaymentHistoryAvgOrderByAggregateInput = {
    dueAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type StudentSemesterPaymentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentSemesterPaymentId?: SortOrder
    transactionId?: SortOrder
    dueAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    isPaid?: SortOrder
  }

  export type StudentSemesterPaymentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentSemesterPaymentId?: SortOrder
    transactionId?: SortOrder
    dueAmount?: SortOrder
    paidAmount?: SortOrder
    paymentMethod?: SortOrder
    isPaid?: SortOrder
  }

  export type StudentSemesterPaymentHistorySumOrderByAggregateInput = {
    dueAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type StudentAcademicInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredit?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoAvgOrderByAggregateInput = {
    totalCompletedCredit?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredit?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentId?: SortOrder
    totalCompletedCredit?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentAcademicInfoSumOrderByAggregateInput = {
    totalCompletedCredit?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StudentUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    set?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    disconnect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    delete?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    update?: SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput | SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
  }

  export type StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput> | StudentCreateWithoutAcademicSemesterInput[] | StudentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicSemesterInput | StudentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentCreateManyAcademicSemesterInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput> | SemesterRegistrationCreateWithoutAcademicSemesterInput[] | SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput | SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: SemesterRegistrationCreateManyAcademicSemesterInputEnvelope
    set?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    disconnect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    delete?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    connect?: SemesterRegistrationWhereUniqueInput | SemesterRegistrationWhereUniqueInput[]
    update?: SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput | SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput | SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput> | StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput | StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput> | StudentSemesterPaymentCreateWithoutAcademicSemesterInput[] | StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput | StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput[]
    createMany?: StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput | StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type FacultyCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput | AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput | StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput | StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicFacultyInput | StudentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type FacultyUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicFacultyInput | FacultyUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput> | AcademicDepartmentCreateWithoutAcademicFacultyInput[] | AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput | AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: AcademicDepartmentCreateManyAcademicFacultyInputEnvelope
    set?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    disconnect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    delete?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    connect?: AcademicDepartmentWhereUniqueInput | AcademicDepartmentWhereUniqueInput[]
    update?: AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput | AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput | AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput> | StudentCreateWithoutAcademicFacultyInput[] | StudentUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicFacultyInput | StudentCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput | StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: StudentCreateManyAcademicFacultyInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput | StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicFacultyInput | StudentUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput> | FacultyCreateWithoutAcademicFacultyInput[] | FacultyUncheckedCreateWithoutAcademicFacultyInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicFacultyInput | FacultyCreateOrConnectWithoutAcademicFacultyInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput[]
    createMany?: FacultyCreateManyAcademicFacultyInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput | FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicFacultyInput | FacultyUpdateManyWithWhereWithoutAcademicFacultyInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput = {
    create?: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type FacultyCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput
    upsert?: AcademicFacultyUpsertWithoutAcademicDepartmentsInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutAcademicDepartmentsInput, AcademicFacultyUpdateWithoutAcademicDepartmentsInput>, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
  }

  export type StudentUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicDepartmentInput | StudentUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type FacultyUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput | FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput | OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput> | StudentCreateWithoutAcademicDepartmentInput[] | StudentUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAcademicDepartmentInput | StudentCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: StudentCreateManyAcademicDepartmentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput | StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAcademicDepartmentInput | StudentUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput> | FacultyCreateWithoutAcademicDepartmentInput[] | FacultyUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutAcademicDepartmentInput | FacultyCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: FacultyCreateManyAcademicDepartmentInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput | FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput | FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput> | OfferedCourseCreateWithoutAcademicDepartmentInput[] | OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput | OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput[]
    createMany?: OfferedCourseCreateManyAcademicDepartmentInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput | OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput | OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type AcademicDepartmentCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStudentsInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicFacultyCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutStudentsInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type StudentSemesterRegistrationCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentAcademicInfoCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
  }

  export type StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentsInput
    upsert?: AcademicSemesterUpsertWithoutStudentsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentsInput, AcademicSemesterUpdateWithoutStudentsInput>, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutStudentsInput
    upsert?: AcademicDepartmentUpsertWithoutStudentsInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutStudentsInput, AcademicDepartmentUpdateWithoutStudentsInput>, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutStudentsInput
    upsert?: AcademicFacultyUpsertWithoutStudentsInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutStudentsInput, AcademicFacultyUpdateWithoutStudentsInput>, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentAcademicInfoUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    set?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    disconnect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    delete?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    update?: StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput | StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCreateWithoutStudentInput[] | StudentSemesterRegistrationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput> | StudentSemesterRegistrationCourseCreateWithoutStudentInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseCreateWithoutStudentInput[] | StudentEnrolledCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentInput | StudentEnrolledCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput> | StudentEnrolledCourseMarkCreateWithoutStudentInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput> | StudentSemesterPaymentCreateWithoutStudentInput[] | StudentSemesterPaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentInput | StudentSemesterPaymentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSemesterPaymentCreateManyStudentInputEnvelope
    set?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    delete?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    connect?: StudentSemesterPaymentWhereUniqueInput | StudentSemesterPaymentWhereUniqueInput[]
    update?: StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput | StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput | StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
  }

  export type StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput> | StudentAcademicInfoCreateWithoutStudentInput[] | StudentAcademicInfoUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAcademicInfoCreateOrConnectWithoutStudentInput | StudentAcademicInfoCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAcademicInfoCreateManyStudentInputEnvelope
    set?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    disconnect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    delete?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    connect?: StudentAcademicInfoWhereUniqueInput | StudentAcademicInfoWhereUniqueInput[]
    update?: StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput | StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput | StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
  }

  export type AcademicDepartmentCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutFacultiesInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type AcademicFacultyCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutFacultiesInput
    connect?: AcademicFacultyWhereUniqueInput
  }

  export type CourseFacultyCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutFacultiesInput
    upsert?: AcademicDepartmentUpsertWithoutFacultiesInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutFacultiesInput, AcademicDepartmentUpdateWithoutFacultiesInput>, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: AcademicFacultyCreateOrConnectWithoutFacultiesInput
    upsert?: AcademicFacultyUpsertWithoutFacultiesInput
    connect?: AcademicFacultyWhereUniqueInput
    update?: XOR<XOR<AcademicFacultyUpdateToOneWithWhereWithoutFacultiesInput, AcademicFacultyUpdateWithoutFacultiesInput>, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
  }

  export type CourseFacultyUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput | CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput | CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutFacultyInput | CourseFacultyUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput> | CourseFacultyCreateWithoutFacultyInput[] | CourseFacultyUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutFacultyInput | CourseFacultyCreateOrConnectWithoutFacultyInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput | CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: CourseFacultyCreateManyFacultyInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput | CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutFacultyInput | CourseFacultyUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput> | OfferedCourseClassScheduleCreateWithoutFacultyInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput | OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: OfferedCourseClassScheduleCreateManyFacultyInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type RoomCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BuildingCreateNestedOneWithoutRoomsInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type BuildingUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    upsert?: BuildingUpsertWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
    update?: XOR<XOR<BuildingUpdateToOneWithWhereWithoutRoomsInput, BuildingUpdateWithoutRoomsInput>, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput> | OfferedCourseClassScheduleCreateWithoutRoomInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput | OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: OfferedCourseClassScheduleCreateManyRoomInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type CourseToPrerequisiteCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutCourseInput, CourseToPrerequisiteUncheckedCreateWithoutCourseInput> | CourseToPrerequisiteCreateWithoutCourseInput[] | CourseToPrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutCourseInput | CourseToPrerequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CourseToPrerequisiteCreateManyCourseInputEnvelope
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
  }

  export type CourseToPrerequisiteCreateNestedManyWithoutPreRequisiteInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPrerequisiteCreateWithoutPreRequisiteInput[] | CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput[]
    createMany?: CourseToPrerequisiteCreateManyPreRequisiteInputEnvelope
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
  }

  export type CourseFacultyCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type CourseToPrerequisiteUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutCourseInput, CourseToPrerequisiteUncheckedCreateWithoutCourseInput> | CourseToPrerequisiteCreateWithoutCourseInput[] | CourseToPrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutCourseInput | CourseToPrerequisiteCreateOrConnectWithoutCourseInput[]
    createMany?: CourseToPrerequisiteCreateManyCourseInputEnvelope
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
  }

  export type CourseToPrerequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPrerequisiteCreateWithoutPreRequisiteInput[] | CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput[]
    createMany?: CourseToPrerequisiteCreateManyPreRequisiteInputEnvelope
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
  }

  export type CourseFacultyUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
  }

  export type CourseToPrerequisiteUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutCourseInput, CourseToPrerequisiteUncheckedCreateWithoutCourseInput> | CourseToPrerequisiteCreateWithoutCourseInput[] | CourseToPrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutCourseInput | CourseToPrerequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CourseToPrerequisiteUpsertWithWhereUniqueWithoutCourseInput | CourseToPrerequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseToPrerequisiteCreateManyCourseInputEnvelope
    set?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    disconnect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    delete?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    update?: CourseToPrerequisiteUpdateWithWhereUniqueWithoutCourseInput | CourseToPrerequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseToPrerequisiteUpdateManyWithWhereWithoutCourseInput | CourseToPrerequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseToPrerequisiteScalarWhereInput | CourseToPrerequisiteScalarWhereInput[]
  }

  export type CourseToPrerequisiteUpdateManyWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPrerequisiteCreateWithoutPreRequisiteInput[] | CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput[]
    upsert?: CourseToPrerequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput | CourseToPrerequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput[]
    createMany?: CourseToPrerequisiteCreateManyPreRequisiteInputEnvelope
    set?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    disconnect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    delete?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    update?: CourseToPrerequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput | CourseToPrerequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput[]
    updateMany?: CourseToPrerequisiteUpdateManyWithWhereWithoutPreRequisiteInput | CourseToPrerequisiteUpdateManyWithWhereWithoutPreRequisiteInput[]
    deleteMany?: CourseToPrerequisiteScalarWhereInput | CourseToPrerequisiteScalarWhereInput[]
  }

  export type CourseFacultyUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutCourseInput | CourseFacultyUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutCourseInput | CourseFacultyUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutCourseInput | CourseFacultyUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutCourseInput | OfferedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutCourseInput | OfferedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutCourseInput | OfferedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput | StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type CourseToPrerequisiteUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutCourseInput, CourseToPrerequisiteUncheckedCreateWithoutCourseInput> | CourseToPrerequisiteCreateWithoutCourseInput[] | CourseToPrerequisiteUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutCourseInput | CourseToPrerequisiteCreateOrConnectWithoutCourseInput[]
    upsert?: CourseToPrerequisiteUpsertWithWhereUniqueWithoutCourseInput | CourseToPrerequisiteUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseToPrerequisiteCreateManyCourseInputEnvelope
    set?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    disconnect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    delete?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    update?: CourseToPrerequisiteUpdateWithWhereUniqueWithoutCourseInput | CourseToPrerequisiteUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseToPrerequisiteUpdateManyWithWhereWithoutCourseInput | CourseToPrerequisiteUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseToPrerequisiteScalarWhereInput | CourseToPrerequisiteScalarWhereInput[]
  }

  export type CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseToPrerequisiteCreateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput> | CourseToPrerequisiteCreateWithoutPreRequisiteInput[] | CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput[]
    connectOrCreate?: CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput | CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput[]
    upsert?: CourseToPrerequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput | CourseToPrerequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput[]
    createMany?: CourseToPrerequisiteCreateManyPreRequisiteInputEnvelope
    set?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    disconnect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    delete?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    connect?: CourseToPrerequisiteWhereUniqueInput | CourseToPrerequisiteWhereUniqueInput[]
    update?: CourseToPrerequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput | CourseToPrerequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput[]
    updateMany?: CourseToPrerequisiteUpdateManyWithWhereWithoutPreRequisiteInput | CourseToPrerequisiteUpdateManyWithWhereWithoutPreRequisiteInput[]
    deleteMany?: CourseToPrerequisiteScalarWhereInput | CourseToPrerequisiteScalarWhereInput[]
  }

  export type CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput> | CourseFacultyCreateWithoutCourseInput[] | CourseFacultyUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseFacultyCreateOrConnectWithoutCourseInput | CourseFacultyCreateOrConnectWithoutCourseInput[]
    upsert?: CourseFacultyUpsertWithWhereUniqueWithoutCourseInput | CourseFacultyUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseFacultyCreateManyCourseInputEnvelope
    set?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    disconnect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    delete?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    connect?: CourseFacultyWhereUniqueInput | CourseFacultyWhereUniqueInput[]
    update?: CourseFacultyUpdateWithWhereUniqueWithoutCourseInput | CourseFacultyUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseFacultyUpdateManyWithWhereWithoutCourseInput | CourseFacultyUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput> | OfferedCourseCreateWithoutCourseInput[] | OfferedCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutCourseInput | OfferedCourseCreateOrConnectWithoutCourseInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutCourseInput | OfferedCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: OfferedCourseCreateManyCourseInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutCourseInput | OfferedCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutCourseInput | OfferedCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput> | StudentEnrolledCourseCreateWithoutCourseInput[] | StudentEnrolledCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutCourseInput | StudentEnrolledCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentEnrolledCourseCreateManyCourseInputEnvelope
    set?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    delete?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    connect?: StudentEnrolledCourseWhereUniqueInput | StudentEnrolledCourseWhereUniqueInput[]
    update?: StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput | StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput | StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutPreRequisiteInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutPreRequisiteForInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteForInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutPreRequisiteNestedInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteInput
    upsert?: CourseUpsertWithoutPreRequisiteInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPreRequisiteInput, CourseUpdateWithoutPreRequisiteInput>, CourseUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput = {
    create?: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    connectOrCreate?: CourseCreateOrConnectWithoutPreRequisiteForInput
    upsert?: CourseUpsertWithoutPreRequisiteForInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutPreRequisiteForInput, CourseUpdateWithoutPreRequisiteForInput>, CourseUncheckedUpdateWithoutPreRequisiteForInput>
  }

  export type CourseCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFacultiesInput
    connect?: CourseWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutCoursesInput = {
    create?: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCoursesInput
    connect?: FacultyWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFacultiesInput
    upsert?: CourseUpsertWithoutFacultiesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFacultiesInput, CourseUpdateWithoutFacultiesInput>, CourseUncheckedUpdateWithoutFacultiesInput>
  }

  export type FacultyUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutCoursesInput
    upsert?: FacultyUpsertWithoutCoursesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutCoursesInput, FacultyUpdateWithoutCoursesInput>, FacultyUncheckedUpdateWithoutCoursesInput>
  }

  export type AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput = {
    create?: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput = {
    set?: $Enums.SemesterRegistrationStatus | null
  }

  export type AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput
    upsert?: AcademicSemesterUpsertWithoutSemesterRegistrationsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutSemesterRegistrationsInput, AcademicSemesterUpdateWithoutSemesterRegistrationsInput>, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
  }

  export type OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseCreateWithoutSemesterRegistrationInput[] | OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    disconnect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    delete?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    connect?: OfferedCourseWhereUniqueInput | OfferedCourseWhereUniqueInput[]
    update?: OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseSectionCreateWithoutSemesterRegistrationInput[] | OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput> | OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput | OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    delete?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    connect?: StudentSemesterRegistrationWhereUniqueInput | StudentSemesterRegistrationWhereUniqueInput[]
    update?: StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput> | StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferedCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutOfferedCoursesInput
    upsert?: CourseUpsertWithoutOfferedCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutOfferedCoursesInput, CourseUpdateWithoutOfferedCoursesInput>, CourseUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput
    upsert?: AcademicDepartmentUpsertWithoutOfferedCoursesInput
    connect?: AcademicDepartmentWhereUniqueInput
    update?: XOR<XOR<AcademicDepartmentUpdateToOneWithWhereWithoutOfferedCoursesInput, AcademicDepartmentUpdateWithoutOfferedCoursesInput>, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCoursesInput, SemesterRegistrationUpdateWithoutOfferedCoursesInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput | OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput> | OfferedCourseSectionCreateWithoutOfferedCourseInput[] | OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput | OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: OfferedCourseSectionCreateManyOfferedCourseInputEnvelope
    set?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    disconnect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    delete?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    connect?: OfferedCourseSectionWhereUniqueInput | OfferedCourseSectionWhereUniqueInput[]
    update?: OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput | OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput | OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput = {
    create?: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput
    connect?: OfferedCourseWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
  }

  export type OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput
    upsert?: OfferedCourseUpsertWithoutOfferedCourseSectionsInput
    connect?: OfferedCourseWhereUniqueInput
    update?: XOR<XOR<OfferedCourseUpdateToOneWithWhereWithoutOfferedCourseSectionsInput, OfferedCourseUpdateWithoutOfferedCourseSectionsInput>, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCourseSectionsInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseSectionsInput, SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput> | OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput[] | OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope
    set?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    disconnect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    delete?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    connect?: OfferedCourseClassScheduleWhereUniqueInput | OfferedCourseClassScheduleWhereUniqueInput[]
    update?: OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput | OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput = {
    create?: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput> | StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput[] | StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput[]
    connectOrCreate?: StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput[]
    upsert?: StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput[]
    createMany?: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope
    set?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    disconnect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    delete?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    connect?: StudentSemesterRegistrationCourseWhereUniqueInput | StudentSemesterRegistrationCourseWhereUniqueInput[]
    update?: StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput[]
    updateMany?: StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput | StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput[]
    deleteMany?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
  }

  export type OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: OfferedCourseSectionWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: RoomWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput = {
    create?: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    connect?: FacultyWhereUniqueInput
  }

  export type EnumWeekDaysFieldUpdateOperationsInput = {
    set?: $Enums.WeekDays
  }

  export type OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: OfferedCourseSectionUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: OfferedCourseSectionWhereUniqueInput
    update?: XOR<XOR<OfferedCourseSectionUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput>, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: SemesterRegistrationUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput>, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: RoomUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, RoomUpdateWithoutOfferedCourseClassSchedulesInput>, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput = {
    create?: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput
    upsert?: FacultyUpsertWithoutOfferedCourseClassSchedulesInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput, FacultyUpdateWithoutOfferedCourseClassSchedulesInput>, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput
    connect?: StudentWhereUniqueInput
  }

  export type SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput
    upsert?: StudentUpsertWithoutStudentSemesterRegistrationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput, StudentUpdateWithoutStudentSemesterRegistrationsInput>, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput
    upsert?: SemesterRegistrationUpsertWithoutStudentSemesterRegistrationsInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput>, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: StudentWhereUniqueInput
  }

  export type OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseWhereUniqueInput
  }

  export type OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseSectionWhereUniqueInput
  }

  export type SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: SemesterRegistrationUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: SemesterRegistrationWhereUniqueInput
    update?: XOR<XOR<SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput>, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: StudentUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, StudentUpdateWithoutStudentSemesterRegistrationCoursesInput>, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: OfferedCourseUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseWhereUniqueInput
    update?: XOR<XOR<OfferedCourseUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput>, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput = {
    create?: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    connectOrCreate?: OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput
    upsert?: OfferedCourseSectionUpsertWithoutStudentSemesterRegistrationCoursesInput
    connect?: OfferedCourseSectionWhereUniqueInput
    update?: XOR<XOR<OfferedCourseSectionUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput>, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: StudentUpsertWithoutStudentEnrolledCoursesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, StudentUpdateWithoutStudentEnrolledCoursesInput>, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: CourseUpsertWithoutStudentEnrolledCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, CourseUpdateWithoutStudentEnrolledCoursesInput>, CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput
    upsert?: AcademicSemesterUpsertWithoutStudentEnrolledCoursesInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput, AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput>, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput = {
    create?: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput> | StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput[] | StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput[]
    connectOrCreate?: StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput[]
    upsert?: StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    createMany?: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope
    set?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    disconnect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    delete?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    connect?: StudentEnrolledCourseMarkWhereUniqueInput | StudentEnrolledCourseMarkWhereUniqueInput[]
    update?: StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput[]
    updateMany?: StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput | StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput[]
    deleteMany?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: StudentEnrolledCourseWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type NullableEnumExamTypeFieldUpdateOperationsInput = {
    set?: $Enums.ExamType | null
  }

  export type StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: StudentUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, StudentUpdateWithoutStudentEnrolledCourseMarksInput>, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: StudentEnrolledCourseUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: StudentEnrolledCourseWhereUniqueInput
    update?: XOR<XOR<StudentEnrolledCourseUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput>, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput
    upsert?: AcademicSemesterUpsertWithoutStudentEnrolledCourseMarksInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput>, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentCreateNestedOneWithoutStudentSemesterPaymentsInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterPaymentsInput
    connect?: StudentWhereUniqueInput
  }

  export type AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput
    connect?: AcademicSemesterWhereUniqueInput
  }

  export type StudentSemesterPaymentHistoryCreateNestedManyWithoutStudentSemesterPaymentInput = {
    create?: XOR<StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput> | StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput[] | StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput[]
    createMany?: StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInputEnvelope
    connect?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
  }

  export type StudentSemesterPaymentHistoryUncheckedCreateNestedManyWithoutStudentSemesterPaymentInput = {
    create?: XOR<StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput> | StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput[] | StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput[]
    createMany?: StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInputEnvelope
    connect?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
  }

  export type NullableEnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus | null
  }

  export type StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSemesterPaymentsInput
    upsert?: StudentUpsertWithoutStudentSemesterPaymentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput, StudentUpdateWithoutStudentSemesterPaymentsInput>, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput = {
    create?: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    connectOrCreate?: AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput
    upsert?: AcademicSemesterUpsertWithoutStudentSemesterPaymentsInput
    connect?: AcademicSemesterWhereUniqueInput
    update?: XOR<XOR<AcademicSemesterUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput, AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput>, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentSemesterPaymentHistoryUpdateManyWithoutStudentSemesterPaymentNestedInput = {
    create?: XOR<StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput> | StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput[] | StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput[]
    upsert?: StudentSemesterPaymentHistoryUpsertWithWhereUniqueWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryUpsertWithWhereUniqueWithoutStudentSemesterPaymentInput[]
    createMany?: StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInputEnvelope
    set?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    delete?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    connect?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    update?: StudentSemesterPaymentHistoryUpdateWithWhereUniqueWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryUpdateWithWhereUniqueWithoutStudentSemesterPaymentInput[]
    updateMany?: StudentSemesterPaymentHistoryUpdateManyWithWhereWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryUpdateManyWithWhereWithoutStudentSemesterPaymentInput[]
    deleteMany?: StudentSemesterPaymentHistoryScalarWhereInput | StudentSemesterPaymentHistoryScalarWhereInput[]
  }

  export type StudentSemesterPaymentHistoryUncheckedUpdateManyWithoutStudentSemesterPaymentNestedInput = {
    create?: XOR<StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput> | StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput[] | StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput[]
    connectOrCreate?: StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput[]
    upsert?: StudentSemesterPaymentHistoryUpsertWithWhereUniqueWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryUpsertWithWhereUniqueWithoutStudentSemesterPaymentInput[]
    createMany?: StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInputEnvelope
    set?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    disconnect?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    delete?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    connect?: StudentSemesterPaymentHistoryWhereUniqueInput | StudentSemesterPaymentHistoryWhereUniqueInput[]
    update?: StudentSemesterPaymentHistoryUpdateWithWhereUniqueWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryUpdateWithWhereUniqueWithoutStudentSemesterPaymentInput[]
    updateMany?: StudentSemesterPaymentHistoryUpdateManyWithWhereWithoutStudentSemesterPaymentInput | StudentSemesterPaymentHistoryUpdateManyWithWhereWithoutStudentSemesterPaymentInput[]
    deleteMany?: StudentSemesterPaymentHistoryScalarWhereInput | StudentSemesterPaymentHistoryScalarWhereInput[]
  }

  export type StudentSemesterPaymentCreateNestedOneWithoutStudentSemesterPaymentHistoryInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentSemesterPaymentHistoryInput, StudentSemesterPaymentUncheckedCreateWithoutStudentSemesterPaymentHistoryInput>
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentSemesterPaymentHistoryInput
    connect?: StudentSemesterPaymentWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type StudentSemesterPaymentUpdateOneRequiredWithoutStudentSemesterPaymentHistoryNestedInput = {
    create?: XOR<StudentSemesterPaymentCreateWithoutStudentSemesterPaymentHistoryInput, StudentSemesterPaymentUncheckedCreateWithoutStudentSemesterPaymentHistoryInput>
    connectOrCreate?: StudentSemesterPaymentCreateOrConnectWithoutStudentSemesterPaymentHistoryInput
    upsert?: StudentSemesterPaymentUpsertWithoutStudentSemesterPaymentHistoryInput
    connect?: StudentSemesterPaymentWhereUniqueInput
    update?: XOR<XOR<StudentSemesterPaymentUpdateToOneWithWhereWithoutStudentSemesterPaymentHistoryInput, StudentSemesterPaymentUpdateWithoutStudentSemesterPaymentHistoryInput>, StudentSemesterPaymentUncheckedUpdateWithoutStudentSemesterPaymentHistoryInput>
  }

  export type StudentCreateNestedOneWithoutStudentAcademicInfosInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicInfosInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentAcademicInfosNestedInput = {
    create?: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentAcademicInfosInput
    upsert?: StudentUpsertWithoutStudentAcademicInfosInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentAcademicInfosInput, StudentUpdateWithoutStudentAcademicInfosInput>, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
  }

  export type NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SemesterRegistrationStatus | EnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SemesterRegistrationStatus[] | ListEnumSemesterRegistrationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSemesterRegistrationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.SemesterRegistrationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumSemesterRegistrationStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumWeekDaysFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDaysFilter<$PrismaModel> | $Enums.WeekDays
  }

  export type NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WeekDays | EnumWeekDaysFieldRefInput<$PrismaModel>
    in?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    notIn?: $Enums.WeekDays[] | ListEnumWeekDaysFieldRefInput<$PrismaModel>
    not?: NestedEnumWeekDaysWithAggregatesFilter<$PrismaModel> | $Enums.WeekDays
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWeekDaysFilter<$PrismaModel>
    _max?: NestedEnumWeekDaysFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentEnrolledCourseStatus | EnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StudentEnrolledCourseStatus[] | ListEnumStudentEnrolledCourseStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStudentEnrolledCourseStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.StudentEnrolledCourseStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumStudentEnrolledCourseStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumExamTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExamTypeNullableFilter<$PrismaModel> | $Enums.ExamType | null
  }

  export type NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamType | EnumExamTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ExamType[] | ListEnumExamTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumExamTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ExamType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumExamTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumExamTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableFilter<$PrismaModel> | $Enums.PaymentStatus | null
  }

  export type NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type StudentCreateWithoutAcademicSemesterInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentCreateManyAcademicSemesterInputEnvelope = {
    data: StudentCreateManyAcademicSemesterInput | StudentCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type SemesterRegistrationCreateWithoutAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationCreateManyAcademicSemesterInputEnvelope = {
    data: SemesterRegistrationCreateManyAcademicSemesterInput | SemesterRegistrationCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseCreateWithoutAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseCreateManyAcademicSemesterInputEnvelope = {
    data: StudentEnrolledCourseCreateManyAcademicSemesterInput | StudentEnrolledCourseCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkCreateManyAcademicSemesterInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyAcademicSemesterInput | StudentEnrolledCourseMarkCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterPaymentCreateWithoutAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryCreateNestedManyWithoutStudentSemesterPaymentInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUncheckedCreateNestedManyWithoutStudentSemesterPaymentInput
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentCreateManyAcademicSemesterInputEnvelope = {
    data: StudentSemesterPaymentCreateManyAcademicSemesterInput | StudentSemesterPaymentCreateManyAcademicSemesterInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcademicSemesterInput, StudentUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentCreateWithoutAcademicSemesterInput, StudentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcademicSemesterInput, StudentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    middleName?: StringFilter<"Student"> | string
    profileImage?: StringNullableFilter<"Student"> | string | null
    email?: StringFilter<"Student"> | string
    contactNo?: StringFilter<"Student"> | string
    gender?: StringFilter<"Student"> | string
    bloodGroup?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    academicSemesterId?: StringFilter<"Student"> | string
    academicDepartmentId?: StringFilter<"Student"> | string
    academicFacultyId?: StringFilter<"Student"> | string
  }

  export type SemesterRegistrationUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    update: XOR<SemesterRegistrationUpdateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<SemesterRegistrationCreateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: SemesterRegistrationWhereUniqueInput
    data: XOR<SemesterRegistrationUpdateWithoutAcademicSemesterInput, SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: SemesterRegistrationScalarWhereInput
    data: XOR<SemesterRegistrationUpdateManyMutationInput, SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type SemesterRegistrationScalarWhereInput = {
    AND?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
    OR?: SemesterRegistrationScalarWhereInput[]
    NOT?: SemesterRegistrationScalarWhereInput | SemesterRegistrationScalarWhereInput[]
    id?: StringFilter<"SemesterRegistration"> | string
    startDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    endDate?: DateTimeFilter<"SemesterRegistration"> | Date | string
    status?: EnumSemesterRegistrationStatusNullableFilter<"SemesterRegistration"> | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFilter<"SemesterRegistration"> | number
    maxCredit?: IntFilter<"SemesterRegistration"> | number
    createdAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"SemesterRegistration"> | Date | string
    academicSemesterId?: StringFilter<"SemesterRegistration"> | string
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentEnrolledCourseCreateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseScalarWhereInput = {
    AND?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
    OR?: StudentEnrolledCourseScalarWhereInput[]
    NOT?: StudentEnrolledCourseScalarWhereInput | StudentEnrolledCourseScalarWhereInput[]
    id?: StringFilter<"StudentEnrolledCourse"> | string
    createdAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourse"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourse"> | string
    courseId?: StringFilter<"StudentEnrolledCourse"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourse"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourse"> | string | null
    point?: FloatNullableFilter<"StudentEnrolledCourse"> | number | null
    totalMarks?: IntNullableFilter<"StudentEnrolledCourse"> | number | null
    status?: EnumStudentEnrolledCourseStatusNullableFilter<"StudentEnrolledCourse"> | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentEnrolledCourseMarkScalarWhereInput = {
    AND?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
    OR?: StudentEnrolledCourseMarkScalarWhereInput[]
    NOT?: StudentEnrolledCourseMarkScalarWhereInput | StudentEnrolledCourseMarkScalarWhereInput[]
    id?: StringFilter<"StudentEnrolledCourseMark"> | string
    createdAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    updatedAt?: DateTimeFilter<"StudentEnrolledCourseMark"> | Date | string
    studentId?: StringFilter<"StudentEnrolledCourseMark"> | string
    studentEnrolledCourseId?: StringFilter<"StudentEnrolledCourseMark"> | string
    academicSemesterId?: StringFilter<"StudentEnrolledCourseMark"> | string
    grade?: StringNullableFilter<"StudentEnrolledCourseMark"> | string | null
    marks?: IntNullableFilter<"StudentEnrolledCourseMark"> | number | null
    examType?: EnumExamTypeNullableFilter<"StudentEnrolledCourseMark"> | $Enums.ExamType | null
  }

  export type StudentSemesterPaymentUpsertWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    update: XOR<StudentSemesterPaymentUpdateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput>
    create: XOR<StudentSemesterPaymentCreateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedCreateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentUpdateWithWhereUniqueWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    data: XOR<StudentSemesterPaymentUpdateWithoutAcademicSemesterInput, StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentUpdateManyWithWhereWithoutAcademicSemesterInput = {
    where: StudentSemesterPaymentScalarWhereInput
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterInput>
  }

  export type StudentSemesterPaymentScalarWhereInput = {
    AND?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
    OR?: StudentSemesterPaymentScalarWhereInput[]
    NOT?: StudentSemesterPaymentScalarWhereInput | StudentSemesterPaymentScalarWhereInput[]
    id?: StringFilter<"StudentSemesterPayment"> | string
    createdAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPayment"> | Date | string
    studentId?: StringFilter<"StudentSemesterPayment"> | string
    academicSemesterId?: StringFilter<"StudentSemesterPayment"> | string
    fullPaymentAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    partialPaymentAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    totalDueAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    totalPaidAmount?: IntNullableFilter<"StudentSemesterPayment"> | number | null
    paymentStatus?: EnumPaymentStatusNullableFilter<"StudentSemesterPayment"> | $Enums.PaymentStatus | null
  }

  export type AcademicDepartmentCreateWithoutAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutAcademicFacultyInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentCreateManyAcademicFacultyInputEnvelope = {
    data: AcademicDepartmentCreateManyAcademicFacultyInput | AcademicDepartmentCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutAcademicFacultyInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicFacultyInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type StudentCreateManyAcademicFacultyInputEnvelope = {
    data: StudentCreateManyAcademicFacultyInput | StudentCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type FacultyCreateWithoutAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAcademicFacultyInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type FacultyCreateManyAcademicFacultyInputEnvelope = {
    data: FacultyCreateManyAcademicFacultyInput | FacultyCreateManyAcademicFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDepartmentUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AcademicDepartmentWhereUniqueInput
    update: XOR<AcademicDepartmentUpdateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<AcademicDepartmentCreateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: AcademicDepartmentWhereUniqueInput
    data: XOR<AcademicDepartmentUpdateWithoutAcademicFacultyInput, AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: AcademicDepartmentScalarWhereInput
    data: XOR<AcademicDepartmentUpdateManyMutationInput, AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type AcademicDepartmentScalarWhereInput = {
    AND?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
    OR?: AcademicDepartmentScalarWhereInput[]
    NOT?: AcademicDepartmentScalarWhereInput | AcademicDepartmentScalarWhereInput[]
    id?: StringFilter<"AcademicDepartment"> | string
    title?: StringFilter<"AcademicDepartment"> | string
    createdAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicDepartment"> | Date | string
    academicFacultyId?: StringFilter<"AcademicDepartment"> | string
  }

  export type StudentUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcademicFacultyInput, StudentUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<StudentCreateWithoutAcademicFacultyInput, StudentUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcademicFacultyInput, StudentUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type FacultyUpsertWithWhereUniqueWithoutAcademicFacultyInput = {
    where: FacultyWhereUniqueInput
    update: XOR<FacultyUpdateWithoutAcademicFacultyInput, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
    create: XOR<FacultyCreateWithoutAcademicFacultyInput, FacultyUncheckedCreateWithoutAcademicFacultyInput>
  }

  export type FacultyUpdateWithWhereUniqueWithoutAcademicFacultyInput = {
    where: FacultyWhereUniqueInput
    data: XOR<FacultyUpdateWithoutAcademicFacultyInput, FacultyUncheckedUpdateWithoutAcademicFacultyInput>
  }

  export type FacultyUpdateManyWithWhereWithoutAcademicFacultyInput = {
    where: FacultyScalarWhereInput
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutAcademicFacultyInput>
  }

  export type FacultyScalarWhereInput = {
    AND?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    OR?: FacultyScalarWhereInput[]
    NOT?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    id?: StringFilter<"Faculty"> | string
    facultyId?: StringFilter<"Faculty"> | string
    firstName?: StringFilter<"Faculty"> | string
    lastName?: StringFilter<"Faculty"> | string
    middleName?: StringFilter<"Faculty"> | string
    profileImage?: StringFilter<"Faculty"> | string
    email?: StringFilter<"Faculty"> | string
    contactNo?: StringFilter<"Faculty"> | string
    gender?: StringFilter<"Faculty"> | string
    bloodGroup?: StringFilter<"Faculty"> | string
    designation?: StringFilter<"Faculty"> | string
    createdAt?: DateTimeFilter<"Faculty"> | Date | string
    updatedAt?: DateTimeFilter<"Faculty"> | Date | string
    academicDepartmentId?: StringFilter<"Faculty"> | string
    academicFacultyId?: StringFilter<"Faculty"> | string
  }

  export type AcademicFacultyCreateWithoutAcademicDepartmentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutAcademicDepartmentsInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
  }

  export type StudentCreateWithoutAcademicDepartmentInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAcademicDepartmentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type StudentCreateManyAcademicDepartmentInputEnvelope = {
    data: StudentCreateManyAcademicDepartmentInput | StudentCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type FacultyCreateWithoutAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFacultyId: string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAcademicDepartmentInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type FacultyCreateManyAcademicDepartmentInputEnvelope = {
    data: FacultyCreateManyAcademicDepartmentInput | FacultyCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseCreateWithoutAcademicDepartmentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseCreateManyAcademicDepartmentInputEnvelope = {
    data: OfferedCourseCreateManyAcademicDepartmentInput | OfferedCourseCreateManyAcademicDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicFacultyUpsertWithoutAcademicDepartmentsInput = {
    update: XOR<AcademicFacultyUpdateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
    create: XOR<AcademicFacultyCreateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedCreateWithoutAcademicDepartmentsInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutAcademicDepartmentsInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutAcademicDepartmentsInput, AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput>
  }

  export type AcademicFacultyUpdateWithoutAcademicDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutAcademicDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAcademicDepartmentInput, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<StudentCreateWithoutAcademicDepartmentInput, StudentUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAcademicDepartmentInput, StudentUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type StudentUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type FacultyUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: FacultyWhereUniqueInput
    update: XOR<FacultyUpdateWithoutAcademicDepartmentInput, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<FacultyCreateWithoutAcademicDepartmentInput, FacultyUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type FacultyUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: FacultyWhereUniqueInput
    data: XOR<FacultyUpdateWithoutAcademicDepartmentInput, FacultyUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type FacultyUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: FacultyScalarWhereInput
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutAcademicDepartmentInput, OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput>
    create: XOR<OfferedCourseCreateWithoutAcademicDepartmentInput, OfferedCourseUncheckedCreateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutAcademicDepartmentInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutAcademicDepartmentInput, OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutAcademicDepartmentInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentInput>
  }

  export type OfferedCourseScalarWhereInput = {
    AND?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
    OR?: OfferedCourseScalarWhereInput[]
    NOT?: OfferedCourseScalarWhereInput | OfferedCourseScalarWhereInput[]
    id?: StringFilter<"OfferedCourse"> | string
    createdAt?: DateTimeFilter<"OfferedCourse"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourse"> | Date | string
    courseId?: StringFilter<"OfferedCourse"> | string
    academicDepartmentId?: StringFilter<"OfferedCourse"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourse"> | string
  }

  export type AcademicSemesterCreateWithoutStudentsInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentsInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
  }

  export type AcademicDepartmentCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFacultyId: string
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutStudentsInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
  }

  export type AcademicFacultyCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutStudentsInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
  }

  export type StudentSemesterRegistrationCreateWithoutStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateWithoutStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCreateManyStudentInputEnvelope = {
    data: StudentSemesterRegistrationCreateManyStudentInput | StudentSemesterRegistrationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutStudentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput = {
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyStudentInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyStudentInput | StudentSemesterRegistrationCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicSemesterId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseCreateManyStudentInputEnvelope = {
    data: StudentEnrolledCourseCreateManyStudentInput | StudentEnrolledCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseMarkCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
    studentEnrolledCourse: StudentEnrolledCourseCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentEnrolledCourseId: string
    academicSemesterId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkCreateManyStudentInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyStudentInput | StudentEnrolledCourseMarkCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterPaymentCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryCreateNestedManyWithoutStudentSemesterPaymentInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUncheckedCreateNestedManyWithoutStudentSemesterPaymentInput
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterPaymentCreateManyStudentInputEnvelope = {
    data: StudentSemesterPaymentCreateManyStudentInput | StudentSemesterPaymentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAcademicInfoCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredit?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoUncheckedCreateWithoutStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredit?: number | null
    cgpa?: number | null
  }

  export type StudentAcademicInfoCreateOrConnectWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    create: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicInfoCreateManyStudentInputEnvelope = {
    data: StudentAcademicInfoCreateManyStudentInput | StudentAcademicInfoCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AcademicSemesterUpsertWithoutStudentsInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentsInput, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicSemesterCreateWithoutStudentsInput, AcademicSemesterUncheckedCreateWithoutStudentsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentsInput, AcademicSemesterUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicSemesterUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicDepartmentUpsertWithoutStudentsInput = {
    update: XOR<AcademicDepartmentUpdateWithoutStudentsInput, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicDepartmentCreateWithoutStudentsInput, AcademicDepartmentUncheckedCreateWithoutStudentsInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutStudentsInput, AcademicDepartmentUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicDepartmentUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicFacultyUpsertWithoutStudentsInput = {
    update: XOR<AcademicFacultyUpdateWithoutStudentsInput, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
    create: XOR<AcademicFacultyCreateWithoutStudentsInput, AcademicFacultyUncheckedCreateWithoutStudentsInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutStudentsInput, AcademicFacultyUncheckedUpdateWithoutStudentsInput>
  }

  export type AcademicFacultyUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type StudentSemesterRegistrationUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    update: XOR<StudentSemesterRegistrationUpdateWithoutStudentInput, StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterRegistrationCreateWithoutStudentInput, StudentSemesterRegistrationUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    data: XOR<StudentSemesterRegistrationUpdateWithoutStudentInput, StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterRegistrationScalarWhereInput
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterRegistrationScalarWhereInput = {
    AND?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
    OR?: StudentSemesterRegistrationScalarWhereInput[]
    NOT?: StudentSemesterRegistrationScalarWhereInput | StudentSemesterRegistrationScalarWhereInput[]
    id?: StringFilter<"StudentSemesterRegistration"> | string
    isConfirmed?: BoolNullableFilter<"StudentSemesterRegistration"> | boolean | null
    totalCreditsTaken?: IntNullableFilter<"StudentSemesterRegistration"> | number | null
    createdAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistration"> | Date | string
    studentId?: StringFilter<"StudentSemesterRegistration"> | string
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistration"> | string
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutStudentInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterRegistrationCourseScalarWhereInput = {
    AND?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
    OR?: StudentSemesterRegistrationCourseScalarWhereInput[]
    NOT?: StudentSemesterRegistrationCourseScalarWhereInput | StudentSemesterRegistrationCourseScalarWhereInput[]
    semesterRegistrationId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    studentId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    offeredCourseSectionId?: StringFilter<"StudentSemesterRegistrationCourse"> | string
    createdAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterRegistrationCourse"> | Date | string
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutStudentInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrolledCourseCreateWithoutStudentInput, StudentEnrolledCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutStudentInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    update: XOR<StudentSemesterPaymentUpdateWithoutStudentInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSemesterPaymentCreateWithoutStudentInput, StudentSemesterPaymentUncheckedCreateWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    data: XOR<StudentSemesterPaymentUpdateWithoutStudentInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSemesterPaymentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSemesterPaymentScalarWhereInput
    data: XOR<StudentSemesterPaymentUpdateManyMutationInput, StudentSemesterPaymentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicInfoUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    update: XOR<StudentAcademicInfoUpdateWithoutStudentInput, StudentAcademicInfoUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAcademicInfoCreateWithoutStudentInput, StudentAcademicInfoUncheckedCreateWithoutStudentInput>
  }

  export type StudentAcademicInfoUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAcademicInfoWhereUniqueInput
    data: XOR<StudentAcademicInfoUpdateWithoutStudentInput, StudentAcademicInfoUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAcademicInfoUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAcademicInfoScalarWhereInput
    data: XOR<StudentAcademicInfoUpdateManyMutationInput, StudentAcademicInfoUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAcademicInfoScalarWhereInput = {
    AND?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
    OR?: StudentAcademicInfoScalarWhereInput[]
    NOT?: StudentAcademicInfoScalarWhereInput | StudentAcademicInfoScalarWhereInput[]
    id?: StringFilter<"StudentAcademicInfo"> | string
    createdAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    updatedAt?: DateTimeFilter<"StudentAcademicInfo"> | Date | string
    studentId?: StringFilter<"StudentAcademicInfo"> | string
    totalCompletedCredit?: IntNullableFilter<"StudentAcademicInfo"> | number | null
    cgpa?: FloatNullableFilter<"StudentAcademicInfo"> | number | null
  }

  export type AcademicDepartmentCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFacultyId: string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutFacultiesInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
  }

  export type AcademicFacultyCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartments?: AcademicDepartmentUncheckedCreateNestedManyWithoutAcademicFacultyInput
    students?: StudentUncheckedCreateNestedManyWithoutAcademicFacultyInput
  }

  export type AcademicFacultyCreateOrConnectWithoutFacultiesInput = {
    where: AcademicFacultyWhereUniqueInput
    create: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
  }

  export type CourseFacultyCreateWithoutFacultyInput = {
    course: CourseCreateNestedOneWithoutFacultiesInput
  }

  export type CourseFacultyUncheckedCreateWithoutFacultyInput = {
    courseId: string
  }

  export type CourseFacultyCreateOrConnectWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    create: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput>
  }

  export type CourseFacultyCreateManyFacultyInputEnvelope = {
    data: CourseFacultyCreateManyFacultyInput | CourseFacultyCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseClassScheduleCreateWithoutFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleCreateManyFacultyInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyFacultyInput | OfferedCourseClassScheduleCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AcademicDepartmentUpsertWithoutFacultiesInput = {
    update: XOR<AcademicDepartmentUpdateWithoutFacultiesInput, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
    create: XOR<AcademicDepartmentCreateWithoutFacultiesInput, AcademicDepartmentUncheckedCreateWithoutFacultiesInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutFacultiesInput, AcademicDepartmentUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicDepartmentUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicFacultyUpsertWithoutFacultiesInput = {
    update: XOR<AcademicFacultyUpdateWithoutFacultiesInput, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
    create: XOR<AcademicFacultyCreateWithoutFacultiesInput, AcademicFacultyUncheckedCreateWithoutFacultiesInput>
    where?: AcademicFacultyWhereInput
  }

  export type AcademicFacultyUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: AcademicFacultyWhereInput
    data: XOR<AcademicFacultyUpdateWithoutFacultiesInput, AcademicFacultyUncheckedUpdateWithoutFacultiesInput>
  }

  export type AcademicFacultyUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type AcademicFacultyUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartments?: AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
    students?: StudentUncheckedUpdateManyWithoutAcademicFacultyNestedInput
  }

  export type CourseFacultyUpsertWithWhereUniqueWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    update: XOR<CourseFacultyUpdateWithoutFacultyInput, CourseFacultyUncheckedUpdateWithoutFacultyInput>
    create: XOR<CourseFacultyCreateWithoutFacultyInput, CourseFacultyUncheckedCreateWithoutFacultyInput>
  }

  export type CourseFacultyUpdateWithWhereUniqueWithoutFacultyInput = {
    where: CourseFacultyWhereUniqueInput
    data: XOR<CourseFacultyUpdateWithoutFacultyInput, CourseFacultyUncheckedUpdateWithoutFacultyInput>
  }

  export type CourseFacultyUpdateManyWithWhereWithoutFacultyInput = {
    where: CourseFacultyScalarWhereInput
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyWithoutFacultyInput>
  }

  export type CourseFacultyScalarWhereInput = {
    AND?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
    OR?: CourseFacultyScalarWhereInput[]
    NOT?: CourseFacultyScalarWhereInput | CourseFacultyScalarWhereInput[]
    courseId?: StringFilter<"CourseFaculty"> | string
    facultyId?: StringFilter<"CourseFaculty"> | string
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedCreateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutFacultyInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutFacultyInput, OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutFacultyInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyInput>
  }

  export type OfferedCourseClassScheduleScalarWhereInput = {
    AND?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
    OR?: OfferedCourseClassScheduleScalarWhereInput[]
    NOT?: OfferedCourseClassScheduleScalarWhereInput | OfferedCourseClassScheduleScalarWhereInput[]
    id?: StringFilter<"OfferedCourseClassSchedule"> | string
    startTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    endTime?: StringFilter<"OfferedCourseClassSchedule"> | string
    dayOfWeek?: EnumWeekDaysFilter<"OfferedCourseClassSchedule"> | $Enums.WeekDays
    createdAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseClassSchedule"> | Date | string
    offeredCourseSectionId?: StringFilter<"OfferedCourseClassSchedule"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseClassSchedule"> | string
    roomId?: StringFilter<"OfferedCourseClassSchedule"> | string
    facultyId?: StringFilter<"OfferedCourseClassSchedule"> | string
  }

  export type RoomCreateWithoutBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomCreateManyBuildingInputEnvelope = {
    data: RoomCreateManyBuildingInput | RoomCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
  }

  export type RoomUpdateManyWithWhereWithoutBuildingInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutBuildingInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    buildingId?: StringFilter<"Room"> | string
  }

  export type BuildingCreateWithoutRoomsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUncheckedCreateWithoutRoomsInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingCreateOrConnectWithoutRoomsInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleCreateManyRoomInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyRoomInput | OfferedCourseClassScheduleCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type BuildingUpsertWithoutRoomsInput = {
    update: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    where?: BuildingWhereInput
  }

  export type BuildingUpdateToOneWithWhereWithoutRoomsInput = {
    where?: BuildingWhereInput
    data: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type BuildingUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutRoomInput, OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutRoomInput, OfferedCourseClassScheduleUncheckedCreateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutRoomInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutRoomInput, OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutRoomInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomInput>
  }

  export type CourseToPrerequisiteCreateWithoutCourseInput = {
    preRequisite: CourseCreateNestedOneWithoutPreRequisiteForInput
  }

  export type CourseToPrerequisiteUncheckedCreateWithoutCourseInput = {
    preRequisiteId: string
  }

  export type CourseToPrerequisiteCreateOrConnectWithoutCourseInput = {
    where: CourseToPrerequisiteWhereUniqueInput
    create: XOR<CourseToPrerequisiteCreateWithoutCourseInput, CourseToPrerequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CourseToPrerequisiteCreateManyCourseInputEnvelope = {
    data: CourseToPrerequisiteCreateManyCourseInput | CourseToPrerequisiteCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseToPrerequisiteCreateWithoutPreRequisiteInput = {
    course: CourseCreateNestedOneWithoutPreRequisiteInput
  }

  export type CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput = {
    courseId: string
  }

  export type CourseToPrerequisiteCreateOrConnectWithoutPreRequisiteInput = {
    where: CourseToPrerequisiteWhereUniqueInput
    create: XOR<CourseToPrerequisiteCreateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseToPrerequisiteCreateManyPreRequisiteInputEnvelope = {
    data: CourseToPrerequisiteCreateManyPreRequisiteInput | CourseToPrerequisiteCreateManyPreRequisiteInput[]
    skipDuplicates?: boolean
  }

  export type CourseFacultyCreateWithoutCourseInput = {
    faculty: FacultyCreateNestedOneWithoutCoursesInput
  }

  export type CourseFacultyUncheckedCreateWithoutCourseInput = {
    facultyId: string
  }

  export type CourseFacultyCreateOrConnectWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    create: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput>
  }

  export type CourseFacultyCreateManyCourseInputEnvelope = {
    data: CourseFacultyCreateManyCourseInput | CourseFacultyCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseCreateWithoutCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput>
  }

  export type OfferedCourseCreateManyCourseInputEnvelope = {
    data: OfferedCourseCreateManyCourseInput | OfferedCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentEnrolledCourseCreateWithoutCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentEnrolledCourseInput
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentEnrolledCourseCreateManyCourseInputEnvelope = {
    data: StudentEnrolledCourseCreateManyCourseInput | StudentEnrolledCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseToPrerequisiteUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseToPrerequisiteWhereUniqueInput
    update: XOR<CourseToPrerequisiteUpdateWithoutCourseInput, CourseToPrerequisiteUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseToPrerequisiteCreateWithoutCourseInput, CourseToPrerequisiteUncheckedCreateWithoutCourseInput>
  }

  export type CourseToPrerequisiteUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseToPrerequisiteWhereUniqueInput
    data: XOR<CourseToPrerequisiteUpdateWithoutCourseInput, CourseToPrerequisiteUncheckedUpdateWithoutCourseInput>
  }

  export type CourseToPrerequisiteUpdateManyWithWhereWithoutCourseInput = {
    where: CourseToPrerequisiteScalarWhereInput
    data: XOR<CourseToPrerequisiteUpdateManyMutationInput, CourseToPrerequisiteUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseToPrerequisiteScalarWhereInput = {
    AND?: CourseToPrerequisiteScalarWhereInput | CourseToPrerequisiteScalarWhereInput[]
    OR?: CourseToPrerequisiteScalarWhereInput[]
    NOT?: CourseToPrerequisiteScalarWhereInput | CourseToPrerequisiteScalarWhereInput[]
    courseId?: StringFilter<"CourseToPrerequisite"> | string
    preRequisiteId?: StringFilter<"CourseToPrerequisite"> | string
  }

  export type CourseToPrerequisiteUpsertWithWhereUniqueWithoutPreRequisiteInput = {
    where: CourseToPrerequisiteWhereUniqueInput
    update: XOR<CourseToPrerequisiteUpdateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedUpdateWithoutPreRequisiteInput>
    create: XOR<CourseToPrerequisiteCreateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseToPrerequisiteUpdateWithWhereUniqueWithoutPreRequisiteInput = {
    where: CourseToPrerequisiteWhereUniqueInput
    data: XOR<CourseToPrerequisiteUpdateWithoutPreRequisiteInput, CourseToPrerequisiteUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseToPrerequisiteUpdateManyWithWhereWithoutPreRequisiteInput = {
    where: CourseToPrerequisiteScalarWhereInput
    data: XOR<CourseToPrerequisiteUpdateManyMutationInput, CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteInput>
  }

  export type CourseFacultyUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    update: XOR<CourseFacultyUpdateWithoutCourseInput, CourseFacultyUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseFacultyCreateWithoutCourseInput, CourseFacultyUncheckedCreateWithoutCourseInput>
  }

  export type CourseFacultyUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseFacultyWhereUniqueInput
    data: XOR<CourseFacultyUpdateWithoutCourseInput, CourseFacultyUncheckedUpdateWithoutCourseInput>
  }

  export type CourseFacultyUpdateManyWithWhereWithoutCourseInput = {
    where: CourseFacultyScalarWhereInput
    data: XOR<CourseFacultyUpdateManyMutationInput, CourseFacultyUncheckedUpdateManyWithoutCourseInput>
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutCourseInput, OfferedCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<OfferedCourseCreateWithoutCourseInput, OfferedCourseUncheckedCreateWithoutCourseInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutCourseInput, OfferedCourseUncheckedUpdateWithoutCourseInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutCourseInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    update: XOR<StudentEnrolledCourseUpdateWithoutCourseInput, StudentEnrolledCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentEnrolledCourseCreateWithoutCourseInput, StudentEnrolledCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    data: XOR<StudentEnrolledCourseUpdateWithoutCourseInput, StudentEnrolledCourseUncheckedUpdateWithoutCourseInput>
  }

  export type StudentEnrolledCourseUpdateManyWithWhereWithoutCourseInput = {
    where: StudentEnrolledCourseScalarWhereInput
    data: XOR<StudentEnrolledCourseUpdateManyMutationInput, StudentEnrolledCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseCreateWithoutPreRequisiteInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisiteFor?: CourseToPrerequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPreRequisiteInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisiteFor?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPreRequisiteInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
  }

  export type CourseCreateWithoutPreRequisiteForInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteCreateNestedManyWithoutCourseInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPreRequisiteForInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutCourseInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPreRequisiteForInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
  }

  export type CourseUpsertWithoutPreRequisiteInput = {
    update: XOR<CourseUpdateWithoutPreRequisiteInput, CourseUncheckedUpdateWithoutPreRequisiteInput>
    create: XOR<CourseCreateWithoutPreRequisiteInput, CourseUncheckedCreateWithoutPreRequisiteInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPreRequisiteInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPreRequisiteInput, CourseUncheckedUpdateWithoutPreRequisiteInput>
  }

  export type CourseUpdateWithoutPreRequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisiteFor?: CourseToPrerequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPreRequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisiteFor?: CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUpsertWithoutPreRequisiteForInput = {
    update: XOR<CourseUpdateWithoutPreRequisiteForInput, CourseUncheckedUpdateWithoutPreRequisiteForInput>
    create: XOR<CourseCreateWithoutPreRequisiteForInput, CourseUncheckedCreateWithoutPreRequisiteForInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutPreRequisiteForInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutPreRequisiteForInput, CourseUncheckedUpdateWithoutPreRequisiteForInput>
  }

  export type CourseUpdateWithoutPreRequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUpdateManyWithoutCourseNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPreRequisiteForInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutFacultiesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteCreateNestedManyWithoutPreRequisiteInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutFacultiesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFacultiesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
  }

  export type FacultyCreateWithoutCoursesInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutCoursesInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    academicFacultyId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutCoursesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
  }

  export type CourseUpsertWithoutFacultiesInput = {
    update: XOR<CourseUpdateWithoutFacultiesInput, CourseUncheckedUpdateWithoutFacultiesInput>
    create: XOR<CourseCreateWithoutFacultiesInput, CourseUncheckedCreateWithoutFacultiesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFacultiesInput, CourseUncheckedUpdateWithoutFacultiesInput>
  }

  export type CourseUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUpdateManyWithoutPreRequisiteNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FacultyUpsertWithoutCoursesInput = {
    update: XOR<FacultyUpdateWithoutCoursesInput, FacultyUncheckedUpdateWithoutCoursesInput>
    create: XOR<FacultyCreateWithoutCoursesInput, FacultyUncheckedCreateWithoutCoursesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutCoursesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutCoursesInput, FacultyUncheckedUpdateWithoutCoursesInput>
  }

  export type FacultyUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type AcademicSemesterCreateWithoutSemesterRegistrationsInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutSemesterRegistrationsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
  }

  export type OfferedCourseCreateWithoutSemesterRegistrationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicDepartmentId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseCreateManySemesterRegistrationInput | OfferedCourseCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseSectionCreateWithoutSemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseSectionCreateManySemesterRegistrationInput | OfferedCourseSectionCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleCreateManySemesterRegistrationInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManySemesterRegistrationInput | OfferedCourseClassScheduleCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationsInput
  }

  export type StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterRegistrationCreateOrConnectWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCreateManySemesterRegistrationInputEnvelope = {
    data: StudentSemesterRegistrationCreateManySemesterRegistrationInput | StudentSemesterRegistrationCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput = {
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseCreateManySemesterRegistrationInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput | StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput[]
    skipDuplicates?: boolean
  }

  export type AcademicSemesterUpsertWithoutSemesterRegistrationsInput = {
    update: XOR<AcademicSemesterUpdateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
    create: XOR<AcademicSemesterCreateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedCreateWithoutSemesterRegistrationsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutSemesterRegistrationsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutSemesterRegistrationsInput, AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput>
  }

  export type AcademicSemesterUpdateWithoutSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type OfferedCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    update: XOR<OfferedCourseUpdateWithoutSemesterRegistrationInput, OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseCreateWithoutSemesterRegistrationInput, OfferedCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseWhereUniqueInput
    data: XOR<OfferedCourseUpdateWithoutSemesterRegistrationInput, OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseScalarWhereInput
    data: XOR<OfferedCourseUpdateManyMutationInput, OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    update: XOR<OfferedCourseSectionUpdateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseSectionCreateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionWhereUniqueInput
    data: XOR<OfferedCourseSectionUpdateWithoutSemesterRegistrationInput, OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseSectionScalarWhereInput
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseSectionScalarWhereInput = {
    AND?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
    OR?: OfferedCourseSectionScalarWhereInput[]
    NOT?: OfferedCourseSectionScalarWhereInput | OfferedCourseSectionScalarWhereInput[]
    id?: StringFilter<"OfferedCourseSection"> | string
    title?: StringFilter<"OfferedCourseSection"> | string
    maxCapacity?: IntFilter<"OfferedCourseSection"> | number
    currentlyEnrolledStudent?: IntFilter<"OfferedCourseSection"> | number
    createdAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    updatedAt?: DateTimeFilter<"OfferedCourseSection"> | Date | string
    offeredCourseId?: StringFilter<"OfferedCourseSection"> | string
    semesterRegistrationId?: StringFilter<"OfferedCourseSection"> | string
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput, OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    update: XOR<StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<StudentSemesterRegistrationCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationWhereUniqueInput
    data: XOR<StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationScalarWhereInput
    data: XOR<StudentSemesterRegistrationUpdateManyMutationInput, StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutSemesterRegistrationInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationInput>
  }

  export type CourseCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutOfferedCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type AcademicDepartmentCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFaculty: AcademicFacultyCreateNestedOneWithoutAcademicDepartmentsInput
    students?: StudentCreateNestedManyWithoutAcademicDepartmentInput
    faculties?: FacultyCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFacultyId: string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicDepartmentInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutAcademicDepartmentInput
  }

  export type AcademicDepartmentCreateOrConnectWithoutOfferedCoursesInput = {
    where: AcademicDepartmentWhereUniqueInput
    create: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCoursesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
  }

  export type OfferedCourseSectionCreateWithoutOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionCreateManyOfferedCourseInputEnvelope = {
    data: OfferedCourseSectionCreateManyOfferedCourseInput | OfferedCourseSectionCreateManyOfferedCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourseSection: OfferedCourseSectionCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyOfferedCourseInput | StudentSemesterRegistrationCourseCreateManyOfferedCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutOfferedCoursesInput = {
    update: XOR<CourseUpdateWithoutOfferedCoursesInput, CourseUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<CourseCreateWithoutOfferedCoursesInput, CourseUncheckedCreateWithoutOfferedCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutOfferedCoursesInput, CourseUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type CourseUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicDepartmentUpsertWithoutOfferedCoursesInput = {
    update: XOR<AcademicDepartmentUpdateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<AcademicDepartmentCreateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedCreateWithoutOfferedCoursesInput>
    where?: AcademicDepartmentWhereInput
  }

  export type AcademicDepartmentUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: AcademicDepartmentWhereInput
    data: XOR<AcademicDepartmentUpdateWithoutOfferedCoursesInput, AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type AcademicDepartmentUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutAcademicDepartmentsNestedInput
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type SemesterRegistrationUpsertWithoutOfferedCoursesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCoursesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCoursesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCoursesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type OfferedCourseSectionUpsertWithWhereUniqueWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    update: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput>
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionUpdateWithWhereUniqueWithoutOfferedCourseInput = {
    where: OfferedCourseSectionWhereUniqueInput
    data: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput>
  }

  export type OfferedCourseSectionUpdateManyWithWhereWithoutOfferedCourseInput = {
    where: OfferedCourseSectionScalarWhereInput
    data: XOR<OfferedCourseSectionUpdateManyMutationInput, OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseInput>
  }

  export type OfferedCourseCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicDepartmentId: string
    semesterRegistrationId: string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutOfferedCourseSectionsInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCourseSectionsInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    room: RoomCreateNestedOneWithoutOfferedCourseClassSchedulesInput
    faculty: FacultyCreateNestedOneWithoutOfferedCourseClassSchedulesInput
  }

  export type OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleCreateOrConnectWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    create: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleCreateManyOfferedCourseSectionInputEnvelope = {
    data: OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput | OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput[]
    skipDuplicates?: boolean
  }

  export type StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    student: StudentCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
    offeredCourse: OfferedCourseCreateNestedOneWithoutStudentSemesterRegistrationCoursesInput
  }

  export type StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSemesterRegistrationCourseCreateOrConnectWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInputEnvelope = {
    data: StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput | StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput[]
    skipDuplicates?: boolean
  }

  export type OfferedCourseUpsertWithoutOfferedCourseSectionsInput = {
    update: XOR<OfferedCourseUpdateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
    create: XOR<OfferedCourseCreateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedCreateWithoutOfferedCourseSectionsInput>
    where?: OfferedCourseWhereInput
  }

  export type OfferedCourseUpdateToOneWithWhereWithoutOfferedCourseSectionsInput = {
    where?: OfferedCourseWhereInput
    data: XOR<OfferedCourseUpdateWithoutOfferedCourseSectionsInput, OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type OfferedCourseUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type SemesterRegistrationUpsertWithoutOfferedCourseSectionsInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseSectionsInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseSectionsInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCourseSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type OfferedCourseClassScheduleUpsertWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    update: XOR<OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput>
    create: XOR<OfferedCourseClassScheduleCreateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleUpdateWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleWhereUniqueInput
    data: XOR<OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput, OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseClassScheduleUpdateManyWithWhereWithoutOfferedCourseSectionInput = {
    where: OfferedCourseClassScheduleScalarWhereInput
    data: XOR<OfferedCourseClassScheduleUpdateManyMutationInput, OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpsertWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    update: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput>
    create: XOR<StudentSemesterRegistrationCourseCreateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedCreateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpdateWithWhereUniqueWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseWhereUniqueInput
    data: XOR<StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput, StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput>
  }

  export type StudentSemesterRegistrationCourseUpdateManyWithWhereWithoutOfferedCourseSectionInput = {
    where: StudentSemesterRegistrationCourseScalarWhereInput
    data: XOR<StudentSemesterRegistrationCourseUpdateManyMutationInput, StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionInput>
  }

  export type OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
    semesterRegistrationId: string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    buildingId: string
  }

  export type RoomCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutFacultiesInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutFacultiesInput
    courses?: CourseFacultyCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    academicFacultyId: string
    courses?: CourseFacultyUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutOfferedCourseClassSchedulesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
  }

  export type OfferedCourseSectionUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<OfferedCourseSectionCreateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: OfferedCourseSectionWhereInput
    data: XOR<OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput, OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type OfferedCourseSectionUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type SemesterRegistrationUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<SemesterRegistrationCreateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput, SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type SemesterRegistrationUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type RoomUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<RoomUpdateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<RoomCreateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutOfferedCourseClassSchedulesInput, RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type RoomUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buildingId?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyUpsertWithoutOfferedCourseClassSchedulesInput = {
    update: XOR<FacultyUpdateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
    create: XOR<FacultyCreateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedCreateWithoutOfferedCourseClassSchedulesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutOfferedCourseClassSchedulesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutOfferedCourseClassSchedulesInput, FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput>
  }

  export type FacultyUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutOfferedCourseClassSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type StudentCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterRegistrationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationsInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
  }

  export type StudentUpsertWithoutStudentSemesterRegistrationsInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterRegistrationsInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationsInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterRegistrationsInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type StudentUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SemesterRegistrationUpsertWithoutStudentSemesterRegistrationsInput = {
    update: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationsInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationsInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput>
  }

  export type SemesterRegistrationUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutSemesterRegistrationsInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutSemesterRegistrationInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutSemesterRegistrationInput
  }

  export type SemesterRegistrationCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: SemesterRegistrationWhereUniqueInput
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutOfferedCoursesInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutOfferedCoursesInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCoursesInput
    offeredCourseSections?: OfferedCourseSectionCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicDepartmentId: string
    semesterRegistrationId: string
    offeredCourseSections?: OfferedCourseSectionUncheckedCreateNestedManyWithoutOfferedCourseInput
  }

  export type OfferedCourseCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: OfferedCourseWhereUniqueInput
    create: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourse: OfferedCourseCreateNestedOneWithoutOfferedCourseSectionsInput
    semesterRegistration: SemesterRegistrationCreateNestedOneWithoutOfferedCourseSectionsInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
    semesterRegistrationId: string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedCreateNestedManyWithoutOfferedCourseSectionInput
  }

  export type OfferedCourseSectionCreateOrConnectWithoutStudentSemesterRegistrationCoursesInput = {
    where: OfferedCourseSectionWhereUniqueInput
    create: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type SemesterRegistrationUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<SemesterRegistrationCreateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: SemesterRegistrationWhereInput
  }

  export type SemesterRegistrationUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: SemesterRegistrationWhereInput
    data: XOR<SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput, SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type SemesterRegistrationUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutSemesterRegistrationsNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type StudentUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<StudentCreateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterRegistrationCoursesInput, StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type StudentUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type OfferedCourseUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<OfferedCourseCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: OfferedCourseWhereInput
  }

  export type OfferedCourseUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: OfferedCourseWhereInput
    data: XOR<OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseSectionUpsertWithoutStudentSemesterRegistrationCoursesInput = {
    update: XOR<OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
    create: XOR<OfferedCourseSectionCreateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedCreateWithoutStudentSemesterRegistrationCoursesInput>
    where?: OfferedCourseSectionWhereInput
  }

  export type OfferedCourseSectionUpdateToOneWithWhereWithoutStudentSemesterRegistrationCoursesInput = {
    where?: OfferedCourseSectionWhereInput
    data: XOR<OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput, OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput>
  }

  export type OfferedCourseSectionUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutStudentSemesterRegistrationCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type StudentCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    title: string
    code: string
    credits?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    preRequisite?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutCourseInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedCreateNestedManyWithoutPreRequisiteInput
    faculties?: CourseFacultyUncheckedCreateNestedManyWithoutCourseInput
    offeredCourses?: OfferedCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type AcademicSemesterCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentEnrolledCoursesInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
    student: StudentCreateNestedOneWithoutStudentEnrolledCourseMarksInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCourseMarksInput
  }

  export type StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkCreateOrConnectWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInputEnvelope = {
    data: StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput | StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<StudentUpdateWithoutStudentEnrolledCoursesInput, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<StudentCreateWithoutStudentEnrolledCoursesInput, StudentUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentEnrolledCoursesInput, StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type StudentUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<CourseUpdateWithoutStudentEnrolledCoursesInput, CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<CourseCreateWithoutStudentEnrolledCoursesInput, CourseUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStudentEnrolledCoursesInput, CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type CourseUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    preRequisite?: CourseToPrerequisiteUncheckedUpdateManyWithoutCourseNestedInput
    preRequisiteFor?: CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteNestedInput
    faculties?: CourseFacultyUncheckedUpdateManyWithoutCourseNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentEnrolledCoursesInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCoursesInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCoursesInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput>
  }

  export type AcademicSemesterUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type StudentEnrolledCourseMarkUpsertWithWhereUniqueWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    update: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput>
    create: XOR<StudentEnrolledCourseMarkCreateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedCreateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkUpdateWithWhereUniqueWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkWhereUniqueInput
    data: XOR<StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput, StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput>
  }

  export type StudentEnrolledCourseMarkUpdateManyWithWhereWithoutStudentEnrolledCourseInput = {
    where: StudentEnrolledCourseMarkScalarWhereInput
    data: XOR<StudentEnrolledCourseMarkUpdateManyMutationInput, StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseInput>
  }

  export type StudentCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
    student: StudentCreateNestedOneWithoutStudentEnrolledCoursesInput
    course: CourseCreateNestedOneWithoutStudentEnrolledCoursesInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentEnrolledCoursesInput
  }

  export type StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
    academicSemesterId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: StudentEnrolledCourseWhereUniqueInput
    create: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentEnrolledCourseMarksInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<StudentUpdateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<StudentCreateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentEnrolledCourseMarksInput, StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentEnrolledCourseUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<StudentEnrolledCourseCreateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: StudentEnrolledCourseWhereInput
  }

  export type StudentEnrolledCourseUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: StudentEnrolledCourseWhereInput
    data: XOR<StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput, StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type StudentEnrolledCourseUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
  }

  export type AcademicSemesterUpsertWithoutStudentEnrolledCourseMarksInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
    create: XOR<AcademicSemesterCreateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedCreateWithoutStudentEnrolledCourseMarksInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentEnrolledCourseMarksInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput, AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput>
  }

  export type AcademicSemesterUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentEnrolledCourseMarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type StudentCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSemesterPaymentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput = {
    id?: string
    year: number
    title: string
    code: string
    startMonth: string
    endMonth: string
    isCurrent?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutAcademicSemesterInput
    semesterRegistrations?: SemesterRegistrationUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutAcademicSemesterInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutAcademicSemesterInput
  }

  export type AcademicSemesterCreateOrConnectWithoutStudentSemesterPaymentsInput = {
    where: AcademicSemesterWhereUniqueInput
    create: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId: string
    dueAmount?: number
    paidAmount?: number
    paymentMethod?: $Enums.PaymentMethod
    isPaid?: boolean | null
  }

  export type StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId: string
    dueAmount?: number
    paidAmount?: number
    paymentMethod?: $Enums.PaymentMethod
    isPaid?: boolean | null
  }

  export type StudentSemesterPaymentHistoryCreateOrConnectWithoutStudentSemesterPaymentInput = {
    where: StudentSemesterPaymentHistoryWhereUniqueInput
    create: XOR<StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput>
  }

  export type StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInputEnvelope = {
    data: StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInput | StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutStudentSemesterPaymentsInput = {
    update: XOR<StudentUpdateWithoutStudentSemesterPaymentsInput, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
    create: XOR<StudentCreateWithoutStudentSemesterPaymentsInput, StudentUncheckedCreateWithoutStudentSemesterPaymentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSemesterPaymentsInput, StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type StudentUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AcademicSemesterUpsertWithoutStudentSemesterPaymentsInput = {
    update: XOR<AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
    create: XOR<AcademicSemesterCreateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedCreateWithoutStudentSemesterPaymentsInput>
    where?: AcademicSemesterWhereInput
  }

  export type AcademicSemesterUpdateToOneWithWhereWithoutStudentSemesterPaymentsInput = {
    where?: AcademicSemesterWhereInput
    data: XOR<AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput, AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput>
  }

  export type AcademicSemesterUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type AcademicSemesterUncheckedUpdateWithoutStudentSemesterPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    startMonth?: StringFieldUpdateOperationsInput | string
    endMonth?: StringFieldUpdateOperationsInput | string
    isCurrent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    semesterRegistrations?: SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterNestedInput
  }

  export type StudentSemesterPaymentHistoryUpsertWithWhereUniqueWithoutStudentSemesterPaymentInput = {
    where: StudentSemesterPaymentHistoryWhereUniqueInput
    update: XOR<StudentSemesterPaymentHistoryUpdateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedUpdateWithoutStudentSemesterPaymentInput>
    create: XOR<StudentSemesterPaymentHistoryCreateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedCreateWithoutStudentSemesterPaymentInput>
  }

  export type StudentSemesterPaymentHistoryUpdateWithWhereUniqueWithoutStudentSemesterPaymentInput = {
    where: StudentSemesterPaymentHistoryWhereUniqueInput
    data: XOR<StudentSemesterPaymentHistoryUpdateWithoutStudentSemesterPaymentInput, StudentSemesterPaymentHistoryUncheckedUpdateWithoutStudentSemesterPaymentInput>
  }

  export type StudentSemesterPaymentHistoryUpdateManyWithWhereWithoutStudentSemesterPaymentInput = {
    where: StudentSemesterPaymentHistoryScalarWhereInput
    data: XOR<StudentSemesterPaymentHistoryUpdateManyMutationInput, StudentSemesterPaymentHistoryUncheckedUpdateManyWithoutStudentSemesterPaymentInput>
  }

  export type StudentSemesterPaymentHistoryScalarWhereInput = {
    AND?: StudentSemesterPaymentHistoryScalarWhereInput | StudentSemesterPaymentHistoryScalarWhereInput[]
    OR?: StudentSemesterPaymentHistoryScalarWhereInput[]
    NOT?: StudentSemesterPaymentHistoryScalarWhereInput | StudentSemesterPaymentHistoryScalarWhereInput[]
    id?: StringFilter<"StudentSemesterPaymentHistory"> | string
    createdAt?: DateTimeFilter<"StudentSemesterPaymentHistory"> | Date | string
    updatedAt?: DateTimeFilter<"StudentSemesterPaymentHistory"> | Date | string
    studentSemesterPaymentId?: StringFilter<"StudentSemesterPaymentHistory"> | string
    transactionId?: StringFilter<"StudentSemesterPaymentHistory"> | string
    dueAmount?: IntFilter<"StudentSemesterPaymentHistory"> | number
    paidAmount?: IntFilter<"StudentSemesterPaymentHistory"> | number
    paymentMethod?: EnumPaymentMethodFilter<"StudentSemesterPaymentHistory"> | $Enums.PaymentMethod
    isPaid?: BoolNullableFilter<"StudentSemesterPaymentHistory"> | boolean | null
  }

  export type StudentSemesterPaymentCreateWithoutStudentSemesterPaymentHistoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
    student: StudentCreateNestedOneWithoutStudentSemesterPaymentsInput
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentSemesterPaymentsInput
  }

  export type StudentSemesterPaymentUncheckedCreateWithoutStudentSemesterPaymentHistoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
  }

  export type StudentSemesterPaymentCreateOrConnectWithoutStudentSemesterPaymentHistoryInput = {
    where: StudentSemesterPaymentWhereUniqueInput
    create: XOR<StudentSemesterPaymentCreateWithoutStudentSemesterPaymentHistoryInput, StudentSemesterPaymentUncheckedCreateWithoutStudentSemesterPaymentHistoryInput>
  }

  export type StudentSemesterPaymentUpsertWithoutStudentSemesterPaymentHistoryInput = {
    update: XOR<StudentSemesterPaymentUpdateWithoutStudentSemesterPaymentHistoryInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentSemesterPaymentHistoryInput>
    create: XOR<StudentSemesterPaymentCreateWithoutStudentSemesterPaymentHistoryInput, StudentSemesterPaymentUncheckedCreateWithoutStudentSemesterPaymentHistoryInput>
    where?: StudentSemesterPaymentWhereInput
  }

  export type StudentSemesterPaymentUpdateToOneWithWhereWithoutStudentSemesterPaymentHistoryInput = {
    where?: StudentSemesterPaymentWhereInput
    data: XOR<StudentSemesterPaymentUpdateWithoutStudentSemesterPaymentHistoryInput, StudentSemesterPaymentUncheckedUpdateWithoutStudentSemesterPaymentHistoryInput>
  }

  export type StudentSemesterPaymentUpdateWithoutStudentSemesterPaymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutStudentSemesterPaymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
  }

  export type StudentCreateWithoutStudentAcademicInfosInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemester: AcademicSemesterCreateNestedOneWithoutStudentsInput
    academicDepartment: AcademicDepartmentCreateNestedOneWithoutStudentsInput
    academicFaculty: AcademicFacultyCreateNestedOneWithoutStudentsInput
    studentSemesterRegistrations?: StudentSemesterRegistrationCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentAcademicInfosInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
    academicFacultyId: string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedCreateNestedManyWithoutStudentInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedCreateNestedManyWithoutStudentInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentAcademicInfosInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
  }

  export type StudentUpsertWithoutStudentAcademicInfosInput = {
    update: XOR<StudentUpdateWithoutStudentAcademicInfosInput, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
    create: XOR<StudentCreateWithoutStudentAcademicInfosInput, StudentUncheckedCreateWithoutStudentAcademicInfosInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentAcademicInfosInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentAcademicInfosInput, StudentUncheckedUpdateWithoutStudentAcademicInfosInput>
  }

  export type StudentUpdateWithoutStudentAcademicInfosInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentAcademicInfosInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyAcademicSemesterInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    academicFacultyId: string
  }

  export type SemesterRegistrationCreateManyAcademicSemesterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.SemesterRegistrationStatus | null
    minCredit?: number
    maxCredit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentEnrolledCourseCreateManyAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    courseId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMarkCreateManyAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    studentEnrolledCourseId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentSemesterPaymentCreateManyAcademicSemesterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
  }

  export type StudentUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
  }

  export type SemesterRegistrationUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourses?: OfferedCourseUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationNestedInput
  }

  export type SemesterRegistrationUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumSemesterRegistrationStatusFieldUpdateOperationsInput | $Enums.SemesterRegistrationStatus | null
    minCredit?: IntFieldUpdateOperationsInput | number
    maxCredit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMarkUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentSemesterPaymentUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    student?: StudentUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUpdateManyWithoutStudentSemesterPaymentNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUncheckedUpdateManyWithoutStudentSemesterPaymentNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutAcademicSemesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
  }

  export type AcademicDepartmentCreateManyAcademicFacultyInput = {
    id?: string
    title: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyAcademicFacultyInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicDepartmentId: string
  }

  export type FacultyCreateManyAcademicFacultyInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
  }

  export type AcademicDepartmentUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutAcademicDepartmentNestedInput
    faculties?: FacultyUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
    offeredCourses?: OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentNestedInput
  }

  export type AcademicDepartmentUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutFacultiesNestedInput
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateManyAcademicDepartmentInput = {
    id?: string
    studentId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage?: string | null
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    academicFacultyId: string
  }

  export type FacultyCreateManyAcademicDepartmentInput = {
    id?: string
    facultyId: string
    firstName: string
    lastName: string
    middleName: string
    profileImage: string
    email: string
    contactNo: string
    gender: string
    bloodGroup: string
    designation: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicFacultyId: string
  }

  export type OfferedCourseCreateManyAcademicDepartmentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    semesterRegistrationId: string
  }

  export type StudentUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentsNestedInput
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutStudentsNestedInput
    studentSemesterRegistrations?: StudentSemesterRegistrationUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    studentSemesterRegistrations?: StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourses?: StudentEnrolledCourseUncheckedUpdateManyWithoutStudentNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentNestedInput
    studentSemesterPayments?: StudentSemesterPaymentUncheckedUpdateManyWithoutStudentNestedInput
    studentAcademicInfos?: StudentAcademicInfoUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
  }

  export type FacultyUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFaculty?: AcademicFacultyUpdateOneRequiredWithoutFacultiesNestedInput
    courses?: CourseFacultyUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
    courses?: CourseFacultyUncheckedUpdateManyWithoutFacultyNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    middleName?: StringFieldUpdateOperationsInput | string
    profileImage?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    contactNo?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    bloodGroup?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicFacultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutAcademicDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCreateManyStudentInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyStudentInput = {
    semesterRegistrationId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentEnrolledCourseCreateManyStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicSemesterId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMarkCreateManyStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentEnrolledCourseId: string
    academicSemesterId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentSemesterPaymentCreateManyStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSemesterId: string
    fullPaymentAmount?: number | null
    partialPaymentAmount?: number | null
    totalDueAmount?: number | null
    totalPaidAmount?: number | null
    paymentStatus?: $Enums.PaymentStatus | null
  }

  export type StudentAcademicInfoCreateManyStudentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    totalCompletedCredit?: number | null
    cgpa?: number | null
  }

  export type StudentSemesterRegistrationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutStudentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutStudentInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutStudentInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    course?: CourseUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
  }

  export type StudentEnrolledCourseMarkUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    studentEnrolledCourse?: StudentEnrolledCourseUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentEnrolledCourseId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentSemesterPaymentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentSemesterPaymentsNestedInput
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUpdateManyWithoutStudentSemesterPaymentNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
    StudentSemesterPaymentHistory?: StudentSemesterPaymentHistoryUncheckedUpdateManyWithoutStudentSemesterPaymentNestedInput
  }

  export type StudentSemesterPaymentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    fullPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    partialPaymentAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalDueAmount?: NullableIntFieldUpdateOperationsInput | number | null
    totalPaidAmount?: NullableIntFieldUpdateOperationsInput | number | null
    paymentStatus?: NullableEnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus | null
  }

  export type StudentAcademicInfoUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredit?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredit?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StudentAcademicInfoUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    totalCompletedCredit?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CourseFacultyCreateManyFacultyInput = {
    courseId: string
  }

  export type OfferedCourseClassScheduleCreateManyFacultyInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    roomId: string
  }

  export type CourseFacultyUpdateWithoutFacultyInput = {
    course?: CourseUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type CourseFacultyUncheckedUpdateWithoutFacultyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUncheckedUpdateManyWithoutFacultyInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCreateManyBuildingInput = {
    id?: string
    roomNumber: string
    floor: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleCreateManyRoomInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    semesterRegistrationId: string
    facultyId: string
  }

  export type OfferedCourseClassScheduleUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPrerequisiteCreateManyCourseInput = {
    preRequisiteId: string
  }

  export type CourseToPrerequisiteCreateManyPreRequisiteInput = {
    courseId: string
  }

  export type CourseFacultyCreateManyCourseInput = {
    facultyId: string
  }

  export type OfferedCourseCreateManyCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academicDepartmentId: string
    semesterRegistrationId: string
  }

  export type StudentEnrolledCourseCreateManyCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    grade?: string | null
    point?: number | null
    totalMarks?: number | null
    status?: $Enums.StudentEnrolledCourseStatus | null
  }

  export type CourseToPrerequisiteUpdateWithoutCourseInput = {
    preRequisite?: CourseUpdateOneRequiredWithoutPreRequisiteForNestedInput
  }

  export type CourseToPrerequisiteUncheckedUpdateWithoutCourseInput = {
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPrerequisiteUncheckedUpdateManyWithoutCourseInput = {
    preRequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPrerequisiteUpdateWithoutPreRequisiteInput = {
    course?: CourseUpdateOneRequiredWithoutPreRequisiteNestedInput
  }

  export type CourseToPrerequisiteUncheckedUpdateWithoutPreRequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseToPrerequisiteUncheckedUpdateManyWithoutPreRequisiteInput = {
    courseId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUpdateWithoutCourseInput = {
    faculty?: FacultyUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseFacultyUncheckedUpdateWithoutCourseInput = {
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFacultyUncheckedUpdateManyWithoutCourseInput = {
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentEnrolledCourseUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCoursesNestedInput
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
    studentEnrolledCourseMarks?: StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseNestedInput
  }

  export type StudentEnrolledCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    point?: NullableFloatFieldUpdateOperationsInput | number | null
    totalMarks?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableEnumStudentEnrolledCourseStatusFieldUpdateOperationsInput | $Enums.StudentEnrolledCourseStatus | null
  }

  export type OfferedCourseCreateManySemesterRegistrationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId: string
    academicDepartmentId: string
  }

  export type OfferedCourseSectionCreateManySemesterRegistrationInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseId: string
  }

  export type OfferedCourseClassScheduleCreateManySemesterRegistrationInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    offeredCourseSectionId: string
    roomId: string
    facultyId: string
  }

  export type StudentSemesterRegistrationCreateManySemesterRegistrationInput = {
    id?: string
    isConfirmed?: boolean | null
    totalCreditsTaken?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
  }

  export type StudentSemesterRegistrationCourseCreateManySemesterRegistrationInput = {
    studentId: string
    offeredCourseId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutOfferedCoursesNestedInput
    academicDepartment?: AcademicDepartmentUpdateOneRequiredWithoutOfferedCoursesNestedInput
    offeredCourseSections?: OfferedCourseSectionUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
    offeredCourseSections?: OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseNestedInput
  }

  export type OfferedCourseUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    academicDepartmentId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseSectionUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationsNestedInput
  }

  export type StudentSemesterRegistrationUncheckedUpdateWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isConfirmed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalCreditsTaken?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutSemesterRegistrationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutSemesterRegistrationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutSemesterRegistrationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseSectionCreateManyOfferedCourseInput = {
    id?: string
    title: string
    maxCapacity: number
    currentlyEnrolledStudent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseSectionId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseSectionUpdateWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseSectionsNestedInput
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    offeredCourseClassSchedules?: OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
    studentSemesterRegistrationCourses?: StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionNestedInput
  }

  export type OfferedCourseSectionUncheckedUpdateManyWithoutOfferedCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentlyEnrolledStudent?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourseSection?: OfferedCourseSectionUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseSectionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferedCourseClassScheduleCreateManyOfferedCourseSectionInput = {
    id?: string
    startTime: string
    endTime: string
    dayOfWeek?: $Enums.WeekDays
    createdAt?: Date | string
    updatedAt?: Date | string
    semesterRegistrationId: string
    roomId: string
    facultyId: string
  }

  export type StudentSemesterRegistrationCourseCreateManyOfferedCourseSectionInput = {
    semesterRegistrationId: string
    studentId: string
    offeredCourseId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferedCourseClassScheduleUpdateWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    room?: RoomUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
    faculty?: FacultyUpdateOneRequiredWithoutOfferedCourseClassSchedulesNestedInput
  }

  export type OfferedCourseClassScheduleUncheckedUpdateWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type OfferedCourseClassScheduleUncheckedUpdateManyWithoutOfferedCourseSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumWeekDaysFieldUpdateOperationsInput | $Enums.WeekDays
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentSemesterRegistrationCourseUpdateWithoutOfferedCourseSectionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    semesterRegistration?: SemesterRegistrationUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    student?: StudentUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
    offeredCourse?: OfferedCourseUpdateOneRequiredWithoutStudentSemesterRegistrationCoursesNestedInput
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateWithoutOfferedCourseSectionInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSemesterRegistrationCourseUncheckedUpdateManyWithoutOfferedCourseSectionInput = {
    semesterRegistrationId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    offeredCourseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentEnrolledCourseMarkCreateManyStudentEnrolledCourseInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentId: string
    academicSemesterId: string
    grade?: string | null
    marks?: number | null
    examType?: $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkUpdateWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
    student?: StudentUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
    academicSemester?: AcademicSemesterUpdateOneRequiredWithoutStudentEnrolledCourseMarksNestedInput
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentEnrolledCourseMarkUncheckedUpdateManyWithoutStudentEnrolledCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicSemesterId?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    examType?: NullableEnumExamTypeFieldUpdateOperationsInput | $Enums.ExamType | null
  }

  export type StudentSemesterPaymentHistoryCreateManyStudentSemesterPaymentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionId: string
    dueAmount?: number
    paidAmount?: number
    paymentMethod?: $Enums.PaymentMethod
    isPaid?: boolean | null
  }

  export type StudentSemesterPaymentHistoryUpdateWithoutStudentSemesterPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    dueAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentSemesterPaymentHistoryUncheckedUpdateWithoutStudentSemesterPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    dueAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StudentSemesterPaymentHistoryUncheckedUpdateManyWithoutStudentSemesterPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionId?: StringFieldUpdateOperationsInput | string
    dueAmount?: IntFieldUpdateOperationsInput | number
    paidAmount?: IntFieldUpdateOperationsInput | number
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    isPaid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AcademicSemesterDefaultArgs instead
     */
    export type AcademicSemesterArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AcademicSemesterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicFacultyDefaultArgs instead
     */
    export type AcademicFacultyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AcademicFacultyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicDepartmentDefaultArgs instead
     */
    export type AcademicDepartmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AcademicDepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacultyDefaultArgs instead
     */
    export type FacultyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = FacultyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingDefaultArgs instead
     */
    export type BuildingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = BuildingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseToPrerequisiteDefaultArgs instead
     */
    export type CourseToPrerequisiteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CourseToPrerequisiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseFacultyDefaultArgs instead
     */
    export type CourseFacultyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CourseFacultyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SemesterRegistrationDefaultArgs instead
     */
    export type SemesterRegistrationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SemesterRegistrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferedCourseDefaultArgs instead
     */
    export type OfferedCourseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OfferedCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferedCourseSectionDefaultArgs instead
     */
    export type OfferedCourseSectionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OfferedCourseSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferedCourseClassScheduleDefaultArgs instead
     */
    export type OfferedCourseClassScheduleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OfferedCourseClassScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSemesterRegistrationDefaultArgs instead
     */
    export type StudentSemesterRegistrationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentSemesterRegistrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSemesterRegistrationCourseDefaultArgs instead
     */
    export type StudentSemesterRegistrationCourseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentSemesterRegistrationCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentEnrolledCourseDefaultArgs instead
     */
    export type StudentEnrolledCourseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentEnrolledCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentEnrolledCourseMarkDefaultArgs instead
     */
    export type StudentEnrolledCourseMarkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentEnrolledCourseMarkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSemesterPaymentDefaultArgs instead
     */
    export type StudentSemesterPaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentSemesterPaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSemesterPaymentHistoryDefaultArgs instead
     */
    export type StudentSemesterPaymentHistoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentSemesterPaymentHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentAcademicInfoDefaultArgs instead
     */
    export type StudentAcademicInfoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = StudentAcademicInfoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}